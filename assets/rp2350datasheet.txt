
Colophon
© 2023-2025 Raspberry Pi Ltd
This documentation is licensed under a Creative Commons Attribution-NoDerivatives 4.0 International  (CC BY-ND).
Portions Copyright © 2019 Synopsys, Inc.
All rights reserved. Used with permission. Synopsys & DesignWare are registered trademarks of Synopsys, Inc.
Portions Copyright © 2000-2001, 2005, 2007, 2009, 2011-2012, 2016 Arm Limited.
All rights reserved. Used with permission.
build-date: 2025-07-29
build-version: d126e9e-clean
Legal disclaimer notice
TECHNICAL AND RELIABILITY DATA FOR RASPBERRY PI PRODUCTS (INCLUDING DATASHEETS) AS MODIFIED FROM
TIME TO TIME ("RESOURCES") ARE PROVIDED BY RASPBERRY PI LTD ("RPL") "AS IS" AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE ARE DISCLAIMED. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW IN NO
EVENT SHALL RPL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
THE USE OF THE RESOURCES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
RPL reserves the right to make any enhancements, improvements, corrections or any other modifications to the
RESOURCES or any products described in them at any time and without further notice.
The RESOURCES are intended for skilled users with suitable levels of design knowledge. Users are solely responsible for
their selection and use of the RESOURCES and any application of the products described in them. User agrees to
indemnify and hold RPL harmless against all liabilities, costs, damages or other losses arising out of their use of the
RESOURCES.
RPL grants users permission to use the RESOURCES solely in conjunction with the Raspberry Pi products. All other use
of the RESOURCES is prohibited. No licence is granted to any other RPL or other third party intellectual property right.
HIGH RISK ACTIVITIES. Raspberry Pi products are not designed, manufactured or intended for use in hazardous
environments requiring fail safe performance, such as in the operation of nuclear facilities, aircraft navigation or
communication systems, air traffic control, weapons systems or safety-critical applications (including life support
systems and other medical devices), in which the failure of the products could lead directly to death, personal injury or
severe physical or environmental damage ("High Risk Activities"). RPL specifically disclaims any express or implied
warranty of fitness for High Risk Activities and accepts no liability for use or inclusions of Raspberry Pi products in High
Risk Activities.
Raspberry Pi products are provided subject to RPL’s Standard Terms . RPL’s provision of the RESOURCES does not
expand or otherwise modify RPL’s Standard Terms  including but not limited to the disclaimers and warranties
expressed in them.
RP2350 Datasheet
Legal disclaimer notice 1
Table of contents
Colophon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1
Legal disclaimer notice . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1
1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13
1.1. The chip . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14
1.2. Pinout reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15
1.2.1. Pin locations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15
1.2.2. Pin descriptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16
1.2.3. GPIO functions (Bank 0) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17
1.2.4. GPIO functions (Bank 1) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  21
1.3. Why is the chip called RP2350? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  22
1.4. Version History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  23
2. System bus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  24
2.1. Bus fabric . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  24
2.1.1. Bus priority . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  25
2.1.2. Bus security filtering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  25
2.1.3. Atomic register access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  26
2.1.4. APB bridge . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  26
2.1.5. Narrow IO register writes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  27
2.1.6. Global Exclusive Monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  28
2.1.7. Bus performance counters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  30
2.2. Address map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  30
2.2.1. ROM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  30
2.2.2. XIP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  30
2.2.3. SRAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  31
2.2.4. APB registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  31
2.2.5. AHB registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  33
2.2.6. Core-local peripherals (SIO) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  33
2.2.7. Cortex-M33 private peripherals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  34
3. Processor subsystem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  35
3.1. SIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  36
3.1.1. Secure and Non-secure SIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  37
3.1.2. CPUID . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  38
3.1.3. GPIO control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  39
3.1.4. Hardware spinlocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  41
3.1.5. Inter-processor FIFOs (Mailboxes) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  42
3.1.6. Doorbells . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  42
3.1.7. Integer divider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43
3.1.8. RISC-V platform timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43
3.1.9. TMDS encoder . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  44
3.1.10. Interpolator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  44
3.1.11. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  54
3.2. Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  82
3.2.1. Non-maskable interrupt (NMI) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  83
3.2.2. Further reading on interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  83
3.3. Event signals (Arm) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  84
3.4. Event signals (RISC-V) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  84
3.5. Debug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  84
3.5.1. Connecting to the SW-DP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  85
3.5.2. Arm debug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  86
3.5.3. RISC-V debug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  86
3.5.4. Debug power domains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  87
3.5.5. Software control of SWD pins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  87
3.5.6. Self-hosted debug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  87
3.5.7. Trace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  88
3.5.8. Rescue reset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  90
RP2350 Datasheet
Table of contents 2
3.5.9. Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  91
3.5.10. RP-AP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  93
3.6. Cortex-M33 coprocessors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  100
3.6.1. GPIO coprocessor (GPIOC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  101
3.6.2. Double-precision coprocessor (DCP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  104
3.6.3. Redundancy coprocessor (RCP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  112
3.6.4. Floating point unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  123
3.7. Cortex-M33 processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  123
3.7.1. Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  124
3.7.2. Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  124
3.7.3. Compliance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  128
3.7.4. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  131
3.7.5. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  148
3.8. Hazard3 processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  233
3.8.1. Instruction set reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  233
3.8.2. Memory access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  278
3.8.3. Memory protection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  279
3.8.4. Interrupts and exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  282
3.8.5. Debug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  285
3.8.6. Custom extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  286
3.8.7. Instruction cycle counts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  296
3.8.8. Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  302
3.8.9. Control and status registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  304
3.9. Arm/RISC-V architecture switching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  335
3.9.1. Automatic switching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  335
3.9.2. Mixed architecture combinations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  336
4. Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  337
4.1. ROM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  337
4.2. SRAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  337
4.2.1. Other on-chip memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  338
4.3. Boot RAM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  339
4.3.1. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  339
4.4. External flash and PSRAM (XIP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  340
4.4.1. XIP cache . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  341
4.4.2. QSPI Memory Interface (QMI) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  345
4.4.3. Streaming DMA interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  345
4.4.4. Performance counters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  346
4.4.5. List of XIP_CTRL registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  346
4.4.6. List of XIP_AUX registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  350
4.5. OTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  352
5. Bootrom . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  353
5.1. Bootrom concepts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  354
5.1.1. Secure and Non-secure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  354
5.1.2. Partition tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  354
5.1.3. Flash permissions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  355
5.1.4. Image definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  355
5.1.5. Blocks and block loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  356
5.1.6. Block versioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  357
5.1.7. A/B versions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  357
5.1.8. Hashing and signing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  357
5.1.9. Load maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  358
5.1.10. Packaged binaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  358
5.1.11. Anti-rollback protection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  359
5.1.12. Flash image boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  359
5.1.13. Flash partition boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  360
5.1.14. Partition-Table-in-Image boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  360
5.1.15. Flash boot slots . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  360
5.1.16. Flash update boot and version downgrade . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  361
5.1.17. Try before you buy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  362
5.1.18. UF2 targeting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  362
RP2350 Datasheet
Table of contents 3
5.1.19. Address translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  363
5.1.20. Automatic architecture switching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  364
5.2. Processor-controlled boot sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  365
5.2.1. Boot outcomes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  365
5.2.2. Sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  366
5.2.3. POWMAN boot vector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  371
5.2.4. Watchdog boot vector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  371
5.2.5. RAM image boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  372
5.2.6. OTP boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  373
5.2.7. Flash boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  373
5.2.8. BOOTSEL (USB/UART) boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  374
5.2.9. Boot configuration (OTP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  375
5.3. Launching code on Processor Core 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  375
5.4. Bootrom APIs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  376
5.4.1. Locating the API functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  376
5.4.2. API function availability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  378
5.4.3. API function return codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  378
5.4.4. API functions and exclusive access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  379
5.4.5. SDK access to the API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  380
5.4.6. Categorised list of API functions and ROM data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  380
5.4.7. Alphabetical list of API functions and ROM data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  382
5.4.8. API function listings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  383
5.5. USB mass storage interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  399
5.5.1. The RP2350 drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  399
5.5.2. UF2 format details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  400
5.5.3. UF2 targeting rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  401
5.6. USB PICOBOOT interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  403
5.6.1. Identifying the device . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  403
5.6.2. Identifying the interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  404
5.6.3. Identifying the endpoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  404
5.6.4. PICOBOOT Commands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  405
5.6.5. Control requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  410
5.7. USB white-labelling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  412
5.7.1. USB device descriptor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  413
5.7.2. USB device strings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  413
5.7.3. USB configuration descriptor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  413
5.7.4. MSD drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  413
5.7.5. UF2 INDEX.HTM  file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  413
5.7.6. UF2 INFO_UF2.TXT file . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  414
5.7.7. SCSI Inquiry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  414
5.7.8. Volume label simple example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  414
5.7.9. Volume label in-depth example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  415
5.8. UART boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  416
5.8.1. Baud rate and clock requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  416
5.8.2. UART boot shell protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  416
5.8.3. UART boot programming flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  417
5.8.4. Recovering from a stuck interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  417
5.8.5. Requirements for UART boot binaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  418
5.9. Metadata block details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  418
5.9.1. Blocks and block loops . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  418
5.9.2. Common block items . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  419
5.9.3. Image definition items . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  421
5.9.4. Partition table items . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  425
5.9.5. Minimum viable image metadata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  428
5.10. Example boot scenarios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  429
5.10.1. Secure boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  429
5.10.2. Signed images . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  430
5.10.3. Packaged binaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  433
5.10.4. A/B booting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  433
5.10.5. A/B booting with owned partitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  435
RP2350 Datasheet
Table of contents 4
5.10.6. Custom bootloader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  437
5.10.7. OTP bootloader . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  439
5.10.8. Rollback versions and bootloaders . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  440
6. Power . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  441
6.1. Power supplies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  441
6.1.1. Digital IO supply ( IOVDD). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  441
6.1.2. QSPI IO supply ( QSPI_IOVDD ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  441
6.1.3. Digital core supply ( DVDD). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  441
6.1.4. USB PHY and OTP supply ( USB_OTP_VDD ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  442
6.1.5. ADC supply ( ADC_AVDD ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  442
6.1.6. Core voltage regulator input supply ( VREG_VIN ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  442
6.1.7. On-chip voltage regulator analogue supply ( VREG_AVDD ). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  442
6.1.8. Power supply sequencing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  443
6.2. Power management . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  443
6.2.1. Core power domains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  443
6.2.2. Power states . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  444
6.2.3. Power state transitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  445
6.3. Core voltage regulator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  448
6.3.1. Operating modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  448
6.3.2. Software control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  449
6.3.3. Power Manager control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  449
6.3.4. Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  450
6.3.5. Current limit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  450
6.3.6. Over temperature protection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  450
6.3.7. Application circuit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  450
6.3.8. External components and PCB layout requirements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  452
6.3.9. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  457
6.4. Power management (POWMAN) registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  457
6.5. Power reduction strategies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  488
6.5.1. Top-level clock gates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  489
6.5.2. SLEEP state . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  489
6.5.3. DORMANT state . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  489
6.5.4. Memory periphery power down . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  490
6.5.5. Full memory power down . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  490
6.5.6. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  491
7. Resets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  494
7.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  494
7.2. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  494
7.3. Chip-level resets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  495
7.3.1. Chip-level reset table . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  495
7.3.2. Chip-level reset destinations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  496
7.3.3. Chip-level reset sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  496
7.4. System resets (Power-on State Machine) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  497
7.4.1. Reset sequence . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  498
7.4.2. Register control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  499
7.4.3. Interaction with watchdog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  499
7.4.4. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  499
7.5. Subsystem resets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  503
7.5.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  503
7.5.2. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  503
7.5.3. List of Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  505
7.6. Power-on resets and brownout detection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  508
7.6.1. Power-on reset (POR) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  509
7.6.2. Brownout detection (BOD) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  509
7.6.3. Supply monitor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  512
7.6.4. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  512
8. Clocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  513
8.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  513
8.1.1. Changes between RP2350 revisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  514
8.1.2. Clock sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  514
RP2350 Datasheet
Table of contents 5
8.1.3. Clock generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  518
8.1.4. Frequency counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  522
8.1.5. Resus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  522
8.1.6. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  523
8.1.7. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  529
8.2. Crystal oscillator (XOSC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  554
8.2.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  554
8.2.2. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  556
8.2.3. Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  556
8.2.4. Startup delay . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  556
8.2.5. XOSC counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  557
8.2.6. DORMANT mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  557
8.2.7. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  558
8.2.8. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  559
8.3. Ring oscillator (ROSC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  561
8.3.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  561
8.3.2. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  562
8.3.3. Changes between RP2350 revisions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  562
8.3.4. ROSC/XOSC trade-offs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  562
8.3.5. Modifying the frequency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  563
8.3.6. Randomising the frequency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  563
8.3.7. ROSC divider . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  563
8.3.8. Random number generator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  564
8.3.9. ROSC counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  564
8.3.10. DORMANT mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  564
8.3.11. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  565
8.4. Low Power oscillator (LPOSC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  569
8.4.1. Frequency accuracy and calibration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  569
8.4.2. Using an external low-power clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  570
8.4.3. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  570
8.5. Tick generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  570
8.5.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  570
8.5.2. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  571
8.6. PLL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  575
8.6.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  575
8.6.2. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  575
8.6.3. Calculating PLL parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  576
8.6.4. Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  580
8.6.5. List of Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  583
9. GPIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  587
9.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  587
9.2. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  588
9.3. Reset state . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  588
9.4. Function select . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  589
9.5. Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  594
9.6. Pads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  595
9.6.1. Bus keeper mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  596
9.7. Pad isolation latches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  596
9.8. Processor GPIO controls (SIO) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  597
9.9. GPIO coprocessor port . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  597
9.10. Software examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  598
9.10.1. Select an IO function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  598
9.10.2. Enable a GPIO interrupt . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  603
9.11. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  604
9.11.1. IO - User Bank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  604
9.11.2. IO - QSPI Bank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  760
9.11.3. Pad Control - User Bank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  785
9.11.4. Pad Control - QSPI Bank . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  812
10. Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  816
10.1. Overview (Arm) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  816
RP2350 Datasheet
Table of contents 6
10.1.1. Secure boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  816
10.1.2. Encrypted boot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  817
10.1.3. Isolating trusted and untrusted doftware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  818
10.2. Processor security features (Arm) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  819
10.2.1. Background . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  819
10.2.2. IDAU address map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  820
10.3. Overview (RISC-V) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  821
10.4. Processor security features (RISC-V) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  821
10.5. Secure boot enable procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  822
10.6. Access control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  822
10.6.1. GPIO access control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  823
10.6.2. Bus access control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  824
10.6.3. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  826
10.7. DMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  867
10.7.1. Channel security attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  868
10.7.2. Memory protection unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  868
10.7.3. DREQ attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  868
10.7.4. IRQ attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  868
10.8. OTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  869
10.9. Glitch detector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  869
10.9.1. Theory of operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  870
10.9.2. Trigger response . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  870
10.9.3. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  871
10.10. Factory test JTAG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  874
10.11. Decommissioning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  874
11. PIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  876
11.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  876
11.1.1. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  877
11.2. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  878
11.2.1. PIO programs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  879
11.2.2. Control flow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  879
11.2.3. Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  881
11.2.4. Autopull . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  881
11.2.5. Stalling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  884
11.2.6. Pin mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  884
11.2.7. IRQ flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  884
11.2.8. Interactions between state machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  885
11.3. PIO assembler (pioasm) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  885
11.3.1. Directives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  885
11.3.2. Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  887
11.3.3. Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  887
11.3.4. Comments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  888
11.3.5. Labels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  888
11.3.6. Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  888
11.3.7. Pseudo-instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  889
11.4. Instruction Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  889
11.4.1. Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  889
11.4.2. JMP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  890
11.4.3. WAIT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  891
11.4.4. IN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  892
11.4.5. OUT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  893
11.4.6. PUSH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  894
11.4.7. PULL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  895
11.4.8. MOV (to RX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  896
11.4.9. MOV (from RX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  897
11.4.10. MOV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  898
11.4.11. IRQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  900
11.4.12. SET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  901
11.5. Functional details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  902
11.5.1. Side-set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  902
RP2350 Datasheet
Table of contents 7
11.5.2. Program wrapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  903
11.5.3. FIFO joining . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  905
11.5.4. Autopush and Autopull . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  906
11.5.5. Clock Dividers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  911
11.5.6. GPIO mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  911
11.5.7. Forced and EXEC’d instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  913
11.6. Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  915
11.6.1. Duplex SPI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  915
11.6.2. WS2812 LEDs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  919
11.6.3. UART TX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  921
11.6.4. UART RX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  923
11.6.5. Manchester serial TX and RX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  926
11.6.6. Differential Manchester (BMC) TX and RX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  929
11.6.7. I2C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  932
11.6.8. PWM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  936
11.6.9. Addition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  938
11.6.10. Further examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  939
11.7. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  939
12. Peripherals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  961
12.1. UART . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  961
12.1.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  961
12.1.2. Functional description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  962
12.1.3. Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  964
12.1.4. UART hardware flow control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  966
12.1.5. UART DMA interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  967
12.1.6. Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  969
12.1.7. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  970
12.1.8. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  972
12.2. I2C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  983
12.2.1. Features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  984
12.2.2. IP configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  984
12.2.3. I2C overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  985
12.2.4. I2C terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  987
12.2.5. I2C behaviour . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  988
12.2.6. I2C protocols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  989
12.2.7. TX FIFO Management and START, STOP and RESTART Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  993
12.2.8. Multiple master arbitration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  995
12.2.9. Clock synchronisation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  995
12.2.10. Operation modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  996
12.2.11. Spike suppression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1001
12.2.12. Fast mode plus operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1002
12.2.13. Bus clear feature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1002
12.2.14. IC_CLK frequency configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1003
12.2.15. DMA controller interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1007
12.2.16. Operation of interrupt registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1008
12.2.17. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1008
12.3. SPI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1046
12.3.1. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1047
12.3.2. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1047
12.3.3. Functional description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1047
12.3.4. Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1050
12.3.5. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1060
12.4. ADC and Temperature Sensor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1066
12.4.1. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1068
12.4.2. ADC controller . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1069
12.4.3. SAR ADC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1069
12.4.4. ADC ENOB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1073
12.4.5. INL and DNL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1073
12.4.6. Temperature sensor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1073
12.4.7. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1073
RP2350 Datasheet
Table of contents 8
12.5. PWM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1076
12.5.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1077
12.5.2. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1077
12.5.3. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1086
12.6. DMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1094
12.6.1. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1095
12.6.2. Configuring channels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1096
12.6.3. Triggering channels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1098
12.6.4. Data request (DREQ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1100
12.6.5. Interrupts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1102
12.6.6. Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1102
12.6.7. Bus error handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1105
12.6.8. Additional features . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1107
12.6.9. Example use cases . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1108
12.6.10. List of Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1112
12.7. USB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1141
12.7.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1141
12.7.2. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1142
12.7.3. Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1144
12.7.4. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1155
12.7.5. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1159
12.8. System timers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1182
12.8.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1182
12.8.2. Counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1183
12.8.3. Alarms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1183
12.8.4. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1184
12.8.5. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1188
12.9. Watchdog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1193
12.9.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1193
12.9.2. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1193
12.9.3. Watchdog counter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1193
12.9.4. Control watchdog reset levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1194
12.9.5. Scratch registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1194
12.9.6. Programmer’s model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1194
12.9.7. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1196
12.10. Always-on timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1197
12.10.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1197
12.10.2. Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1198
12.10.3. Accessing the AON Timer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1198
12.10.4. Using the alarm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1198
12.10.5. Selecting the AON Timer tick source . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1199
12.10.6. Synchronising the AON timer to an external 1Hz clock . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1201
12.10.7. Using an external clock or tick from GPIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1201
12.10.8. Using a tick faster than 1ms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1201
12.10.9. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1202
12.11. HSTX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1202
12.11.1. Data FIFO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1203
12.11.2. Output shift register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1203
12.11.3. Bit crossbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1204
12.11.4. Clock generator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1205
12.11.5. Command expander . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1206
12.11.6. PIO-to-HSTX coupled mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1208
12.11.7. List of control registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1208
12.11.8. List of FIFO registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1212
12.12. TRNG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1212
12.12.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1212
12.12.2. Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1213
12.12.3. Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1213
12.12.4. Caveats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1214
12.12.5. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1215
RP2350 Datasheet
Table of contents 9
12.13. SHA-256 accelerator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1221
12.13.1. Message padding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1222
12.13.2. Throughput . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1222
12.13.3. Data size and endianness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1222
12.13.4. DMA DREQ interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1222
12.13.5. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1223
12.14. QSPI memory interface (QMI) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1226
12.14.1. Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1226
12.14.2. QSPI transfers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1228
12.14.3. Timing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1231
12.14.4. Address translation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1234
12.14.5. Direct mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1235
12.14.6. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1236
12.15. System Control Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1249
12.15.1. SYSINFO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1249
12.15.2. SYSCFG . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1251
12.15.3. TBMAN . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1254
12.15.4. BUSCTRL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1255
13. OTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1268
13.1. OTP address map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1268
13.1.1. Guarded reads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1269
13.2. Background: OTP IP details . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1269
13.3. Background: OTP hardware architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1270
13.3.1. Lock shim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1270
13.3.2. External interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1271
13.3.3. OTP boot oscillator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1272
13.3.4. Power-up state machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1272
13.4. Critical flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1273
13.5. Page locks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1274
13.5.1. Lock progression . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1274
13.5.2. OTP access keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1275
13.5.3. Lock encoding in OTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1276
13.5.4. Special pages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1276
13.5.5. Permissions of blank devices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1276
13.6. Error Correction Code (ECC) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1277
13.6.1. Bit repair by polarity (BRP) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1277
13.6.2. Modified Hamming ECC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1278
13.7. Device decommissioning (RMA) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1279
13.8. Imaging Vulnerability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1279
13.8.1. Best Practices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1279
13.8.2. Chaff . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1280
13.9. List of registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1280
13.10. Predefined OTP data locations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1292
14. Electrical and mechanical . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1327
14.1. QFN-60 package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1327
14.1.1. Thermal characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1328
14.1.2. Recommended PCB footprint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1328
14.2. QFN-80 package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1328
14.2.1. Thermal characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1329
14.2.2. Recommended PCB footprint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1329
14.3. Flash in package . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1330
14.4. Package markings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1331
14.5. Storage conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1331
14.6. Solder profile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1331
14.7. Compliance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1333
14.8. Pinout . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1333
14.8.1. Pin locations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1333
14.8.2. Pin definitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1335
14.9. Electrical specifications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1338
14.9.1. Absolute maximum ratings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1338
RP2350 Datasheet
Table of contents 10
14.9.2. ESD performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1339
14.9.3. Thermal performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1339
14.9.4. IO electrical characteristics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1339
14.9.5. Power supplies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1343
14.9.6. Core voltage regulator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1344
14.9.7. Power consumption . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1345
Appendix A: Register field types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
Changes from RP2040 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
Standard types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
RW:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
RO:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
WO:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
Clear types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
SC:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
WC:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1349
FIFO types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1350
RWF: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1350
RF:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1350
WF:. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1350
Appendix B: Units used in this document . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1351
Memory and storage capacity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1351
Transfer Rate . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1351
Physical Quantities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1351
Scale Prefixes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1353
Digit Separators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1353
Appendix C: Hardware revision history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1354
RP2350 A2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1354
RP2350 A3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1354
Hardware changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1354
Bootrom changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1355
RP2350 A4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1355
Hardware Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1355
Bootrom Changes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1356
Appendix E: Errata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1357
ACCESSCTRL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1357
RP2350-E3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1357
Bootrom . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1357
RP2350-E10 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1357
RP2350-E13 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1358
RP2350-E14 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1358
RP2350-E15 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1359
RP2350-E18 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1359
RP2350-E19 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1360
RP2350-E20 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1360
RP2350-E21 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1361
RP2350-E22 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1362
RP2350-E23 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1362
RP2350-E24 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1362
RP2350-E25 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1363
Bus Fabric . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1363
RP2350-E27 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1363
DMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1364
RP2350-E5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1364
RP2350-E8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1365
GPIO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1365
RP2350-E9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1366
Hazard3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1368
RP2350-E4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1368
RP2350-E6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1369
RP2350-E7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1369
RP2350 Datasheet
Table of contents 11
OTP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1370
RP2350-E16 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1370
RP2350-E17 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1371
RP2350-E28 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1371
RCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1372
RP2350-E26 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1372
SIO. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1373
RP2350-E1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1373
RP2350-E2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1373
XIP. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1374
RP2350-E11 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1374
USB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1375
RP2350-E12 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1375
Appendix H: Documentation release history . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1377
29 July 2025 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1377
20 February 2025 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1377
04 December 2024 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1377
16 October 2024 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1377
15 October 2024 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1377
6 September 2024 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1377
8 August 2024 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1378
RP2350 Datasheet
Table of contents 12
Chapter 1. Introduction
RP2350 is a new family of microcontrollers from Raspberry Pi that offers major enhancements over RP2040. Key
features include:
•Dual Cortex-M33 or Hazard3 processors at 150 MHz
•520 kB on-chip SRAM, in 10 independent banks
•8 kB of one-time-programmable storage (OTP)
•Up to 16 MB of external QSPI flash or PSRAM through dedicated QSPI bus
•Additional 16 MB flash or PSRAM through optional second chip-select
•On-chip switched-mode power supply to generate core voltage
•Optional low-quiescent-current LDO mode for sleep states
•2 × on-chip PLLs for internal or external clock generation
•GPIOs are 5 V-tolerant (powered) and 3.3 V-failsafe (unpowered)
•Security features:
◦Optional boot signing, enforced by on-chip mask ROM, with key fingerprint in OTP
◦Protected OTP storage for optional boot decryption key
◦Global bus filtering based on Arm or RISC-V security/privilege levels
◦Peripherals, GPIOs, and DMA channels individually assignable to security domains
◦Hardware mitigations for fault injection attacks
◦Hardware SHA-256 accelerator
•Peripherals:
◦2 × UARTs
◦2 × SPI controllers
◦2 × I2C controllers
◦24 × PWM channels
◦USB 1.1 controller and PHY, with host and device support
◦12 × PIO state machines
◦1 × HSTX peripheral
Table 1  shows the RP2350 family of devices, including options for QFN-80 (10 × 10 mm) and QFN-60 (7 × 7 mm)
packages, with and without flash-in-package.
Table 1. RP2350
device familyProduct Package Internal Flash GPIO Analogue Inputs
RP2350A QFN-60 None 30 4
RP2350B QFN-80 None 48 8
RP2354A QFN-60 2 MB 30 4
RP2354B QFN-80 2 MB 48 8
RP2350 Datasheet
Chapter 1. Introduction 13
1.1. The chip
Dual Cortex-M33 or Hazard3 processors access RP2350’s memory and peripherals via AHB and APB bus fabric.
IOs
PIO MemoryCrystalClock
generationProcessor subsystem
Peripherals
Bus FabricInternal 
oscillator
USBProc0
ROM
SRAMDMA
Core Supply Regulator
(Switcher and low 
power LDO)XIP / 
CacheSPI ×2
PWM
UART ×2
Timer
AON Timer
I2C ×2
ADC & TS
Reset control
Power control
Sysctrl
Sysinfo
Watchdog
Security
HSTXPLLPLL Interrupts
SWD
QSPIRP2350
SRAM
SRAM SRAM
SRAMOTP
SRAM SRAM
SRAM SRAM
SRAMProc1
PIO0 PIO1 PIO2
SIOGPIOFigure 1. A system
overview of the
RP2350 chip
Code may execute directly from external memory through a dedicated QSPI memory interface in the execute-in-place
subsystem (XIP). The cache improves XIP performance significantly. Both flash and RAM can attach via this interface.
Debug is available via the SWD interface. This allows an external host to load, run, halt and inspect software running on
the system, or configure the execution trace output.
Internal SRAM can contain code or data. It is addressed as a single 520 kB region, but physically partitioned into 10
banks to allow simultaneous parallel access from different managers. All SRAM supports single-cycle access.
A high-bandwidth system DMA offloads repetitive data transfer tasks from the processors.
GPIO pins can be driven directly via single-cycle IO (SIO), or from a variety of dedicated logic functions such as the
hardware SPI, I2C, UART and PWM. Programmable IO controllers (PIO) can provide a wider variety of IO functions, or
supplement the number of fixed-function peripherals.
A USB controller with embedded PHY provides FS/LS Host or Device connectivity under software control.
Four or eight ADC inputs (depending on package size) are shared with GPIO pins.
Two PLLs provide a fixed 48 MHz clock for USB or ADC, and a flexible system clock up to 150 MHz. A crystal oscillator
provides a precise reference for the PLLs.
An internal voltage regulator supplies the core voltage, so you need generally only supply the IO voltage. It operates as a
RP2350 Datasheet
1.1. The chip 14
switched mode buck converter when the system is awake, providing up to 200 mA at a variable output voltage, and can
switch to a low-quiescent-current LDO mode when the system is asleep, providing up to 1 mA for state retention.
The system features low-power states where unused logic is powered off, supporting wakeup from timer or IO events.
The amount of SRAM retained during power-down is configurable.
The internal 8 kB one-time-programmable storage (OTP) contains chip information such as unique identifiers, can be
used to configure hardware and bootrom security features, and can be programmed with user-supplied code and data.
The built-in bootrom implements direct boot from flash or OTP, and serial boot from USB or UART. Code signature
enforcement is supported for all boot media, using a key fingerprint registered in internal OTP storage. OTP can also
store decryption keys for encrypted boot, preventing flash contents from being read externally.
RISC-V architecture support is implemented by dynamically swapping the Cortex-M33 (Armv8-M) processors with
Hazard3 (RV32IMAC+) processors. Both architectures are available on all RP2350-family devices. The RISC-V cores
support debug over SWD, and can be programmed with the same SDK as the Arm cores.
1.2. Pinout reference
This section provides a quick reference for pinout and pin functions. Full details, including electrical specifications and
package drawings, can be found in Chapter 14 .
1.2.1. Pin locations
1.2.1.1. QFN-60 (RP2350A)
VREG_AVDDVREG_PGND
IOVDDGPIO18GPIO11GPIO10GND
TOP VIEW1
2
3
4
5
6
7
8
9
10
11
12
13
14
15GPIO9GPIO8IOVDDGPIO7GPIO6GPIO5GPIO4DVDDGPIO3GPIO2GPIO1GPIO0IOVDD
GPIO20GPIO21GPIO22GPIO23GPIO24GPIO25IOVDDDVDDGPIO26_ADC0GPIO27_ADC1GPIO28_ADC2GPIO29_ADC3ADC_AVDDIOVDDVREG_LXVREG_VINVREG_FBUSB_DMUSB_DPUSB_OTP_VDDQSPI_IOVDDQSPI_SD3QSPI_SCLKQSPI_SD0QSPI_SD2QSPI_SD1QSPI_SS
4560595857565554535251504948
16171819202122232425262728293044
43
42
41
40
39
38
37
36
35
34
33
32
GPIO1931GPIO17GPIO16RUNSWDIOSWCLKDVDDXOUTXINIOVDDGPIO15GPIO14GPIO13GPIO124746Figure 2. RP2350
Pinout for QFN-60
7×7mm (reduced ePad
size)
RP2350 Datasheet
1.2. Pinout reference 15
1.2.1.2. QFN-80 (RP2350B)
VREG_AVDDVREG_PGNDVREG_LXVREG_VINVREG_FBUSB_DMUSB_DP
RUNSWDIOGPIO11GPIO15GND
TOP VIEW1
2
3
4
5
6
7
8
9
10
11
12
13
14
15GPIO14GPIO13GPIO12
GPIO19GPIO1815
16
17
18
19
GPIO20 20GPIO17GPIO16IOVDDDVDDGPIO11GPIO10GPIO9GPIO8IOVDDGPIO7GPIO6GPIO5GPIO4
GPIO38GPIO39GPIO40_ADC0IOVDDDVDDGPIO41_ADC1GPIO42_ADC2GPIO43_ADC3GPIO44_ADC4GPIO45_ADC5GPIO46_ADC6GPIO47_ADC7ADC_AVDDIOVDDUSB_OTP_VDDQSPI_IOVDDQSPI_SD3QSPI_SCLKQSPI_SD0QSPI_SD2QSPI_SD1QSPI_SSIOVDDGPIO0GPIO1GPIO2GPIO3
6080797877767574737271706968
21222324252627282930313233343559
58
57
56
55
54
53
52
51
50
49
48
47SWCLKDVDDXOUT
GPIO32GPIO313637383940GPIO30GPIO29GPIO28XINIOVDDGPIO27GPIO26GPIO25GPIO24IOVDDGPIO23GPIO22GPIO2167666564636261
GPIO33GPIO34GPIO35GPIO36GPIO3746
45
44
43
42
IOVDD41Figure 3. RP2350
Pinout for QFN-80
10×10mm (reduced
ePad size)
1.2.2. Pin descriptions
Table 2. The function
of each pin is briefly
described here. Full
electrical
specifications can be
found in Chapter 14 .Name Description
GPIOx General-purpose digital input and output. RP2350 can connect one of a number of internal
peripherals to each GPIO, or control GPIOs directly from software.
GPIOx/ADCy General-purpose digital input and output, with analogue-to-digital converter function. The RP2350
ADC has an analogue multiplexer which can select any one of these pins, and sample the voltage.
QSPIx Interface to a SPI, Dual-SPI or Quad-SPI flash or PSRAM device, with execute-in-place support.
These pins can also be used as software-controlled GPIOs, if they are not required for flash
access.
USB_DM and
USB_DPUSB controller, supporting Full Speed device and Full/Low Speed host. A 27Ω series termination
resistor is required on each pin, but bus pullups and pulldowns are provided internally. These pins
can be used as software-controlled GPIOs, if USB is not required.
XIN and XOUT Connect a crystal to RP2350’s crystal oscillator. XIN can also be used as a single-ended CMOS
clock input, with XOUT disconnected. The USB bootloader defaults to a 12MHz crystal or 12MHz
clock input, but this can be configured via OTP.
RUN Global asynchronous reset pin. Reset when driven low, run when driven high. If no external reset is
required, this pin can be tied directly to IOVDD.
SWCLK and
SWDIOAccess to the internal Serial Wire Debug multi-drop bus. Provides debug access to both
processors, and can be used to download code.
GND Single external ground connection, bonded to a number of internal ground pads on the RP2350 die.
RP2350 Datasheet
1.2. Pinout reference 16
Name Description
IOVDD Power supply for digital GPIOs, nominal voltage 1.8V to 3.3V
USB_OTP_VDD Power supply for internal USB Full Speed PHY and OTP storage, nominal voltage 3.3V
ADC_AVDD Power supply for analogue-to-digital converter, nominal voltage 3.3V
QSPI_IOVDD Power supply for QSPI IOs, nominal voltage 1.8V to 3.3V
VREG_AVDD Analogue power supply for internal core voltage regulator, nominal voltage 3.3V
VREG_PGND Power-ground connection for internal core voltage regulator, tie to ground externally
VREG_LX Switched-mode output for internal core voltage regulator, connected to external inductor. Max
current 200 mA, nominal voltage 1.1V after filtering.
VREG_VIN Power input for internal core voltage regulator, nominal voltage 2.7V to 5.5V
VREG_FB Voltage feedback for internal core voltage regulator, connect to filtered VREG output (e.g. to DVDD,
if the regulator is used to supply DVDD)
DVDD Digital core power supply, nominal voltage 1.1V. Must be connected externally, either to the
voltage regulator output, or an external board-level power supply.
1.2.3. GPIO functions (Bank 0)
Each individual GPIO pin can be connected to an internal peripheral via the GPIO functions defined below. Some internal
peripheral connections appear in multiple places to allow some system level flexibility. SIO, PIO0, PIO1 and PIO2 can
connect to all GPIO pins and are controlled by software (or software controlled state machines) so can be used to
implement many functions.
RP2350 Datasheet
1.2. Pinout reference 17
Table 3. General
Purpose Input/Output
(GPIO) Bank 0
FunctionsGPIO F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11
0 SPI0 RX UART0 TX I2C0 SDA PWM0 A SIO PIO0 PIO1 PIO2 QMI CS1n USB OVCUR DET
1 SPI0 CSn UART0 RX I2C0 SCL PWM0 B SIO PIO0 PIO1 PIO2 TRACECLK USB VBUS DET
2 SPI0 SCK UART0 CTS I2C1 SDA PWM1 A SIO PIO0 PIO1 PIO2 TRACEDATA0 USB VBUS EN UART0 TX
3 SPI0 TX UART0 RTS I2C1 SCL PWM1 B SIO PIO0 PIO1 PIO2 TRACEDATA1 USB OVCUR DET UART0 RX
4 SPI0 RX UART1 TX I2C0 SDA PWM2 A SIO PIO0 PIO1 PIO2 TRACEDATA2 USB VBUS DET
5 SPI0 CSn UART1 RX I2C0 SCL PWM2 B SIO PIO0 PIO1 PIO2 TRACEDATA3 USB VBUS EN
6 SPI0 SCK UART1 CTS I2C1 SDA PWM3 A SIO PIO0 PIO1 PIO2 USB OVCUR DET UART1 TX
7 SPI0 TX UART1 RTS I2C1 SCL PWM3 B SIO PIO0 PIO1 PIO2 USB VBUS DET UART1 RX
8 SPI1 RX UART1 TX I2C0 SDA PWM4 A SIO PIO0 PIO1 PIO2 QMI CS1n USB VBUS EN
9 SPI1 CSn UART1 RX I2C0 SCL PWM4 B SIO PIO0 PIO1 PIO2 USB OVCUR DET
10 SPI1 SCK UART1 CTS I2C1 SDA PWM5 A SIO PIO0 PIO1 PIO2 USB VBUS DET UART1 TX
11 SPI1 TX UART1 RTS I2C1 SCL PWM5 B SIO PIO0 PIO1 PIO2 USB VBUS EN UART1 RX
12 HSTX SPI1 RX UART0 TX I2C0 SDA PWM6 A SIO PIO0 PIO1 PIO2 CLOCK GPIN0 USB OVCUR DET
13 HSTX SPI1 CSn UART0 RX I2C0 SCL PWM6 B SIO PIO0 PIO1 PIO2 CLOCK GPOUT0 USB VBUS DET
14 HSTX SPI1 SCK UART0 CTS I2C1 SDA PWM7 A SIO PIO0 PIO1 PIO2 CLOCK GPIN1 USB VBUS EN UART0 TX
15 HSTX SPI1 TX UART0 RTS I2C1 SCL PWM7 B SIO PIO0 PIO1 PIO2 CLOCK GPOUT1 USB OVCUR DET UART0 RX
16 HSTX SPI0 RX UART0 TX I2C0 SDA PWM0 A SIO PIO0 PIO1 PIO2 USB VBUS DET
17 HSTX SPI0 CSn UART0 RX I2C0 SCL PWM0 B SIO PIO0 PIO1 PIO2 USB VBUS EN
18 HSTX SPI0 SCK UART0 CTS I2C1 SDA PWM1 A SIO PIO0 PIO1 PIO2 USB OVCUR DET UART0 TX
19 HSTX SPI0 TX UART0 RTS I2C1 SCL PWM1 B SIO PIO0 PIO1 PIO2 QMI CS1n USB VBUS DET UART0 RX
20 SPI0 RX UART1 TX I2C0 SDA PWM2 A SIO PIO0 PIO1 PIO2 CLOCK GPIN0 USB VBUS EN
21 SPI0 CSn UART1 RX I2C0 SCL PWM2 B SIO PIO0 PIO1 PIO2 CLOCK GPOUT0 USB OVCUR DET
22 SPI0 SCK UART1 CTS I2C1 SDA PWM3 A SIO PIO0 PIO1 PIO2 CLOCK GPIN1 USB VBUS DET UART1 TXRP2350 Datasheet
1.2. Pinout reference 18 18
GPIO F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11
23 SPI0 TX UART1 RTS I2C1 SCL PWM3 B SIO PIO0 PIO1 PIO2 CLOCK GPOUT1 USB VBUS EN UART1 RX
24 SPI1 RX UART1 TX I2C0 SDA PWM4 A SIO PIO0 PIO1 PIO2 CLOCK GPOUT2 USB OVCUR DET
25 SPI1 CSn UART1 RX I2C0 SCL PWM4 B SIO PIO0 PIO1 PIO2 CLOCK GPOUT3 USB VBUS DET
26 SPI1 SCK UART1 CTS I2C1 SDA PWM5 A SIO PIO0 PIO1 PIO2 USB VBUS EN UART1 TX
27 SPI1 TX UART1 RTS I2C1 SCL PWM5 B SIO PIO0 PIO1 PIO2 USB OVCUR DET UART1 RX
28 SPI1 RX UART0 TX I2C0 SDA PWM6 A SIO PIO0 PIO1 PIO2 USB VBUS DET
29 SPI1 CSn UART0 RX I2C0 SCL PWM6 B SIO PIO0 PIO1 PIO2 USB VBUS EN
GPIOs 30 through 47 are QFN-80 only:
30 SPI1 SCK UART0 CTS I2C1 SDA PWM7 A SIO PIO0 PIO1 PIO2 USB OVCUR DET UART0 TX
31 SPI1 TX UART0 RTS I2C1 SCL PWM7 B SIO PIO0 PIO1 PIO2 USB VBUS DET UART0 RX
32 SPI0 RX UART0 TX I2C0 SDA PWM8 A SIO PIO0 PIO1 PIO2 USB VBUS EN
33 SPI0 CSn UART0 RX I2C0 SCL PWM8 B SIO PIO0 PIO1 PIO2 USB OVCUR DET
34 SPI0 SCK UART0 CTS I2C1 SDA PWM9 A SIO PIO0 PIO1 PIO2 USB VBUS DET UART0 TX
35 SPI0 TX UART0 RTS I2C1 SCL PWM9 B SIO PIO0 PIO1 PIO2 USB VBUS EN UART0 RX
36 SPI0 RX UART1 TX I2C0 SDA PWM10 A SIO PIO0 PIO1 PIO2 USB OVCUR DET
37 SPI0 CSn UART1 RX I2C0 SCL PWM10 B SIO PIO0 PIO1 PIO2 USB VBUS DET
38 SPI0 SCK UART1 CTS I2C1 SDA PWM11 A SIO PIO0 PIO1 PIO2 USB VBUS EN UART1 TX
39 SPI0 TX UART1 RTS I2C1 SCL PWM11 B SIO PIO0 PIO1 PIO2 USB OVCUR DET UART1 RX
40 SPI1 RX UART1 TX I2C0 SDA PWM8 A SIO PIO0 PIO1 PIO2 USB VBUS DET
41 SPI1 CSn UART1 RX I2C0 SCL PWM8 B SIO PIO0 PIO1 PIO2 USB VBUS EN
42 SPI1 SCK UART1 CTS I2C1 SDA PWM9 A SIO PIO0 PIO1 PIO2 USB OVCUR DET UART1 TX
43 SPI1 TX UART1 RTS I2C1 SCL PWM9 B SIO PIO0 PIO1 PIO2 USB VBUS DET UART1 RX
44 SPI1 RX UART0 TX I2C0 SDA PWM10 A SIO PIO0 PIO1 PIO2 USB VBUS ENRP2350 Datasheet
1.2. Pinout reference 19 19
GPIO F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11
45 SPI1 CSn UART0 RX I2C0 SCL PWM10 B SIO PIO0 PIO1 PIO2 USB OVCUR DET
46 SPI1 SCK UART0 CTS I2C1 SDA PWM11 A SIO PIO0 PIO1 PIO2 USB VBUS DET UART0 TX
47 SPI1 TX UART0 RTS I2C1 SCL PWM11 B SIO PIO0 PIO1 PIO2 QMI CS1n USB VBUS EN UART0 RXRP2350 Datasheet
1.2. Pinout reference 20 20
Table 4. GPIO bank 0
function descriptionsFunction Name Description
SPIx Connect one of the internal PL022 SPI peripherals to GPIO
UARTx Connect one of the internal PL011 UART peripherals to GPIO
I2Cx Connect one of the internal DW I2C peripherals to GPIO
PWMx A/B Connect a PWM slice to GPIO. There are twelve PWM slices, each with two output
channels (A/B). The B pin can also be used as an input, for frequency and duty cycle
measurement.
SIO Software control of GPIO, from the single-cycle IO (SIO) block. The SIO function ( F5)
must be selected for the processors to drive  a GPIO, but the input is always connected,
so software can check the state of GPIOs at any time.
PIOx Connect one of the programmable IO blocks (PIO) to GPIO. PIO can implement a wide 
variety of interfaces, and has its own internal pin mapping hardware, allowing flexible
placement of digital interfaces on bank 0 GPIOs. The PIO function ( F6, F7, F8) must be
selected for PIO to drive  a GPIO, but the input is always connected, so the PIOs can
always see the state of all pins.
HSTX Connect the high-speed transmit peripheral (HSTX) to GPIO
CLOCK GPINx General purpose clock inputs. Can be routed to a number of internal clock domains on
RP2350, e.g. to provide a 1Hz clock for the AON Timer, or can be connected to an
internal frequency counter.
CLOCK GPOUTx General purpose clock outputs. Can drive a number of internal clocks (including PLL
outputs) onto GPIOs, with optional integer divide.
TRACECLK, TRACEDATAx CoreSight TPIU execution trace output from Cortex-M33 processors (Arm-only)
USB OVCUR DET/VBUS
DET/VBUS ENUSB power control signals to/from the internal USB controller
QMI CS1n Auxiliary chip select for QSPI bus, to allow execute-in-place from an additional flash or
PSRAM device
NOTE
GPIOs 0 through 29 are available in all package variants. GPIOs 30 through 47 are available only in QFN-80
(RP2350B) package.
NOTE
Analogue input is available on GPIOs 26 through 29 in the QFN-60 package (RP2350A), for a total of four inputs, and
on GPIOs 40 through 47 in the QFN-80 package (RP2350B), for a total of eight inputs.
1.2.4. GPIO functions (Bank 1)
GPIO functions are also available on the six dedicated QSPI pins, which are usually used for flash execute-in-place, and
on the USB DP/DM pins. These may become available for general-purpose use depending on the use case, for example,
QSPI pins may not be needed for code execution if RP2350 is booting from internal OTP storage, or being controlled
externally via SWD.
Table 5. GPIO Bank 1
FunctionsPin F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11
USB DP UART1 TX I2C0 SDA SIO
RP2350 Datasheet
1.2. Pinout reference 21
Pin F0 F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11
USB DM UART1 RX I2C0 SCL SIO
QSPI SCK QMI SCK UART1 CTS I2C1 SDA SIO UART1 TX
QSPI CSn QMI CS0n UART1 RTS I2C1 SCL SIO UART1 RX
QSPI SD0 QMI SD0 UART0 TX I2C0 SDA SIO
QSPI SD1 QMI SD1 UART0 RX I2C0 SCL SIO
QSPI SD2 QMI SD2 UART0 CTS I2C1 SDA SIO UART0 TX
QSPI SD3 QMI SD3 UART0 RTS I2C1 SCL SIO UART0 RX
Table 6. GPIO bank 1
function descriptionsFunction Name Description
UARTx Connect one of the internal PL011 UART peripherals to GPIO
I2Cx Connect one of the internal DW I2C peripherals to GPIO
SIO Software control of GPIO, from the single-cycle IO (SIO) block. The SIO function ( F5) must be selected
for the processors to drive  a GPIO, but the input is always connected, so software can check the state
of GPIOs at any time.
QMI QSPI memory interface peripheral, used for execute-in-place from external QSPI flash or PSRAM
memory devices.
1.3. Why is the chip called RP2350?
RP 2 3 5 0 
Raspberry PiNumber of coresType of core (e.g. Cortex-M33)floor(log2(RAM / 16 kB))floor(log2(nonvolatile / 128 kB))Figure 4. An
explanation for the
name of the RP2350
chip.
The post-fix numeral on RP2350 comes from the following,
1.Number of processor cores
◦2 indicates a dual-core system
2.Loosely which type of processor
◦3 indicates Cortex-M33 or Hazard3
3.Internal memory capacity: 
 
◦5 indicates at least 25 × 16 kB = 512 kB
◦RP2350 has 520 kB of main system SRAM
4.Internal storage capacity: 
  (or 0 if no onboard nonvolatile storage)
RP2350 Datasheet
1.3. Why is the chip called RP2350? 22
◦RP235 0 uses external flash
◦RP235 4 has 24 × 128 kB = 2 MB of internal flash
1.4. Version History
Table 7  lists versions of RP2350. Later versions fix bugs in earlier versions. For more information about the changes
made between versions, see Appendix C . Also refer to Product Change Notification (PCN) 28.
Table 7. RP2350
version historyVersion Use
A0 Internal development
A1 Internal development
A2 Initial release
A3 Internal development, samples, and limited production
A4 Production version
RP2350 Datasheet
1.4. Version History 23
Chapter 2. System bus
2.1. Bus fabric
The RP2350 bus fabric routes addresses and data across the chip.
Figure 5  shows the high-level structure of the bus fabric. The main AHB5 crossbar routes addresses and data between
its 6 upstream ports and 17 downstream ports, with up to six bus transfers taking place each cycle. All data paths are
32 bits wide. Memories connect to multiple dedicated ports on the main crossbar, for the best possible memory
bandwidth. High-bandwidth AHB peripherals share a port on the crossbar. An APB bridge provides access to system
control registers and lower-bandwidth peripherals. The SIO peripherals are accessed via a dedicated path from each
processor.
DMA
R WCore 0
I DCore 1
Global Exclusivity 
Monitor
SIO UART0UART1I2C0 I2C1 SPI0 SPI1 PWM PIO0 PIO1 PIO2 USB Timer0 QSPI Memory InterfaceAHB5 Crossbar
APB Splitter Arbiter AHB5 SplitterXIP Cache 
16 kB WBack 
2-way 2-bankCore 0Port DOnly
Core 1Port DOnlySRAM0–3 4 × 64 kB
Word-stripedSRAM8–9 
2× 4 kBAHB5 
to APBROM 32 kBI D
TraceFIFOXIP AuxOther APBSRAM Write Kill (SRAM0–9)Exclusive Query/ Response
DMACtrlSRAM4–7 4 × 64 kB
Word-stripedFigure 5. RP2350 bus
fabric overview.
The bus fabric connects 6 AHB5 managers, i.e. bus ports which generate addresses:
•Core 0: Instruction port (instruction fetch), and Data port (load/store access)
•Core 1: Instruction port (instruction fetch), and Data port (load/store access)
•DMA controller: Read port, Write port
The following 13 downstream ports are symmetrically accessible from all 6 upstream ports:
•Boot ROM (1 port)
•XIP (2 ports, striped)
•SRAM (10 ports, striped)
Additionally, the following 2 ports are accessible for processor load/store and DMA read/write only:
•1 shared port for fast AHB5 peripherals: PIO0, PIO1, PIO2, USB, DMA control registers, XIP DMA FIFOs, HSTX FIFO,
CoreSight trace DMA FIFO
•1 port for the APB bridge, to all APB peripherals and control registers
RP2350 Datasheet
2.1. Bus fabric 24
NOTE
Instruction fetch from peripherals is physically disconnected , to avoid this IDAU-Exempt region ever becoming both
Non-secure-writable and Secure-executable. This includes USB RAM, OTP and boot RAM. See Section 10.2.2 .
The SIO block, which was connected to the Cortex-M0+ IOPORT on RP2040, provides two AHB ports, each dedicated to
load/store access from one core.
The six managers can access any six different  crossbar ports simultaneously. So, at a system clock of 150 MHz, the
maximum sustained bus bandwidth is 3.6 GB/s.
2.1.1. Bus priority
The main AHB5 crossbar implements a two-level bus priority scheme. Priority levels are configured separately for core
0, core 1, DMA read and DMA write, using the BUS_PRIORITY  register in the BUSCTRL register block.
When a downstream subordinate receives multiple simultaneous access requests, the port serves high-priority (priority
level 1) managers before serving any requests from low-priority (priority 0) managers. If all requests come from
managers with the same priority level, the port applies a round-robin tie break, granting access to each manager in turn.
NOTE
Priority arbitration only applies when multiple managers attempt to access the same  subordinate on the same cycle.
When multiple managers access different subordinates, e.g. different SRAM banks, the requests proceed
simultaneously.
A subordinate with zero wait states can be accessed once per system clock cycle. When accessing a subordinate with
zero wait states (e.g. SRAM), high-priority managers never experience delays caused by accesses from low-priority
managers. This guarantees  latency and throughput for real-time use cases. However, it also means that low-priority
managers may stall until there is a free cycle.
2.1.2. Bus security filtering
Every point where the fabric connects to a downstream AHB or APB peripheral is interposed by a bus security filter,
which enforces the following access control lists as defined by the ACCESSCTRL registers ( Section 10.6 ):
•A list of who can access the port: core 0, core 1, DMA, debugger
•A list of the security states from which the port can be accessed: the four combinations of Secure/Non-secure and
Privileged/Unprivileged.
Accesses that fail either check are prevented from accessing the downstream port, and return a bus error upstream.
There are three exceptions, which do not implement bus security filters because they implement their own security
filtering internally:
•The ACCESSCTRL block itself, which is always world-readable, but filters writes on security and privilege
•Boot RAM, which is hardwired to Secure access only
•The single-cycle IO subsystem (SIO), which is internally banked over Secure and Non-secure
The Cortex-M Private Peripheral Bus (PPB) registers also lack ACCESSCTRL permissions because they are internal to
the processors, not accessed through the system bus. The PPB registers are internally banked over Secure and Non-
secure.
RP2350 Datasheet
2.1. Bus fabric 25
2.1.3. Atomic register access
Each peripheral register block is allocated 4 kB of address space, with registers accessed using one of 4 methods,
selected by address decode.
•Addr + 0x0000  : normal read write access
•Addr + 0x1000  : atomic XOR on write
•Addr + 0x2000  : atomic bitmask set on write
•Addr + 0x3000  : atomic bitmask clear on write
This allows software to modify individual fields of a control register without performing a read-modify-write sequence.
Instead, the peripheral itself modifies its contents in-place. Without this capability, it is difficult to safely access IO
registers when an interrupt service routine is concurrent with code running in the foreground, or when the two
processors run code in parallel.
The four atomic access aliases occupy a total of 16 kB. Native atomic writes take the same number of clock cycles as
normal writes. Most peripherals on RP2350 provide this functionality natively, but some peripherals (I2C, UART, SPI and
SSI) add this functionality using a bus interposer. The bus interposer translates upstream atomic writes into
downstream read-modify-write sequences at the boundary of the peripheral, at the cost of additional clock cycles.
Atomic writes that use a bus interposer take two additional clock cycles compared to normal writes.
The following registers do not support atomic register access:
•SIO ( Section 3.1 ), though some individual registers (for example, GPIO) have set, clear, and XOR aliases.
•Any register accessed through the self-hosted CoreSight window, including Arm Mem-APs and the RISC-V Debug
Module.
•Standard Arm control registers on the Cortex-M33 private peripheral bus (PPB), except for Raspberry Pi-specific
registers on the EPPB.
•OTP programming registers accessed through the SBPI bridge.
2.1.4. APB bridge
The APB bridge provides an interface between the high-speed main AHB5 interconnect and the lower-bandwidth
peripherals. Unlike the AHB5 fabric, which offers zero-wait-state accesses everywhere, APB accesses take a minimum
of three cycles for a read, and four cycles for a write.
As a result, the throughput of the APB portion of the bus fabric is lower than the AHB5 portion. However, there is more
than sufficient bandwidth to saturate the APB serial peripherals.
The following APB ports contain asynchronous bus crossings, which insert additional stall cycles on top of the typical
cost of a read or write in the APB bridge:
•ADC
•HSTX_CTRL
•OTP
•POWMAN
The APB bridge implements a fixed timeout for stalled downstream transfers. The downstream bus may stall
indefinitely, such as when accessing an asynchronous bus crossing when the destination clock is stopped, or deadlock
conditions when accessing system APB registers through Mem-APs in the self-hosted debug window ( Section 3.5.6 ).
When an APB transfer exceeds 65,535 cycles the APB bridge abandons the transfer and returns a bus fault. This keeps
the system bus available so that software or the debugger can diagnose the reason for the overly long transfer.
RP2350 Datasheet
2.1. Bus fabric 26
2.1.5. Narrow IO register writes
The majority of memory-mapped IO registers on RP2350 ignore the width of bus read/write accesses. They treat all
writes as though they were 32 bits in size. This means software cannot use byte or halfword writes to modify part of an
IO register: any write to an address where the 30 address MSBs match the register address affects the contents of the
entire register.
To update part of an IO register without a read-modify-write sequence, the best solution on RP2350 is atomic
set/clear/XOR (see Section 2.1.3 ). This is more flexible than byte or halfword writes, as any combination of fields can be
updated in one operation.
Upon a 8-bit or 16-bit write (such as a strb instruction on the Cortex-M33), the narrow value is replicated multiple times
across the 32-bit data bus, so that it is broadcast to all 8-bit or 16-bit segments of the destination register:
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/system/narrow_io_write/narrow_io_write.c  Lines 19 - 62
19 int main() {
20     stdio_init_all ();
21 
22     // We'll use WATCHDOG_SCRATCH0 as a convenient 32 bit read/write register
23     // that we can assign arbitrary values to
24     io_rw_32  *scratch32  = &watchdog_hw ->scratch[0];
25     // Alias the scratch register as two halfwords at offsets +0x0 and +0x2
26     volatile  uint16_t  *scratch16  = (volatile  uint16_t  *) scratch32 ;
27     // Alias the scratch register as four bytes at offsets +0x0, +0x1, +0x2, +0x3:
28     volatile  uint8_t *scratch8  = (volatile  uint8_t *) scratch32 ;
29 
30     // Show that we can read/write the scratch register as normal:
31     printf("Writing 32 bit value \n");
32     *scratch32  = 0xdeadbeef ;
33     printf("Should be 0xdeadbeef: 0x%08x \n", *scratch32 );
34 
35     // We can do narrow reads just fine -- IO registers treat this as a 32 bit
36     // read, and the processor/DMA will pick out the correct byte lanes based
37     // on transfer size and address LSBs
38     printf("\nReading back 1 byte at a time \n");
39     // Little-endian!
40     printf("Should be ef be ad de: %02x " , scratch8 [0]);
41     printf("%02x ", scratch8 [1]);
42     printf("%02x ", scratch8 [2]);
43     printf("%02x\n", scratch8 [3]);
44 
45     // Byte writes are replicated four times across the 32-bit bus, and IO
46     // registers usually sample the entire write bus.
47     printf("\nWriting 8 bit value 0xa5 at offset 0 \n");
48     scratch8 [0] = 0xa5;
49     // Read back the whole scratch register in one go
50     printf("Should be 0xa5a5a5a5: 0x%08x \n", *scratch32 );
51 
52     // The IO register ignores the address LSBs [1:0] as well as the transfer
53     // size, so it doesn't matter what byte offset we use
54     printf("\nWriting 8 bit value at offset 1 \n");
55     scratch8 [1] = 0x3c;
56     printf("Should be 0x3c3c3c3c: 0x%08x \n", *scratch32 );
57 
58     // Halfword writes are also replicated across the write data bus
59     printf("\nWriting 16 bit value at offset 0 \n");
60     scratch16 [0] = 0xf00d;
61     printf("Should be 0xf00df00d: 0x%08x \n", *scratch32 );
62 }
To disable this behaviour on RP2350, set bit 14 of the address by accessing the peripheral at an offset of +0x4000. This
RP2350 Datasheet
2.1. Bus fabric 27
causes invalid byte lanes to be driven to zero, rather than being driven with replicated data. In some situations, such as
DMA of 8-bit values to the PWM peripheral, the default replication behaviour is not desirable.
2.1.6. Global Exclusive Monitor
The Global Exclusive Monitor enables standard Arm and RISC-V atomic instructions to safely access shared variables in
SRAM from both cores. This underpins software libraries for manipulating shared variables, such as stdatomic.h  in C11.
For detailed rules governing the monitor’s operation, see the Armv8-M Architecture Reference Manual .
Arm describes exclusive monitor interactions in terms of a processing element , PE, which performs a sequence of bus
accesses. For RP2350 purposes, this is one AHB5 manager out of the following three: core 0 load/store, core 1
load/store, and DMA write. The DMA does not itself perform exclusive accesses, but its writes are monitored with
respect to exclusive sequences on either processor. No distinction is made between debugger and non-debugger
accesses from a processor.
The monitor observes all transfers on SRAM initiated by the DMA write and processor load/store ports, and pays
particular attention to two types of transfer:
•AHB5 exclusive reads : Arm ldrex* instructions, RISC-V lr.w instructions, and the read phase of RISC-V AMOs (The
Hazard3 cores on RP2350 implement AMOs as an exclusive read/write pair that retries until the write succeeds).
•AHB5 exclusive writes : Arm strex* instructions, RISC-V sc.w instructions, and the writeback phase of RISC-V AMOs
Based on these observations, the monitor enforces that an atomic read-modify-write sequence (formed of an exclusive
read followed by a successful exclusive write by the same PE) is not interleaved with another PE’s successful write
(exclusive or not) to the same reservation granule. A reservation granule is any 16-byte, naturally aligned area of SRAM.
An exclusive write succeeds when all of the following are true:
•It is preceded by an exclusive read by the same PE
•No other exclusive writes were performed by this PE since that exclusive read
•The exclusive read was to the same reservation granule
•The exclusive read was of the same size (byte/halfword/word)
•The exclusive read was from the same security and privilege state
•No other PEs successfully wrote to the same granule since that exclusive read
If the above conditions are not met, the Global Exclusive Monitor shoots down the exclusive write before SRAM can
commit the write data. The failure is reported to the originating PE, for example by a non-zero return value from an Arm
strex instruction.
This implementation of the Armv8-M Global Exclusive Monitor also meets the requirements for RISC-V lr/sc and amo*
instructions, with the caveat that the RsrvEventual  PMA is not supported. (In practice, whilst it is quite easy to come up
with contrived examples of starvation such as the DMA writing to a shared variable on every single cycle, bounded
LR/SC and AMO sequences will generally complete quickly.)
CAUTION
Secure software should avoid shared variables in Non-secure-accessible memory. Such variables are vulnerable to
deliberate starvation from exclusive accesses by repeatedly performing non-exclusive writes.
Exclusive accesses are only supported on SRAM. The system treats exclusive accesses to other memory regions as
normal reads and writes, reporting exclusivity failure to the originating PE, for example by a non-zero return value from
an Arm strex instruction.
RP2350 Datasheet
2.1. Bus fabric 28
2.1.6.1. Implementation-defined monitor behaviour
The Armv8-M Architecture Reference Manual  leaves several aspects of the Global Exclusive Monitor up to the
implementation. For completeness, the RP2350 implementation defines them as follows:
•The reservation granule size is fixed at 16 bytes
•A single reservation is tracked per PE
•The Arm clrex instruction does not affect global monitor state
•Any exclusive write by a PE clears that PE’s global reservation
•A non-exclusive write by a PE does not clear that PE’s global reservation, no matter the address
Only the following updates a PE’s reservation tag, setting its reservation state to Exclusive :
•An exclusive read on SRAM
Only the following changes a PE’s reservation state from Exclusive  to Open :
•A successful  exclusive write from another PE to this PE’s reservation
•A non-exclusive write from another PE to this PE’s reservation
•Any exclusive write by this PE
•An exclusive read by this PE, not on SRAM
A reservation granule can span multiple SRAM banks, so multiple operations on the same reservation granule may
complete on the same cycle. This can result in the following problematic situations:
•Multiple exclusive writes to the same reservation granule, reserved on each PE: in this case the lowest-numbered
PE succeeds (in the order DMA < core 0 < core 1), and all others fail.
•A mixture of non-exclusive and exclusive writes to the same reservation granule on the same cycle: in this case,
the exclusive writes fail.
•One PE x can write to a reservation granule on the same cycle that another PE y attempts to reserve the same 
reservation granule via exclusive load: in this case, y's reservation is granted (i.e. the write takes place logically
before the load).
•One PE x can write to a reservation granule reserved by another PE y, on the same cycle that PE y makes a new
reservation on a different  reservation granule: in this case, again, y's reservation is granted.
These rules can be summarised by a logical  ordering of all possible events on a reservation granule that can occur on
the same cycle: first all normal writes in arbitrary order, then all exclusive writes in ascending PE order (DMA, core 0,
core 1), then all loads in arbitrary order.
2.1.6.2. Regions without exclusives support
The Global Exclusive monitor only supports exclusive transactions on certain address ranges. The main system SRAM
supports exclusive transactions throughout its entire range: 0x20000000  through 0x20082000 . Within ranges that support
exclusive transactions, the Global Exclusive monitor:
•Tracks exclusive sequences across all participating PEs.
•Drives the exclusive success/failure response correctly based on the observed ordering.
•Shoots down failing exclusive writes so that they have no effect.
Exclusive transactions aren’t supported outside of this range; all exclusive accesses report exclusive failure (both
exclusive reads and exclusive writes), and exclusive writes aren’t suppressed.
Outside of regions with exclusive transaction support, load/store exclusive loops run forever while still affecting SRAM
contents. This applies to both Arm processors performing exclusive reads/writes and RISC-V processors performing
lr.w/sc.w instructions. However, an amo*.w instruction on Hazard3 will result in a Store/AMO Fault, as the hardware
RP2350 Datasheet
2.1. Bus fabric 29
detects the failed exclusive read and bails out to avoid an infinite loop.
It is recommended not to perform exclusive accesses on regions outside of main SRAM. Shared variables outside of
main SRAM can be protected using either lock variables in main SRAM, the SIO spinlocks, or a locking protocol that
does not require exclusive accesses, such as a lock-free queue.
2.1.7. Bus performance counters
Bus performance counters automatically count accesses to the main AHB5 crossbar arbiters. These counters can help
diagnose high-traffic performance issues.
There are four performance counters, starting at PERFCTR0 . Each is a 24-bit saturating counter. Counter values can be
read from BUSCTRL_PERFCTRx  and cleared by writing any value to BUSCTRL_PERFCTRx . Each counter can count one of the 20
available events at a time, as selected by BUSCTRL_PERFSELx . For more information, see Section 12.15.4 .
2.2. Address map
The address map for the device is split into sections as shown in Table 8 . Details are shown in the following sections.
Unmapped address ranges raise a bus error when accessed.
Each link in the left-hand column of Table 8  goes to a detailed address map for that address range. The detailed
address maps have a link for each address to the relevant documentation for that address.
Rough address decode is first performed on bits 31:28 of the address:
Table 8. Address Map
SummaryBus Segment Base Address
ROM 0x00000000
XIP 0x10000000
SRAM 0x20000000
APB Peripherals 0x40000000
AHB Peripherals 0x50000000
Core-local Peripherals (SIO) 0xd0000000
Cortex-M33 private registers 0xe0000000
2.2.1. ROM
ROM is accessible to DMA, processor load/store, and processor instruction fetch. It is located at address zero, which is
the starting point for both Arm processors when the device is reset.
Table 9. Address map
for ROM bus segmentBus Endpoint Base Address
ROM_BASE 0x00000000
2.2.2. XIP
XIP is accessible to DMA, processor load/store, and processor instruction fetch. This address range contains various
mirrors of a 64 MB space which is mapped to external memory devices. On RP2350 the lower 32 MB is occupied by the
QSPI Memory Interface (QMI), and the remainder is reserved. QMI controls are in the APB register section.
RP2350 Datasheet
2.2. Address map 30
Table 10. Address
map for XIP bus
segmentBus Endpoint Base Address
XIP_BASE 0x10000000
XIP_NOCACHE_NOALLOC_BASE 0x14000000
XIP_MAINTENANCE_BASE 0x18000000
XIP_NOCACHE_NOALLOC_NOTRANSLATE_BASE 0x1c000000
NOTE
XIP_SRAM_BASE  no longer exists as a separate address range. Cache-as-SRAM is now achieved by pinning cache lines
within the cached XIP address space.
2.2.3. SRAM
SRAM is accessible to DMA, processor load/store, and processor instruction fetch.
SRAM0-3 and SRAM4-7 are always striped on bits 3:2 of the address:
Table 11. Address
map for SRAM bus
segment, SRAM0-7
(striped)Bus Endpoint Base Address
SRAM_BASE 0x20000000
SRAM_STRIPED_BASE 0x20000000
SRAM0_BASE 0x20000000
SRAM4_BASE 0x20040000
SRAM_STRIPED_END 0x20080000
There are two striped regions, each 256 kB in size, and each striped over 4 SRAM banks. SRAM0-3 are in the SRAM0
power domain, and SRAM4-7 are in the SRAM1 power domain.
SRAM 8-9 are always non-striped:
Table 12. Address
map for SRAM bus
segment, SRAM8-9
(non-striped)Bus Endpoint Base Address
SRAM8_BASE 0x20080000
SRAM9_BASE 0x20081000
SRAM_END 0x20082000
These smaller blocks of SRAM are useful for hoisting high-bandwidth data structures like the processor stacks. They
are in the SRAM1 power domain.
2.2.4. APB registers
APB peripheral registers are accessible to processor load/store and DMA only. Instruction fetch will always fail.
The APB peripheral segment provides access to control and configuration registers, as well as data access for lower-
bandwidth peripherals. APB writes cost a minimum of four cycles, and APB reads a minimum of three.
Table 13. Address
map for APB bus
segmentBus Endpoint Base Address
SYSINFO_BASE 0x40000000
SYSCFG_BASE 0x40008000
RP2350 Datasheet
2.2. Address map 31
Bus Endpoint Base Address
CLOCKS_BASE 0x40010000
PSM_BASE 0x40018000
RESETS_BASE 0x40020000
IO_BANK0_BASE 0x40028000
IO_QSPI_BASE 0x40030000
PADS_BANK0_BASE 0x40038000
PADS_QSPI_BASE 0x40040000
XOSC_BASE 0x40048000
PLL_SYS_BASE 0x40050000
PLL_USB_BASE 0x40058000
ACCESSCTRL_BASE 0x40060000
BUSCTRL_BASE 0x40068000
UART0_BASE 0x40070000
UART1_BASE 0x40078000
SPI0_BASE 0x40080000
SPI1_BASE 0x40088000
I2C0_BASE 0x40090000
I2C1_BASE 0x40098000
ADC_BASE 0x400a0000
PWM_BASE 0x400a8000
TIMER0_BASE 0x400b0000
TIMER1_BASE 0x400b8000
HSTX_CTRL_BASE 0x400c0000
XIP_CTRL_BASE 0x400c8000
XIP_QMI_BASE 0x400d0000
WATCHDOG_BASE 0x400d8000
BOOTRAM_BASE 0x400e0000
ROSC_BASE 0x400e8000
TRNG_BASE 0x400f0000
SHA256_BASE 0x400f8000
POWMAN_BASE 0x40100000
TICKS_BASE 0x40108000
OTP_BASE 0x40120000
OTP_DATA_BASE 0x40130000
OTP_DATA_RAW_BASE 0x40134000
OTP_DATA_GUARDED_BASE 0x40138000
RP2350 Datasheet
2.2. Address map 32
Bus Endpoint Base Address
OTP_DATA_RAW_GUARDED_BASE 0x4013c000
CORESIGHT_PERIPH_BASE 0x40140000
CORESIGHT_ROMTABLE_BASE 0x40140000
CORESIGHT_AHB_AP_CORE0_BASE 0x40142000
CORESIGHT_AHB_AP_CORE1_BASE 0x40144000
CORESIGHT_TIMESTAMP_GEN_BASE 0x40146000
CORESIGHT_ATB_FUNNEL_BASE 0x40147000
CORESIGHT_TPIU_BASE 0x40148000
CORESIGHT_CTI_BASE 0x40149000
CORESIGHT_APB_AP_RISCV_BASE 0x4014a000
GLITCH_DETECTOR_BASE 0x40158000
TBMAN_BASE 0x40160000
2.2.5. AHB registers
AHB peripheral registers are accessible to processor load/store and DMA only. Instruction fetch will always fail.
The AHB peripheral segment provides access to higher-bandwidth peripherals. The minimum read/write cost is one
cycle, and peripherals may insert up to one wait state.
Table 14. Address
map for AHB
peripheral bus
segmentBus Endpoint Base Address
DMA_BASE 0x50000000
USBCTRL_BASE 0x50100000
USBCTRL_DPRAM_BASE 0x50100000
USBCTRL_REGS_BASE 0x50110000
PIO0_BASE 0x50200000
PIO1_BASE 0x50300000
PIO2_BASE 0x50400000
XIP_AUX_BASE 0x50500000
HSTX_FIFO_BASE 0x50600000
CORESIGHT_TRACE_BASE 0x50700000
2.2.6. Core-local peripherals (SIO)
SIO is accessible to processor load/store only. It contains registers which need single-cycle access from both cores
concurrently, such as the GPIO registers. Access is always zero-wait-state.
RP2350 Datasheet
2.2. Address map 33
Table 15. Address
map for SIO bus
segmentBus Endpoint Base Address
SIO_BASE 0xd0000000
SIO_NONSEC_BASE 0xd0020000
2.2.7. Cortex-M33 private peripherals
The PPB is accessible to processor load/store only.
The PPB region contains standard control registers defined by Arm, Non-secure aliases of some of those registers, and
a handful of other core-local registers defined by Raspberry Pi (the EPPB).
These addresses are only accessible to Arm processors: RISC-V processors will return a bus fault.
Table 16. Address
map for PPB bus
segmentBus Endpoint Base Address
PPB_BASE 0xe0000000
PPB_NONSEC_BASE 0xe0020000
EPPB_BASE 0xe0080000
RP2350 Datasheet
2.2. Address map 34
Chapter 3. Processor subsystem
Core 0 Core 1Dual-core Complex
System interruptsSystem Bus:Core 1 InstructionSystem Bus:Core 0 InstructionSystem Bus:Core 0 DataSystem Bus:Core 1 Data(48 + 8) × GPIOTo the OutsideSWD from Debug Host
SW-DP
APB-APRISC-V
Debug Module
Single-cycle IOArmCortex-M33IDIRQDebugRISC-VHazard3IDIRQDebugArmCortex-M33DIIRQDebugRISC-VHazard3DIIRQDebugAHB-APCore -1AHB-APCore -0
Mux
Split SplitMux Mux MuxDebug ComplexFigure 6. The RP2350
processor subsystem
connects two
processors to the
system bus, peripheral
interrupts, GPIOs, and
a Serial Wire Debug
(SWD) connection
from an external
debug host. It also
contains closely-
coupled peripherals,
and peripherals used
for synchronisation
and communication,
which are collectively
referred to as the
single-cycle IO
subsystem (SIO).
RP2350 is a symmetric dual-core system. Two cores operate simultaneously and independently, offering high
processing throughput and the ability to route interrupts to different cores to improve throughput and latency of
interrupt handling. The two cores have a symmetric view of the system bus; all memory resources on RP2350 are
accessible equally on both cores, with the same performance.
Each core has a pair of 32-bit AHB5 links to the system bus. One is used exclusively for instruction fetch, the other
exclusively for load or store instructions and debugger access. Each core can perform one instruction fetch and one
load or store access per cycle, provided there are no conflicts on the downstream bus ports.
There are two sockets for cores to attach to the system bus, referred to as core 0  and core 1  throughout this datasheet.
(They may synonymously be referred to as core0, core1, proc0 and proc1 in register documentation.) The processor
plugged into each socket is selectable at boot time:
•A Cortex-M33 processor, implementing the Armv8-M Main instruction set, plus extensions
•A Hazard3 processor, implementing the RV32IMAC instruction set, plus extensions
Cortex-M33 is the default option. Whichever processor is unused is held in reset with its clock gated at the top level.
Unused processors use zero dynamic power. See Section 3.9  for information about the architecture selection hardware.
The two Cortex-M33 instances are identical. They are configured with the Security, DSP and FPU extensions, as well as
8× SAU regions, 8× Secure MPU regions and 8× Non-secure MPU regions. Section 3.7  documents the Cortex-M33
processor as well as the specific configuration used on RP2350. The two Hazard3 instances are also identical to one
another; see Section 3.8  for the features and operation of the Hazard3 processors.
RP2350 Datasheet
Chapter 3. Processor subsystem 35
The Cortex-M33 implementation of the Armv8-M Security extension (also known as TrustZone-M) isolates trusted and
untrusted software running on-device. RP2350 extends the strict partitioning of the Arm Secure and Non-secure states
throughout the system, including the ability to assign peripherals, GPIOs and DMA channels to each security domain.
See Section 10.2  for a high-level overview of Armv8-M Security extension features in the context of the RP2350 security
architecture.
Not shown on Figure 6  are the coprocessors for the Cortex-M33. These are closely coupled to the core, offering a
transfer rate of 64 bits per cycle in and out of the Arm register file. You may consider them to be inside the Cortex-M33
block on the diagram. RP2350 equips each Cortex-M33 with the following coprocessors:
•Coprocessor 0: GPIO coprocessor (GPIOC), described in Section 3.6.1
•Coprocessors 4 and 5: Secure and Non-secure instances of the double-precision coprocessor (DCP), described in
Section 3.6.2
•Coprocessor 7: redundancy coprocessor (RCP), described in Section 3.6.3
An external debug host can access both cores over a Serial Wire Debug (SWD) bus. The host can:
•run, halt and reset the cores
•inspect internal core state such as registers
•access memory from the core’s point of view
•load code onto the device and run it
Section 3.5  describes the debug hardware in addition to the instruction trace hardware available on the Arm processors.
Peripherals throughout the system assert interrupt requests  (IRQs) to demand attention from the processors. For
example, a UART peripheral asserts its interrupt when it has received a character, so the processor can collect it from
the receive FIFO. All interrupts route to both cores, and the core’s internal interrupt controller selects the interrupt
signals it wishes to subscribe to. Section 3.2  defines the system-level IRQ numbering as well as details of the Arm non-
maskable interrupt (NMI).
The event signals described in Section 3.3  are a mechanism for processors to sleep when waiting for other processors
in the system to complete a task or free up some resource. Each processor sees events emitted by the other processor.
They also see exclusivity events generated by the Global Exclusive Monitor described in Section 2.1.6 , which is the piece
of hardware that allows the processors to safely manipulate shared variables using atomic read-modify-write
sequences.
3.1. SIO
The Single-cycle IO subsystem (SIO) contains peripherals that require low-latency, deterministic access from the
processors. It is accessed via the AHB Fabric. The SIO has a dedicated bus interface for each processor, as shown in
Figure 7 .
RP2350 Datasheet
3.1. SIO 36
Non-secure SIO
CPUID 0CPUID 1
FIFO 4 × 32b
FIFO 4 × 32b
Bus InterfaceHardware Spinlock × 32
Doorbells × 8 Each Way
RISC-V Platform TimerBus InterfaceCore 0Load/StoreCore 1Load/Store
GPIO Registers (Shared S + NS)Secure SIO
CPUID 0CPUID 1
FIFO 4 × 32b
FIFO 4 × 32b
Bus InterfaceHardware Spinlock × 32
Doorbells × 8 Each Way
RISC-V Platform TimerBus Interface
To IO MuxingGPIO × 48 + 8S           NS S           NS
Interp0(S/NS)Interp1(S/NS)TMDS(S/NS)TMDS(S/NS)Interp1(S/NS)Interp0(S/NS)Figure 7. The single-
cycle IO block
contains registers
which processors
must access quickly.
FIFOs, doorbells and
spinlocks support
message passing and
synchronisation
between the two
cores. The shared
GPIO registers provide
fast, direct access to
GPIO-capable pins.
Interpolators can
accelerate common
software tasks. Most
SIO hardware is
banked (duplicated)
for Secure and Non-
secure access. Grey
arrows show bus
connections for Non-
secure access.
The SIO contains:
•CPUID  registers which read as 0/1 on core 0/1 ( Section 3.1.2 )
•Mailbox FIFOs for passing ordered messages between cores ( Section 3.1.5 )
•Doorbells for interrupting the opposite core on cumulative and unordered events ( Section 3.1.6 )
•Hardware spinlocks for implementing critical sections without using exclusive bus accesses ( Section 3.1.4 )
•Interpolators ( Section 3.1.10 ) and TMDS encoders ( Section 3.1.9 )
•Standard RISC-V 64-bit platform timer ( Section 3.1.8 ) which is usable by both Arm and RISC-V software
•GPIO registers for fast software bitbanging ( Section 3.1.3 ), with shared access from both cores
Most SIO hardware is duplicated for Secure/Non-secure access. Non-secure access to the FIFO registers will see a
physically different FIFO than Secure access to the same address, so that messages belonging to Secure and Non-
secure software are not mixed: Section 3.1.1  describes this Secure/Non-secure banking in more detail.
3.1.1. Secure and Non-secure SIO
To allow isolation of Secure and Non-secure software, whilst keeping a consistent programming model for software
written to run in either domain, the SIO is duplicated into a Secure and a Non-secure bank. Most hardware is duplicated
between the two banks, including:
•Mailbox FIFOs
•Doorbell registers
RP2350 Datasheet
3.1. SIO 37
•Interrupt outputs to processors
•Spinlocks
For example, Non-secure code on core 0 can pass messages to Non-secure code on core 1 through the Non-secure
instance of the mailbox FIFO. In turn, this message will generate a Non-secure interrupt, which is separate from the
Secure FIFO interrupt line. This does not interfere with any Secure message passing that might be going on at the same
time, and Non-secure code can not snoop Secure messages because it does not have access to the Secure mailboxes.
The software running in the Secure and Non-secure domain can be identical, and the processors' bus accesses to the
SIO will automatically be routed to the Secure or Non-secure version of the mailbox registers.
The following hardware is not duplicated:
•The GPIO registers are shared, and Non-secure accesses are filtered on a per-GPIO basis by the Non-secure GPIO
mask defined in the ACCESSCTRL GPIO_NSMASK0  and GPIO_NSMASK1  registers
•The RISC-V standard platform timer ( MTIME , MTIMEH ), which is also usable by Arm processors, is present only in
the Secure SIO, as it is a Machine-mode peripheral on RISC-V
•The interpolator and TMDS encoder peripherals are assignable to either the Secure or Non-secure SIO using the
PERI_NONSEC  register
Accesses to the SIO register address range, starting at 0xd0000000  (SIO_BASE ), are mapped to the SIO bank which
matches the security attribute of the bus access. This means accesses from the Arm Secure state, or RISC-V Machine
mode, will access the Secure SIO bank, and accesses from the Arm Non-secure state, or RISC-V User mode, will access
the Non-secure SIO bank.
Additionally, Secure accesses can use the mirrored address range starting at 0xd0020000  (SIO_NONSEC_BASE ) to access
the Non-secure view of SIO, for example, using the Non-secure doorbells to interrupt Non-secure code running on the
other core. Attempting to access this address range from Non-secure code will generate a bus fault.
NOTE
The 0x20000 offset of the Secure-to-Non-secure mirror matches the PPB mirrors at 0xe0000000  (PPB_BASE ) and
0xe0020000  (PPB_NONSEC_BASE ), which function similarly.
NOTE
Debug access is mapped to the Secure/Non-secure SIO using the security attribute of the debugger’s bus access,
which may differ from the security state that the core was halted in.
3.1.2. CPUID
The CPUID  SIO register returns a value of 0 when read by core 0, and 1 when read by core 1. This helps software identify
the core running the current application. The initial boot sequence also relies on this check: both cores start running
simultaneously, core 1 goes into a deep sleep state, and core 0 continues the main boot sequence.
IMPORTANT
Don’t confuse the SIO CPUID  register with the Cortex-M33 CPUID  register on each processor’s internal Private
Peripheral Bus, which lists the processor’s part number and version.
RP2350 Datasheet
3.1. SIO 38
NOTE
Reading the MHARTID  CSR on each Hazard3 core returns the same values as CPUID : 0 on core 0, and 1 on core 1.
3.1.3. GPIO control
The SIO GPIO registers control GPIOs which have the SIO function selected (function 5). This function is supported on
the following pins:
•All user GPIOs (GPIOs 0 through 29, or 0 through 47, depending on package option)
•QSPI pins
•USB DP/DM pins
All SIO GPIO control registers come in pairs. The lower-addressed register in each pair (for example, GPIO_IN ) is
connected to GPIOs 0 through 31, and the higher-addressed register in each pair (for example, GPIO_HI_IN ) is
connected to GPIOs 32 through 47, the QSPI pins, and the USB DP/DM pins.
NOTE
To drive a pin with the SIO’s GPIO registers, the GPIO multiplexer for this pin must first be configured to select the
SIO GPIO function. See Table 646 .
These GPIO registers are shared  between the two cores: both cores can access them simultaneously. There are three
groups of registers:
•Output registers, GPIO_OUT  and GPIO_HI_OUT  set the output level of the GPIO. 0 for low output, 1 for high output.
•Output enable registers, GPIO_OE  and GPIO_HI_OE , are used to enable the output driver. 0 for high-impedance, 1
for drive high or low based on GPIO_OUT  and GPIO_HI_OUT .
•Input registers, GPIO_IN  and GPIO_HI_IN , allow the processor to sample the current state of the GPIOs.
Reading GPIO_IN  returns up to 32 input values in a single read, and software then masks out individual pins it is
interested in.
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_gpio/include/hardware/gpio.h  Lines 869 - 879
869 static inline bool gpio_get (uint gpio) {
870 #ifdef NUM_BANK0_GPIOS <= 32
871     return sio_hw->gpio_in & (1u << gpio);
872 #else
873     if (gpio < 32) {
874         return sio_hw->gpio_in & (1u << gpio);
875     } else {
876         return sio_hw->gpio_hi_in  & (1u << (gpio - 32));
877     }
878 #endif
879 }
The OUT and OE registers also have atomic SET, CLR, and XOR aliases. This allows software to update a subset of the pins in
one operation. This ensures safety for concurrent GPIO access, both between the two cores and between a single core’s
interrupt handler and foreground code.
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_gpio/include/hardware/gpio.h  Lines 918 - 924
918 static inline void gpio_set_mask (uint32_t  mask) {
919 #ifdef PICO_USE_GPIO_COPROCESSOR
920     gpioc_lo_out_set (mask);
RP2350 Datasheet
3.1. SIO 39
921 #else
922     sio_hw->gpio_set  = mask;
923 #endif
924 }
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_gpio/include/hardware/gpio.h  Lines 965 - 971
965 static inline void gpio_clr_mask (uint32_t  mask) {
966 #ifdef PICO_USE_GPIO_COPROCESSOR
967     gpioc_lo_out_clr (mask);
968 #else
969     sio_hw->gpio_clr  = mask;
970 #endif
971 }
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_gpio/include/hardware/gpio.h  Lines 1155 - 1180
1155 static inline void gpio_put (uint gpio, bool value) {
1156 #ifdef PICO_USE_GPIO_COPROCESSOR
1157     gpioc_bit_out_put (gpio, value);
1158 #elif NUM_BANK0_GPIOS <= 32
1159     uint32_t  mask = 1ul << gpio;
1160     if (value)
1161         gpio_set_mask (mask);
1162     else
1163         gpio_clr_mask (mask);
1164 #else
1165     uint32_t  mask = 1ul << (gpio & 0x1fu);
1166     if (gpio < 32) {
1167         if (value) {
1168             sio_hw->gpio_set  = mask;
1169         } else {
1170             sio_hw->gpio_clr  = mask;
1171         }
1172     } else {
1173         if (value) {
1174             sio_hw->gpio_hi_set  = mask;
1175         } else {
1176             sio_hw->gpio_hi_clr  = mask;
1177         }
1178     }
1179 #endif
1180 }
If both processors write to an OUT or OE register (or any of its SET/CLR/XOR aliases) on the same clock cycle, the result is as
though core 0 wrote first, then core 1 wrote immediately afterward. For example, if core 0 SETs a bit and core 1 XORs it
on the same clock cycle, the bit ends up with a value of 0.
RP2350 Datasheet
3.1. SIO 40
NOTE
This is a conceptual model for the result produced when two cores write to a GPIO register simultaneously. The
register never contains the intermediate values at any point. In the previous example, if the pin is initially 0, and core
0 performs a SET while core 1 performs a XOR, the GPIO output remains low throughout the clock cycle.
As well as being shared between cores, the GPIO registers are also shared between security domains. The Secure and
Non-secure SIO offer alternative views of the same GPIO registers, which are always mapped as GPIO function 5.
However, the Non-secure SIO can only access pins which are enabled in the GPIO Non-secure mask configured by the
ACCESSCTRL registers GPIO_NSMASK0  and GPIO_NSMASK1 . The layout of the NSMASK registers matches the layout
of the SIO registers — for example, QSPI_SCK  is bit 26 in both GPIO_HI_IN  and GPIO_NSMASK1 .
When a pin is not enabled in Non-secure code:
•Writes to the corresponding GPIO registers from a Non-secure context have no effect.
•Reads from a Non-secure context return zeroes.
•Reads and writes from a Secure context function as usual using the Secure bank.
The GPIO coprocessor port ( Section 3.6.1 ) provides dedicated instructions for accessing the SIO GPIO registers from
the Cortex-M33 processors. This includes the ability to read and write 64 bits in a single operation.
3.1.4. Hardware spinlocks
The SIO provides 32 hardware spinlocks, which can be used to manage mutually-exclusive access to shared software
resources. Each spinlock is a one-bit flag, mapped to a different address (from SPINLOCK0  to SPINLOCK31 ). Software
interacts with each spinlock with one of the following operations:
•Read: Attempt to claim the lock. Read value is non-zero if the lock was successfully claimed, or zero if the lock had
already been claimed by a previous read.
•Write (any value): Release the lock. The next attempt to claim the lock will succeed.
If both cores try to claim the same lock on the same clock cycle, core 0 succeeds.
Generally software will acquire a lock by repeatedly polling the lock bit ("spinning" on the lock) until it is successfully
claimed. This is inefficient if the lock is held for long periods, so generally the spinlocks should be used to protect short
critical sections of higher-level primitives such as mutexes, semaphores and queues.
For debugging purposes, the current state of all 32 spinlocks can be observed via SPINLOCK_ST .
NOTE
RP2350 has separate spinlocks for Secure and Non-secure SIO banks because sharing these registers would allow
Non-secure code to deliberately starve Secure code that attempts to acquire a lock. See Section 3.1.1 .
NOTE
The processors on RP2350 support standard atomic/exclusive access instructions which, in concert with the global
exclusive monitor ( Section 2.1.6 ), allow both cores to safely share variables in SRAM. The SIO spinlocks are still
included for compatibility with RP2040.
RP2350 Datasheet
3.1. SIO 41
NOTE
Due to RP2350-E2 , writes to new SIO registers above an offset of +0x180 alias the spinlocks, causing spurious lock
releases. The SDK by default uses atomic memory accesses to implement the hardware_sync_spin_lock  API, as a
workaround on RP2350 A2.
3.1.5. Inter-processor FIFOs (Mailboxes)
The SIO contains two FIFOs for passing data, messages or ordered events between the two cores. Each FIFO is 32 bits
wide and four entries deep. One of the FIFOs can only be written by core 0 and read by core 1. The other can only be
written by core 1 and read by core 0.
Each core writes to its outgoing FIFO by writing to FIFO_WR  and reads from its incoming FIFO by reading from FIFO_RD .
A status register, FIFO_ST , provides the following status signals:
•Incoming FIFO contains data ( VLD).
•Outgoing FIFO has room for more data ( RDY).
•The incoming FIFO was read from while empty at some point in the past ( ROE).
•The outgoing FIFO was written to while full at some point in the past ( WOF).
Writing to the outgoing FIFO while full, or reading from the incoming FIFO while empty, does not affect the FIFO state.
The current contents and level of the FIFO is preserved. However, this does represent some loss of data or reception of
invalid data by the software accessing the FIFO, so a sticky error flag is raised ( ROE or WOF).
The SIO has a FIFO IRQ output for each core to notify the core that it has received FIFO data. This is a core-local
interrupt , mapped to the same IRQ number on each core ( SIO_IRQ_FIFO , interrupt number 25). Non-secure FIFO interrupts
use a separate interrupt line, ( SIO_IRQ_FIFO_NS , interrupt number 27). It is not possible to interrupt on the opposite core’s
FIFO.
Each IRQ output is the logical OR of the VLD, ROE and WOF bits in that core’s FIFO_ST  register: that is, the IRQ is asserted if
any of these three bits is high, and clears again when they are all low. To clear the ROE and WOF flags, write any value to
FIFO_ST . To clear the VLD flag, read data from the FIFO until it is empty.
If the corresponding interrupt line is enabled in the processor’s interrupt controller, the processor takes an interrupt
each time data appears in its FIFO, or if it has performed some invalid FIFO operation (read on empty, write on full).
NOTE
ROE and WOF only become set if software misbehaves in some way. Generally, the interrupt handler triggers when data
appears in the FIFO, raising the VLD flag. Then, the interrupt handler clears the IRQ by reading data from the FIFO until
VLD goes low once more.
The inter-processor FIFOs and the Event signals are used by the bootrom ( Chapter 5 ) wait_for_vector  routine, where core
1 remains in a sleep state until it is woken, and provided with its initial stack pointer, entry point and vector table through
the FIFO.
NOTE
RP2350 has separate FIFOs and interrupts for Secure and Non-secure SIO banks. See Section 3.1.1
3.1.6. Doorbells
The doorbell registers raise an interrupt on the opposite core. There are 8 doorbell flags in each direction, combined into
a single doorbell interrupt per core. This is a core-local interrupt: the same interrupt number on each core ( SIO_IRQ_BELL ,
interrupt number 26) notifies that core of incoming doorbell interrupts.
RP2350 Datasheet
3.1. SIO 42
Whereas the mailbox FIFOs are used for cross-core events whose count and order is important, doorbells are used for
events which are accumulative (i.e. may post multiple times, but only answered once) and which can be responded to in
any order.
Writing a non-zero value to the DOORBELL_OUT_SET  register raises the opposite core’s doorbell interrupt. The interrupt
remains raised until all bits are cleared. Generally, the opposite core enters its doorbell interrupt handler, reads its
DOORBELL_IN_CLR  register to get the mask of active doorbell flags, and then writes back to acknowledge and clear the
interrupt.
The DOORBELL_IN_SET  register allows a processor to ring its own doorbell. This is useful when the routine which rings
a doorbell can be scheduled on either core. Likewise, for symmetry, a processor can clear the opposite core’s doorbell
flags using the DOORBELL_OUT_CLR  register: this is useful for setup code, but should be avoided in general because of
the potential for race conditions when acknowledging interrupts meant for the opposite core.
At any time, a core can read back its DOORBELL_OUT_SET  or DOORBELL_OUT_CLR  register (they return the same
result) to see the status of doorbell interrupts posted to the opposite core. Likewise, reading either DOORBELL_IN_SET 
or DOORBELL_IN_CLR  returns the status of doorbell interrupts posted to this core.
NOTE
RP2350 has separate per-core doorbell interrupt signals and doorbell registers for Secure and Non-secure SIO
banks. Non-secure doorbells are posted on SIO_IRQ_BELL_NS , interrupt number 28. See Section 3.1.1 .
3.1.7. Integer divider
RP2040’s memory-mapped integer divider peripheral is not present on RP2350, since the processors support divide
instructions. The address space previously allocated for the divider registers is now reserved.
3.1.8. RISC-V platform timer
This 64-bit timer is a standard peripheral described in the RISC-V privileged specification, usable equally by the Arm and
RISC-V processors on RP2350. It drives the per-core SIO_IRQ_MTIMECMP  system-level interrupt ( Section 3.2 ), as well as the
mip.mtip  timer interrupt on the RISC-V processors.
There is a single 64-bit counter, shared between both cores. The low and high half can be accessed through the MTIME 
and MTIMEH  SIO registers. Use the following procedure to safely read the 64-bit time using 32-bit register accesses:
1.Read the upper half, MTIMEH .
2.Read the lower half, MTIME .
3.Read the upper half again.
4.Loop if the two upper-half reads returned different values.
This is similar to the procedure for reading RP2350 system timers ( Section 12.8 ). The loop should only happen once,
when the timer is read at exactly the instant of a 32-bit rollover, and even this is only occasional. If you require constant-
time operation, you can instead zero the lower half when the two upper-half reads differ.
Timer interrupts are generated based on a per-core 64-bit time comparison value, accessed through the MTIMECMP 
and MTIMECMPH  SIO registers. Each core gets its own copy of these registers, accessed at the same address. The per-
core interrupt is asserted whenever the current time indicated in the MTIME  registers is greater than or equal to that
core’s MTIMECMP . Use the following sequence to write a new 64-bit timer comparison value without causing spurious
interrupts:
1.Write all-ones to MTIMECMP  (guaranteed greater than or equal to the old value, and the lower half of the target
value).
2.Write the upper half of the target value to MTIMECMPH  (combined 64-bit value is still greater than or equal to the
target value).
RP2350 Datasheet
3.1. SIO 43
3.Write the lower half of the target value to MTIMECMP .
The RISC-V timer can count either ticks from the system-level tick generator ( Section 8.5 ), or system clock cycles,
selected by the MTIME_CTRL  register. Use a 1 microsecond time base for compatibility with most RISC-V software.
3.1.9. TMDS encoder
Each core is equipped with an implementation of the TMDS encode algorithm described in chapter 3 of the DVI 1.0
specification. In general, the HSTX peripheral ( Section 12.11 ) supports lower processor overhead for DVI-D output as
well as a wider range of pixel formats, but the SIO TMDS encoders are included for use with non-HSTX-capable GPIOs.
The TMDS_CTRL  register allows configuration of a number of input pixel formats, from 16-bit RGB down to 1-bit
monochrome. Once the encoder has been set up, the processor writes 32 bits of colour data at a time to TMDS_WDATA ,
and then reads TMDS data symbols from the output registers. Depending on the pixel format, there may be multiple
TMDS symbols read for each write to TMDS_WDATA . There are no stalls: encoding is limited entirely by the processor’s
load/store bandwidth, up to one 32-bit read or write per cycle per core.
To allow for framebuffer/scanbuffer resolution lower than the display resolution, the output registers have both peek
and pop aliases (e.g. TMDS_PEEK_SINGLE  and TMDS_POP_SINGLE ). Reading either register advances the encoder’s DC
balance counter, but only the pop alias shifts the colour data in TMDS_WDATA  so that multiple correctly-DC-balanced
TMDS symbols can be generated from the same input pixel.
The TMDS encoder peripherals are not duplicated over security domains. They are assigned to the Secure SIO at reset,
and can be reassigned to the Non-secure SIO using the PERI_NONSEC  register.
3.1.10. Interpolator
Each core is equipped with two interpolators  (INTERP0 and INTERP1) that can accelerate tasks by combining certain pre-
configured operations into a single processor cycle. Intended for cases where the pre-configured operation repeats
many times, interpolators result in code which uses both fewer CPU cycles and fewer CPU registers in time-critical
sections.
The interpolators already accelerate audio operations within the SDK. Their flexible configuration makes it possible to
optimise many other tasks, including:
•quantization
•dithering
•table lookup address generation
•affine texture mapping
•decompression
•linear feedback
RP2350 Datasheet
3.1. SIO 44
Base 0
0
1Mask Accumulator 0 Result 0Result 0
Result 1
Result 0
Result 1Result 2Accumulator 1
Accumulator 0Right Shift Sign-extend  fromMask
Base 2
Base 1Accumulator 10
1
1
01
01
01
0
MaskRight Shift Sign-extend  fromMask0
10
1Result 1+
+
+Figure 8. An
interpolator. The two
accumulator registers
and three base
registers have single-
cycle read/write
access from the
processor. The
interpolator is
organised into two
lanes, which perform
masking, shifting and
sign-extension
operations on the two
accumulators. This
produces three
possible results, by
adding the
intermediate
shift/mask values to
the three base
registers. From left to
right, the multiplexers
on each lane are
controlled by the
following flags in the
CTRL registers:
CROSS_RESULT ,
CROSS_INPUT , SIGNED,
and ADD_RAW.The processor can write or read any interpolator register in one cycle, and the results are ready on the next cycle. The
processor can also perform an addition on one of the two accumulators ACCUM0 or ACCUM1 by writing to the corresponding
ACCUMx_ADD  register.
The three results are available in the read-only locations PEEK0, PEEK1, PEEK2. Reading from these locations does not
change the state of the interpolator. The results are also aliased at the locations POP0, POP1, POP2; reading from a POPx alias
returns the same result as the corresponding PEEKx, and simultaneously writes back the lane results to the
accumulators. Use the POPx aliases to advance the state of interpolator each time a result is read.
You can adjust interpolator behaviour with the following operational modes:
•fractional blending between two values
•clamping  values to restrict them within a given range.
The following example shows a trivial example of popping  a lane result to produce simple iterative feedback.
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 11 - 23
11 void times_table () {
12     puts("9 times table:" );
13 
14     // Initialise lane 0 on interp0 on this core
15     interp_config  cfg = interp_default_config ();
16     interp_set_config (interp0, 0, &cfg);
17 
18     interp0->accum[0] = 0;
19     interp0->base[0] = 9;
20 
21     for (int i = 0; i < 10; ++i)
22         printf("%d\n", interp0->pop[0]);
23 }
3.1.10.1. Lane operations
RP2350 Datasheet
3.1. SIO 45
0
1Mask Accumulator 0 Add to BASE1(for PEEK0/POP0) 
Add to BASE2(forms part of  PEEK2/POP2) Result 0
Result 1Accumulator 1Right Shift Sign-extend  fromMask0
11
01
0Figure 9. Each lane of
each interpolator can
be configured to
perform mask, shift
and sign-extension on
one of the
accumulators. This is
fed into adders which
produce final results,
which may optionally
be fed back into the
accumulators with
each read. The
datapath can be
configured using a
handful of 32-bit
multiplexers. From left
to right, these are
controlled by the
following CTRL flags:
CROSS_RESULT ,
CROSS_INPUT , SIGNED,
and ADD_RAW.Each lane performs these three operations, in sequence:
•A right shift by CTRL_LANEx_SHIFT  (0 to 31 bits)
•A mask of bits from CTRL_LANEx_MASK_LSB  to CTRL_LANEx_MASK_MSB  inclusive (each ranging from bit 0 to bit 31)
•A sign extension from the top of the mask, i.e. take bit CTRL_LANEx_MASK_MSB  and OR it into all more-significant bits, if
CTRL_LANEx_SIGNED  is set
For example, if:
•ACCUM0 = 0xdeadbeef
•CTRL_LANE0_SHIFT  = 8
•CTRL_LANE0_MASK_LSB  = 4
•CTRL_LANE0_MASK_MSB  = 7
•CTRL_SIGNED  = 1
Then lane 0 would produce the following results at each stage:
•Right shift by 8 to produce 0x00deadbe
•Mask bits 7 to 4 to produce 0x00deadbe & 0x000000f0  = 0x000000b0
•Sign-extend up from bit 7 to produce 0xffffffb0
In software:
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 25 - 46
25 void moving_mask () {
26     interp_config  cfg = interp_default_config ();
27     interp0->accum[0] = 0x1234abcd ;
28 
29     puts("Masking:" );
30     printf("ACCUM0 = %08x \n", interp0->accum[0]);
31     for (int i = 0; i < 8; ++i) {
32         // LSB, then MSB. These are inclusive, so 0,31 means "the entire 32 bit register"
33         interp_config_set_mask (&cfg, i * 4, i * 4 + 3);
34         interp_set_config (interp0, 0, &cfg);
35         // Reading from ACCUMx_ADD returns the raw lane shift and mask value, without BASEx
   added
36         printf("Nibble %d: %08x \n", i, interp0->add_raw[0]);
37     }
38 
39     puts("Masking with sign extension:" );
40     interp_config_set_signed (&cfg, true);
41     for (int i = 0; i < 8; ++i) {
42         interp_config_set_mask (&cfg, i * 4, i * 4 + 3);
43         interp_set_config (interp0, 0, &cfg);
44         printf("Nibble %d: %08x \n", i, interp0->add_raw[0]);
45     }
46 }
The above example should print the following:
RP2350 Datasheet
3.1. SIO 46
ACCUM0 = 1234abcd
Nibble 0: 0000000d
Nibble 1: 000000c0
Nibble 2: 00000b00
Nibble 3: 0000a000
Nibble 4: 00040000
Nibble 5: 00300000
Nibble 6: 02000000
Nibble 7: 10000000
Masking with sign extension:
Nibble 0: fffffffd
Nibble 1: ffffffc0
Nibble 2: fffffb00
Nibble 3: ffffa000
Nibble 4: 00040000
Nibble 5: 00300000
Nibble 6: 02000000
Nibble 7: 10000000
Changing the result and input multiplexers can create feedback between the accumulators. This is useful for audio
dithering.
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 48 - 66
48 void cross_lanes () {
49     interp_config  cfg = interp_default_config ();
50     interp_config_set_cross_result (&cfg, true);
51     // ACCUM0 gets lane 1 result:
52     interp_set_config (interp0, 0, &cfg);
53     // ACCUM1 gets lane 0 result:
54     interp_set_config (interp0, 1, &cfg);
55 
56     interp0->accum[0] = 123;
57     interp0->accum[1] = 456;
58     interp0->base[0] = 1;
59     interp0->base[1] = 0;
60     puts("Lane result crossover:" );
61     for (int i = 0; i < 10; ++i) {
62         uint32_t  peek0 = interp0->peek[0];
63         uint32_t  pop1 = interp0->pop[1];
64         printf("PEEK0, POP1: %d, %d \n", peek0, pop1);
65     }
66 }
This should print the following :
PEEK0, POP1: 124, 456
PEEK0, POP1: 457, 124
PEEK0, POP1: 125, 457
PEEK0, POP1: 458, 125
PEEK0, POP1: 126, 458
PEEK0, POP1: 459, 126
PEEK0, POP1: 127, 459
PEEK0, POP1: 460, 127
PEEK0, POP1: 128, 460
PEEK0, POP1: 461, 128
RP2350 Datasheet
3.1. SIO 47
3.1.10.2. Blend mode
Blend mode is available on INTERP0 on each core, and is enabled by the CTRL_LANE0_BLEND  control flag. It performs linear
interpolation, which we define as follows:
Where 
  is the register BASE0, 
 is the register BASE1, and 
  is a fractional value formed from the least significant 8 bits
of the lane 1 shift and mask value.
Blend mode differs from normal mode in the following ways:
•PEEK0, POP0 return the 8-bit alpha value (the 8 LSBs of the lane 1 shift and mask value), with zeroes in result bits 31
down to 24.
•PEEK1, POP1 return the linear interpolation between BASE0 and BASE1
•PEEK2, POP2 do not include lane 1 result in the addition (i.e. it is BASE2 + lane 0 shift and mask value)
The result of the linear interpolation is equal to BASE0 when the alpha value is 0, and equal to BASE0 + 255/256 * ( BASE1 -
BASE0) when the alpha value is all-ones.
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 68 - 87
68 void simple_blend1 () {
69     puts("Simple blend 1:" );
70 
71     interp_config  cfg = interp_default_config ();
72     interp_config_set_blend (&cfg, true);
73     interp_set_config (interp0, 0, &cfg);
74 
75     cfg = interp_default_config ();
76     interp_set_config (interp0, 1, &cfg);
77 
78     interp0->base[0] = 500;
79     interp0->base[1] = 1000;
80 
81     for (int i = 0; i <= 6; i++) {
82         // set fraction to value between 0 and 255
83         interp0->accum[1] = 255 * i / 6;
84         // ≈ 500 + (1000 - 500) * i / 6;
85         printf("%d\n", (int) interp0->peek[1]);
86     }
87 }
This should print the following (note the 255/256 resulting in 998 not 1000):
500
582
666
748
832
914
998
CTRL_LANE1_SIGNED  controls whether BASE0 and BASE1 are sign-extended for this interpolation (this sign extension is required
because the interpolation produces an intermediate product value 40 bits in size). CTRL_LANE0_SIGNED  continues to control
the sign extension of the lane 0 intermediate result in PEEK2, POP2 as normal.
RP2350 Datasheet
3.1. SIO 48
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 90 - 121
 90 void print_simple_blend2_results (bool is_signed ) {
 91     // lane 1 signed flag controls whether base 0/1 are treated as signed or unsigned
 92     interp_config  cfg = interp_default_config ();
 93     interp_config_set_signed (&cfg, is_signed );
 94     interp_set_config (interp0, 1, &cfg);
 95 
 96     for (int i = 0; i <= 6; i++) {
 97         interp0->accum[1] = 255 * i / 6;
 98         if (is_signed ) {
 99             printf("%d\n", (int) interp0->peek[1]);
100         } else {
101             printf("0x%08x\n", (uint) interp0->peek[1]);
102         }
103     }
104 }
105 
106 void simple_blend2 () {
107     puts("Simple blend 2:" );
108 
109     interp_config  cfg = interp_default_config ();
110     interp_config_set_blend (&cfg, true);
111     interp_set_config (interp0, 0, &cfg);
112 
113     interp0->base[0] = (uint32_t ) -1000;
114     interp0->base[1] = 1000;
115 
116     puts("signed:" );
117     print_simple_blend2_results (true);
118 
119     puts("unsigned:" );
120     print_simple_blend2_results (false);
121 }
This should print the following:
signed:
-1000
-672
-336
-8
328
656
992
unsigned:
0xfffffc18
0xd5fffd60
0xaafffeb0
0x80fffff8
0x56000148
0x2c000290
0x010003e0
Finally, in blend mode when using the BASE_1AND0  register to send a 16-bit value to each of BASE0 and BASE1 with a single
32-bit write, the sign-extension of these 16-bit values to full 32-bit values during the write is controlled by
CTRL_LANE1_SIGNED  for both bases, as opposed to non-blend-mode operation, where CTRL_LANE0_SIGNED  affects extension
into BASE0 and CTRL_LANE1_SIGNED  affects extension into BASE1.
RP2350 Datasheet
3.1. SIO 49
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 124 - 145
124 void simple_blend3 () {
125     puts("Simple blend 3:" );
126 
127     interp_config  cfg = interp_default_config ();
128     interp_config_set_blend (&cfg, true);
129     interp_set_config (interp0, 0, &cfg);
130 
131     cfg = interp_default_config ();
132     interp_set_config (interp0, 1, &cfg);
133 
134     interp0->accum[1] = 128;
135     interp0->base01 = 0x30005000 ;
136     printf("0x%08x\n", (int) interp0->peek[1]);
137     interp0->base01 = 0xe000f000 ;
138     printf("0x%08x\n", (int) interp0->peek[1]);
139 
140     interp_config_set_signed (&cfg, true);
141     interp_set_config (interp0, 1, &cfg);
142 
143     interp0->base01 = 0xe000f000 ;
144     printf("0x%08x\n", (int) interp0->peek[1]);
145 }
This should print the following:
0x00004000
0x0000e800
0xffffe800
3.1.10.3. Clamp Mode
Clamp mode is available on INTERP1 on each core. To enable clamp mode, set the CTRL_LANE0_CLAMP  control flag to high. In
clamp mode, the PEEK0/POP0 result is the lane value (shifted, masked, sign-extended ACCUM0) clamped between BASE0 and
BASE1. In other words, if the lane value is less than BASE0, a value of BASE0 is produced; if greater than BASE1, a value of BASE1
is produced; otherwise, the value passes through. No addition is performed. The signedness of these comparisons is
controlled by the CTRL_LANE0_SIGNED  flag.
Other than this, the interpolator behaves the same as in normal mode.
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 193 - 211
193 void clamp() {
194     puts("Clamp:" );
195     interp_config  cfg = interp_default_config ();
196     interp_config_set_clamp (&cfg, true);
197     interp_config_set_shift (&cfg, 2);
198     // set mask according to new position of sign bit..
199     interp_config_set_mask (&cfg, 0, 29);
200     // ...so that the shifted value is correctly sign extended
201     interp_config_set_signed (&cfg, true);
202     interp_set_config (interp1, 0, &cfg);
203 
204     interp1->base[0] = 0;
205     interp1->base[1] = 255;
206 
207     for (int i = -1024; i <= 1024; i += 256) {
RP2350 Datasheet
3.1. SIO 50
208         interp1->accum[0] = i;
209         printf("%d\t%d\n", i, (int) interp1->peek[0]);
210     }
211 }
This should print the following:
-1024   0
-768    0
-512    0
-256    0
0       0
256     64
512     128
768     192
1024    255
3.1.10.4. Sample use case: linear interpolation
Linear interpolation combines blend mode with other interpolator functionality. In this example, ACCUM0 tracks a fixed-
point (integer/fraction) position within a list of values to be interpolated. Lane 0 is used to produce an address into the
value array for the integer part of the position. The fractional part of the position is shifted to produce a value from 0-
255 for the blend. The blend is performed between two consecutive values in the array.
Finally the fractional position is updated via a single write to ACCUM0_ADD_RAW .
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 147 - 191
147 void linear_interpolation () {
148     puts("Linear interpolation:" );
149     const int uv_fractional_bits  = 12;
150 
151     // for lane 0
152     // shift and mask XXXX XXXX XXXX XXXX XXXX FFFF FFFF FFFF (accum 0)
153     // to             0000 0000 000X XXXX XXXX XXXX XXXX XXX0
154     // i.e. non fractional part times 2 (for uint16_t)
155     interp_config  cfg = interp_default_config ();
156     interp_config_set_shift (&cfg, uv_fractional_bits  - 1);
157     interp_config_set_mask (&cfg, 1, 32 - uv_fractional_bits );
158     interp_config_set_blend (&cfg, true);
159     interp_set_config (interp0, 0, &cfg);
160 
161     // for lane 1
162     // shift XXXX XXXX XXXX XXXX XXXX FFFF FFFF FFFF (accum 0 via cross input)
163     // to    0000 XXXX XXXX XXXX XXXX FFFF FFFF FFFF
164 
165     cfg = interp_default_config ();
166     interp_config_set_shift (&cfg, uv_fractional_bits  - 8);
167     interp_config_set_signed (&cfg, true);
168     interp_config_set_cross_input (&cfg, true); // signed blending
169     interp_set_config (interp0, 1, &cfg);
170 
171     int16_t samples[] = {0, 10, -20, -1000, 500};
172 
173     // step is 1/4 in our fractional representation
174     uint step = (1 << uv_fractional_bits ) / 4;
175 
176     interp0->accum[0] = 0; // initial sample_offset;
RP2350 Datasheet
3.1. SIO 51
177     interp0->base[2] = (uintptr_t ) samples;
178     for (int i = 0; i < 16; i++) {
179         // result2 = samples + (lane0 raw result)
180         // i.e. ptr to the first of two samples to blend between
181         int16_t *sample_pair  = (int16_t *) interp0->peek[2];
182         interp0->base[0] = sample_pair [0];
183         interp0->base[1] = sample_pair [1];
184         uint32_t  peek1 = interp0->peek[1];
185         uint32_t  add_raw1  = interp0->add_raw[1];
186         printf("%d\t(%d%% between %d and %d) \n", (int) peek1,
187                100 * (add_raw1  & 0xff) / 0xff,
188                sample_pair [0], sample_pair [1]);
189         interp0->add_raw[0] = step;
190     }
191 }
This should print the following:
0       (0% between 0 and 10)
2       (25% between 0 and 10)
5       (50% between 0 and 10)
7       (75% between 0 and 10)
10      (0% between 10 and -20)
2       (25% between 10 and -20)
-5      (50% between 10 and -20)
-13     (75% between 10 and -20)
-20     (0% between -20 and -1000)
-265    (25% between -20 and -1000)
-510    (50% between -20 and -1000)
-755    (75% between -20 and -1000)
-1000   (0% between -1000 and 500)
-625    (25% between -1000 and 500)
-250    (50% between -1000 and 500)
125     (75% between -1000 and 500)
This method is used for fast approximate audio upscaling in the SDK.
3.1.10.5. Sample use case: simple affine texture mapping
Simple affine texture mapping can be implemented by using fixed-point arithmetic for texture coordinates, and stepping
a fixed amount in each coordinate for every pixel in a scanline. The integer parts of the texture coordinates form an
address into the texture. Reading from POP2 adds the offset to the texture base pointer. The processor loads the
resulting address to sample a pixel colour from the texture.
By using two lanes, all three base values, and the CTRL_LANEx_ADD_RAW  flag, you can use the interpolator to reduce an
expensive CPU operation to a single cycle iteration.
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/interp/hello_interp/hello_interp.c  Lines 214 - 272
214 void texture_mapping_setup (uint8_t *texture, uint texture_width_bits , uint
    texture_height_bits ,
215                            uint uv_fractional_bits ) {
216     interp_config  cfg = interp_default_config ();
217     // set add_raw flag to use raw (un-shifted and un-masked) lane accumulator value when
    adding
218     // it to the lane base to make the lane result
219     interp_config_set_add_raw (&cfg, true);
220     interp_config_set_shift (&cfg, uv_fractional_bits );
RP2350 Datasheet
3.1. SIO 52
221     interp_config_set_mask (&cfg, 0, texture_width_bits  - 1);
222     interp_set_config (interp0, 0, &cfg);
223 
224     interp_config_set_shift (&cfg, uv_fractional_bits  - texture_width_bits );
225     interp_config_set_mask (&cfg, texture_width_bits , texture_width_bits  +
    texture_height_bits  - 1);
226     interp_set_config (interp0, 1, &cfg);
227 
228     interp0->base[2] = (uintptr_t ) texture;
229 }
230 
231 void texture_mapped_span (uint8_t *output, uint32_t  u, uint32_t  v, uint32_t  du, uint32_t  dv,
    uint count) {
232     // u, v are texture coordinates in fixed point with uv_fractional_bits fractional bits
233     // du, dv are texture coordinate steps across the span in same fixed point.
234     interp0->accum[0] = u;
235     interp0->base[0] = du;
236     interp0->accum[1] = v;
237     interp0->base[1] = dv;
238     for (uint i = 0; i < count; i++) {
239         // equivalent to
240         // uint32_t sm_result0 = (accum0 >> uv_fractional_bits) & (1 << (texture_width_bits -
    1);
241         // uint32_t sm_result1 = (accum1 >> uv_fractional_bits) & (1 << (texture_height_bits -
    1);
242         // uint8_t *address = texture + sm_result0 + (sm_result1 << texture_width_bits);
243         // output[i] = *address;
244         // accum0 = du + accum0;
245         // accum1 = dv + accum1;
246 
247         // result2 is the texture address for the current pixel;
248         // popping the result advances to the next iteration
249         output[i] = *(uint8_t *) interp0->pop[2];
250     }
251 }
252 
253 void texture_mapping () {
254     puts("Affine Texture mapping (with texture wrap):" );
255 
256     uint8_t texture[] = {
257             0x00, 0x01, 0x02, 0x03,
258             0x10, 0x11, 0x12, 0x13,
259             0x20, 0x21, 0x22, 0x23,
260             0x30, 0x31, 0x32, 0x33,
261     };
262     // 4x4 texture
263     texture_mapping_setup (texture, 2, 2, 16);
264     uint8_t output[12];
265     uint32_t  du = 65536 / 2;  // step of 1/2
266     uint32_t  dv = 65536 / 3;  // step of 1/3
267     texture_mapped_span (output, 0, 0, du, dv, 12);
268 
269     for (uint i = 0; i < 12; i++) {
270         printf("0x%02x\n", output[i]);
271     }
272 }
This should print the following:
RP2350 Datasheet
3.1. SIO 53
0x00
0x00
0x01
0x01
0x12
0x12
0x13
0x23
0x20
0x20
0x31
0x31
3.1.11. List of registers
The SIO registers start at a base address of 0xd0000000  (defined as SIO_BASE  in SDK).
Table 17. List of SIO
registersOffset Name Info
0x000 CPUID Processor core identifier
0x004 GPIO_IN Input value for GPIO0…31.
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL)
appear as zero.
0x008 GPIO_HI_IN Input value on GPIO32…47, QSPI IOs and USB pins
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL)
appear as zero.
0x010 GPIO_OUT GPIO0…31 output value
0x014 GPIO_HI_OUT Output value for GPIO32…47, QSPI IOs and USB pins.
Write to set output level (1/0 → high/low). Reading back gives
the last value written, NOT the input value from the pins. If core 0
and core 1 both write to GPIO_HI_OUT simultaneously (or to a
SET/CLR/XOR alias), the result is as though the write from core 0
took place first, and the write from core 1 was then applied to
that intermediate result.
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL)
ignore writes, and their output status reads back as zero. This is
also true for SET/CLR/XOR aliases of this register.
0x018 GPIO_OUT_SET GPIO0…31 output value set
0x01c GPIO_HI_OUT_SET Output value set for GPIO32..47, QSPI IOs and USB pins.
Perform an atomic bit-set on GPIO_HI_OUT, i.e. GPIO_HI_OUT |=
wdata
0x020 GPIO_OUT_CLR GPIO0…31 output value clear
0x024 GPIO_HI_OUT_CLR Output value clear for GPIO32..47, QSPI IOs and USB pins.
Perform an atomic bit-clear on GPIO_HI_OUT, i.e. GPIO_HI_OUT &=
~wdata
0x028 GPIO_OUT_XOR GPIO0…31 output value XOR
RP2350 Datasheet
3.1. SIO 54
Offset Name Info
0x02c GPIO_HI_OUT_XOR Output value XOR for GPIO32..47, QSPI IOs and USB pins.
Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. GPIO_HI_OUT
^= wdata
0x030 GPIO_OE GPIO0…31 output enable
0x034 GPIO_HI_OE Output enable value for GPIO32…47, QSPI IOs and USB pins.
Write output enable (1/0 → output/input). Reading back gives
the last value written. If core 0 and core 1 both write to
GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), the
result is as though the write from core 0 took place first, and the
write from core 1 was then applied to that intermediate result.
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL)
ignore writes, and their output status reads back as zero. This is
also true for SET/CLR/XOR aliases of this register.
0x038 GPIO_OE_SET GPIO0…31 output enable set
0x03c GPIO_HI_OE_SET Output enable set for GPIO32…47, QSPI IOs and USB pins.
Perform an atomic bit-set on GPIO_HI_OE, i.e. GPIO_HI_OE |= wdata
0x040 GPIO_OE_CLR GPIO0…31 output enable clear
0x044 GPIO_HI_OE_CLR Output enable clear for GPIO32…47, QSPI IOs and USB pins.
Perform an atomic bit-clear on GPIO_HI_OE, i.e. GPIO_HI_OE &=
~wdata
0x048 GPIO_OE_XOR GPIO0…31 output enable XOR
0x04c GPIO_HI_OE_XOR Output enable XOR for GPIO32…47, QSPI IOs and USB pins.
Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. GPIO_HI_OE ^=
wdata
0x050 FIFO_ST Status register for inter-core FIFOs (mailboxes).
0x054 FIFO_WR Write access to this core’s TX FIFO
0x058 FIFO_RD Read access to this core’s RX FIFO
0x05c SPINLOCK_ST Spinlock state
0x080 INTERP0_ACCUM0 Read/write access to accumulator 0
0x084 INTERP0_ACCUM1 Read/write access to accumulator 1
0x088 INTERP0_BASE0 Read/write access to BASE0 register.
0x08c INTERP0_BASE1 Read/write access to BASE1 register.
0x090 INTERP0_BASE2 Read/write access to BASE2 register.
0x094 INTERP0_POP_LANE0 Read LANE0 result, and simultaneously write lane results to both
accumulators (POP).
0x098 INTERP0_POP_LANE1 Read LANE1 result, and simultaneously write lane results to both
accumulators (POP).
0x09c INTERP0_POP_FULL Read FULL result, and simultaneously write lane results to both
accumulators (POP).
0x0a0 INTERP0_PEEK_LANE0 Read LANE0 result, without altering any internal state (PEEK).
0x0a4 INTERP0_PEEK_LANE1 Read LANE1 result, without altering any internal state (PEEK).
RP2350 Datasheet
3.1. SIO 55
Offset Name Info
0x0a8 INTERP0_PEEK_FULL Read FULL result, without altering any internal state (PEEK).
0x0ac INTERP0_CTRL_LANE0 Control register for lane 0
0x0b0 INTERP0_CTRL_LANE1 Control register for lane 1
0x0b4 INTERP0_ACCUM0_ADD Values written here are atomically added to ACCUM0
0x0b8 INTERP0_ACCUM1_ADD Values written here are atomically added to ACCUM1
0x0bc INTERP0_BASE_1AND0 On write, the lower 16 bits go to BASE0, upper bits to BASE1
simultaneously.
0x0c0 INTERP1_ACCUM0 Read/write access to accumulator 0
0x0c4 INTERP1_ACCUM1 Read/write access to accumulator 1
0x0c8 INTERP1_BASE0 Read/write access to BASE0 register.
0x0cc INTERP1_BASE1 Read/write access to BASE1 register.
0x0d0 INTERP1_BASE2 Read/write access to BASE2 register.
0x0d4 INTERP1_POP_LANE0 Read LANE0 result, and simultaneously write lane results to both
accumulators (POP).
0x0d8 INTERP1_POP_LANE1 Read LANE1 result, and simultaneously write lane results to both
accumulators (POP).
0x0dc INTERP1_POP_FULL Read FULL result, and simultaneously write lane results to both
accumulators (POP).
0x0e0 INTERP1_PEEK_LANE0 Read LANE0 result, without altering any internal state (PEEK).
0x0e4 INTERP1_PEEK_LANE1 Read LANE1 result, without altering any internal state (PEEK).
0x0e8 INTERP1_PEEK_FULL Read FULL result, without altering any internal state (PEEK).
0x0ec INTERP1_CTRL_LANE0 Control register for lane 0
0x0f0 INTERP1_CTRL_LANE1 Control register for lane 1
0x0f4 INTERP1_ACCUM0_ADD Values written here are atomically added to ACCUM0
0x0f8 INTERP1_ACCUM1_ADD Values written here are atomically added to ACCUM1
0x0fc INTERP1_BASE_1AND0 On write, the lower 16 bits go to BASE0, upper bits to BASE1
simultaneously.
0x100 SPINLOCK0 Spinlock register 0
0x104 SPINLOCK1 Spinlock register 1
0x108 SPINLOCK2 Spinlock register 2
0x10c SPINLOCK3 Spinlock register 3
0x110 SPINLOCK4 Spinlock register 4
0x114 SPINLOCK5 Spinlock register 5
0x118 SPINLOCK6 Spinlock register 6
0x11c SPINLOCK7 Spinlock register 7
0x120 SPINLOCK8 Spinlock register 8
0x124 SPINLOCK9 Spinlock register 9
RP2350 Datasheet
3.1. SIO 56
Offset Name Info
0x128 SPINLOCK10 Spinlock register 10
0x12c SPINLOCK11 Spinlock register 11
0x130 SPINLOCK12 Spinlock register 12
0x134 SPINLOCK13 Spinlock register 13
0x138 SPINLOCK14 Spinlock register 14
0x13c SPINLOCK15 Spinlock register 15
0x140 SPINLOCK16 Spinlock register 16
0x144 SPINLOCK17 Spinlock register 17
0x148 SPINLOCK18 Spinlock register 18
0x14c SPINLOCK19 Spinlock register 19
0x150 SPINLOCK20 Spinlock register 20
0x154 SPINLOCK21 Spinlock register 21
0x158 SPINLOCK22 Spinlock register 22
0x15c SPINLOCK23 Spinlock register 23
0x160 SPINLOCK24 Spinlock register 24
0x164 SPINLOCK25 Spinlock register 25
0x168 SPINLOCK26 Spinlock register 26
0x16c SPINLOCK27 Spinlock register 27
0x170 SPINLOCK28 Spinlock register 28
0x174 SPINLOCK29 Spinlock register 29
0x178 SPINLOCK30 Spinlock register 30
0x17c SPINLOCK31 Spinlock register 31
0x180 DOORBELL_OUT_SET Trigger a doorbell interrupt on the opposite core.
Write 1 to a bit to set the corresponding bit in DOORBELL_IN on
the opposite core. This raises the opposite core’s doorbell
interrupt.
Read to get the status of the doorbells currently asserted on the
opposite core. This is equivalent to that core reading its own
DOORBELL_IN status.
RP2350 Datasheet
3.1. SIO 57
Offset Name Info
0x184 DOORBELL_OUT_CLR Clear doorbells which have been posted to the opposite core.
This register is intended for debugging and initialisation
purposes.
Writing 1 to a bit in DOORBELL_OUT_CLR clears the
corresponding bit in DOORBELL_IN on the opposite core.
Clearing all bits will cause that core’s doorbell interrupt to
deassert. Since the usual order of events is for software to send
events using DOORBELL_OUT_SET, and acknowledge incoming
events by writing to DOORBELL_IN_CLR, this register should be
used with caution to avoid race conditions.
Reading returns the status of the doorbells currently asserted on
the other core, i.e. is equivalent to that core reading its own
DOORBELL_IN status.
0x188 DOORBELL_IN_SET Write 1s to trigger doorbell interrupts on this core. Read to get
status of doorbells currently asserted on this core.
0x18c DOORBELL_IN_CLR Check and acknowledge doorbells posted to this core. This
core’s doorbell interrupt is asserted when any bit in this register
is 1.
Write 1 to each bit to clear that bit. The doorbell interrupt
deasserts once all bits are cleared. Read to get status of
doorbells currently asserted on this core.
0x190 PERI_NONSEC Detach certain core-local peripherals from Secure SIO, and
attach them to Non-secure SIO, so that Non-secure software can
use them. Attempting to access one of these peripherals from
the Secure SIO when it is attached to the Non-secure SIO, or vice
versa, will generate a bus error.
This register is per-core, and is only present on the Secure SIO.
Most SIO hardware is duplicated across the Secure and Non-
secure SIO, so is not listed in this register.
0x1a0 RISCV_SOFTIRQ Control the assertion of the standard software interrupt
(MIP.MSIP) on the RISC-V cores.
Unlike the RISC-V timer, this interrupt is not routed to a normal
system-level interrupt line, so can not be used by the Arm cores.
It is safe for both cores to write to this register on the same
cycle. The set/clear effect is accumulated across both cores,
and then applied. If a flag is both set and cleared on the same
cycle, only the set takes effect.
RP2350 Datasheet
3.1. SIO 58
Offset Name Info
0x1a4 MTIME_CTRL Control register for the RISC-V 64-bit Machine-mode timer. This
timer is only present in the Secure SIO, so is only accessible to
an Arm core in Secure mode or a RISC-V core in Machine mode.
Note whilst this timer follows the RISC-V privileged specification,
it is equally usable by the Arm cores. The interrupts are routed to
normal system-level interrupt lines as well as to the MIP.MTIP
inputs on the RISC-V cores.
0x1b0 MTIME Read/write access to the high half of RISC-V Machine-mode
timer. This register is shared between both cores. If both cores
write on the same cycle, core 1 takes precedence.
0x1b4 MTIMEH Read/write access to the high half of RISC-V Machine-mode
timer. This register is shared between both cores. If both cores
write on the same cycle, core 1 takes precedence.
0x1b8 MTIMECMP Low half of RISC-V Machine-mode timer comparator. This
register is core-local, i.e., each core gets a copy of this register,
with the comparison result routed to its own interrupt line.
The timer interrupt is asserted whenever MTIME is greater than
or equal to MTIMECMP. This comparison is unsigned, and
performed on the full 64-bit values.
0x1bc MTIMECMPH High half of RISC-V Machine-mode timer comparator. This
register is core-local.
The timer interrupt is asserted whenever MTIME is greater than
or equal to MTIMECMP. This comparison is unsigned, and
performed on the full 64-bit values.
0x1c0 TMDS_CTRL Control register for TMDS encoder.
0x1c4 TMDS_WDATA Write-only access to the TMDS colour data register.
0x1c8 TMDS_PEEK_SINGLE Get the encoding of one pixel’s worth of colour data, packed into
a 32-bit value (3x10-bit symbols).
The PEEK alias does not shift the colour register when read, but
still advances the running DC balance state of each encoder.
This is useful for pixel doubling.
0x1cc TMDS_POP_SINGLE Get the encoding of one pixel’s worth of colour data, packed into
a 32-bit value. The packing is 5 chunks of 3 lanes times 2 bits (30
bits total). Each chunk contains two bits of a TMDS symbol per
lane. This format is intended for shifting out with the HSTX
peripheral on RP2350.
The POP alias shifts the colour register when read, as well as
advancing the running DC balance state of each encoder.
RP2350 Datasheet
3.1. SIO 59
Offset Name Info
0x1d0 TMDS_PEEK_DOUBLE_L0 Get lane 0 of the encoding of two pixels' worth of colour data.
Two 10-bit TMDS symbols are packed at the bottom of a 32-bit
word.
The PEEK alias does not shift the colour register when read, but
still advances the lane 0 DC balance state. This is useful if all 3
lanes' worth of encode are to be read at once, rather than
processing the entire scanline for one lane before moving to the
next lane.
0x1d4 TMDS_POP_DOUBLE_L0 Get lane 0 of the encoding of two pixels' worth of colour data.
Two 10-bit TMDS symbols are packed at the bottom of a 32-bit
word.
The POP alias shifts the colour register when read, according to
the values of PIX_SHIFT and PIX2_NOSHIFT.
0x1d8 TMDS_PEEK_DOUBLE_L1 Get lane 1 of the encoding of two pixels' worth of colour data.
Two 10-bit TMDS symbols are packed at the bottom of a 32-bit
word.
The PEEK alias does not shift the colour register when read, but
still advances the lane 1 DC balance state. This is useful if all 3
lanes' worth of encode are to be read at once, rather than
processing the entire scanline for one lane before moving to the
next lane.
0x1dc TMDS_POP_DOUBLE_L1 Get lane 1 of the encoding of two pixels' worth of colour data.
Two 10-bit TMDS symbols are packed at the bottom of a 32-bit
word.
The POP alias shifts the colour register when read, according to
the values of PIX_SHIFT and PIX2_NOSHIFT.
0x1e0 TMDS_PEEK_DOUBLE_L2 Get lane 2 of the encoding of two pixels' worth of colour data.
Two 10-bit TMDS symbols are packed at the bottom of a 32-bit
word.
The PEEK alias does not shift the colour register when read, but
still advances the lane 2 DC balance state. This is useful if all 3
lanes' worth of encode are to be read at once, rather than
processing the entire scanline for one lane before moving to the
next lane.
0x1e4 TMDS_POP_DOUBLE_L2 Get lane 2 of the encoding of two pixels' worth of colour data.
Two 10-bit TMDS symbols are packed at the bottom of a 32-bit
word.
The POP alias shifts the colour register when read, according to
the values of PIX_SHIFT and PIX2_NOSHIFT.
SIO: CPUID Register
Offset : 0x000
Description
Processor core identifier
RP2350 Datasheet
3.1. SIO 60
Table 18. CPUID
RegisterBits Description Type Reset
31:0 Value is 0 when read from processor core 0, and 1 when read from processor
core 1.RO -
SIO: GPIO_IN Register
Offset : 0x004
Table 19. GPIO_IN
RegisterBits Description Type Reset
31:0 Input value for GPIO0…31.
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as
zero.RO 0x00000000
SIO: GPIO_HI_IN Register
Offset : 0x008
Description
Input value on GPIO32…47, QSPI IOs and USB pins
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) appear as zero.
Table 20. GPIO_HI_IN
RegisterBits Description Type Reset
31:28 QSPI_SD : Input value on QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins RO 0x0
27 QSPI_CSN : Input value on QSPI CSn pin RO 0x0
26 QSPI_SCK : Input value on QSPI SCK pin RO 0x0
25 USB_DM : Input value on USB D- pin RO 0x0
24 USB_DP : Input value on USB D+ pin RO 0x0
23:16 Reserved. - -
15:0 GPIO : Input value on GPIO32…47 RO 0x0000
SIO: GPIO_OUT Register
Offset : 0x010
Description
GPIO0…31 output value
RP2350 Datasheet
3.1. SIO 61
Table 21. GPIO_OUT
RegisterBits Description Type Reset
31:0 Set output level (1/0 → high/low) for GPIO0…31. Reading back gives the last
value written, NOT the input value from the pins.
If core 0 and core 1 both write to GPIO_OUT simultaneously (or to a
SET/CLR/XOR alias), the result is as though the write from core 0 took place
first, and the write from core 1 was then applied to that intermediate result.
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes,
and their output status reads back as zero. This is also true for SET/CLR/XOR
aliases of this register.RW 0x00000000
SIO: GPIO_HI_OUT Register
Offset : 0x014
Description
Output value for GPIO32…47, QSPI IOs and USB pins.
Write to set output level (1/0 → high/low). Reading back gives the last value written, NOT the input value from the pins.
If core 0 and core 1 both write to GPIO_HI_OUT simultaneously (or to a SET/CLR/XOR alias), the result is as though the
write from core 0 took place first, and the write from core 1 was then applied to that intermediate result.
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as
zero. This is also true for SET/CLR/XOR aliases of this register.
Table 22.
GPIO_HI_OUT RegisterBits Description Type Reset
31:28 QSPI_SD : Output value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3 pins RW 0x0
27 QSPI_CSN : Output value for QSPI CSn pin RW 0x0
26 QSPI_SCK : Output value for QSPI SCK pin RW 0x0
25 USB_DM : Output value for USB D- pin RW 0x0
24 USB_DP : Output value for USB D+ pin RW 0x0
23:16 Reserved. - -
15:0 GPIO : Output value for GPIO32…47 RW 0x0000
SIO: GPIO_OUT_SET Register
Offset : 0x018
Description
GPIO0…31 output value set
Table 23.
GPIO_OUT_SET
RegisterBits Description Type Reset
31:0 Perform an atomic bit-set on GPIO_OUT, i.e. GPIO_OUT |= wdata WO 0x00000000
SIO: GPIO_HI_OUT_SET Register
Offset : 0x01c
Description
Output value set for GPIO32..47, QSPI IOs and USB pins.
Perform an atomic bit-set on GPIO_HI_OUT, i.e. GPIO_HI_OUT |= wdata
RP2350 Datasheet
3.1. SIO 62
Table 24.
GPIO_HI_OUT_SET
RegisterBits Description Type Reset
31:28 QSPI_SD WO 0x0
27 QSPI_CSN WO 0x0
26 QSPI_SCK WO 0x0
25 USB_DM WO 0x0
24 USB_DP WO 0x0
23:16 Reserved. - -
15:0 GPIO WO 0x0000
SIO: GPIO_OUT_CLR Register
Offset : 0x020
Description
GPIO0…31 output value clear
Table 25.
GPIO_OUT_CLR
RegisterBits Description Type Reset
31:0 Perform an atomic bit-clear on GPIO_OUT, i.e. GPIO_OUT &= ~wdata WO 0x00000000
SIO: GPIO_HI_OUT_CLR Register
Offset : 0x024
Description
Output value clear for GPIO32..47, QSPI IOs and USB pins.
Perform an atomic bit-clear on GPIO_HI_OUT, i.e. GPIO_HI_OUT &= ~wdata
Table 26.
GPIO_HI_OUT_CLR
RegisterBits Description Type Reset
31:28 QSPI_SD WO 0x0
27 QSPI_CSN WO 0x0
26 QSPI_SCK WO 0x0
25 USB_DM WO 0x0
24 USB_DP WO 0x0
23:16 Reserved. - -
15:0 GPIO WO 0x0000
SIO: GPIO_OUT_XOR Register
Offset : 0x028
Description
GPIO0…31 output value XOR
Table 27.
GPIO_OUT_XOR
RegisterBits Description Type Reset
31:0 Perform an atomic bitwise XOR on GPIO_OUT, i.e. GPIO_OUT ^= wdata WO 0x00000000
SIO: GPIO_HI_OUT_XOR Register
Offset : 0x02c
RP2350 Datasheet
3.1. SIO 63
Description
Output value XOR for GPIO32..47, QSPI IOs and USB pins.
Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. GPIO_HI_OUT ^= wdata
Table 28.
GPIO_HI_OUT_XOR
RegisterBits Description Type Reset
31:28 QSPI_SD WO 0x0
27 QSPI_CSN WO 0x0
26 QSPI_SCK WO 0x0
25 USB_DM WO 0x0
24 USB_DP WO 0x0
23:16 Reserved. - -
15:0 GPIO WO 0x0000
SIO: GPIO_OE Register
Offset : 0x030
Description
GPIO0…31 output enable
Table 29. GPIO_OE
RegisterBits Description Type Reset
31:0 Set output enable (1/0 → output/input) for GPIO0…31. Reading back gives the
last value written.
If core 0 and core 1 both write to GPIO_OE simultaneously (or to a
SET/CLR/XOR alias), the result is as though the write from core 0 took place
first, and the write from core 1 was then applied to that intermediate result.
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes,
and their output status reads back as zero. This is also true for SET/CLR/XOR
aliases of this register.RW 0x00000000
SIO: GPIO_HI_OE Register
Offset : 0x034
Description
Output enable value for GPIO32…47, QSPI IOs and USB pins.
Write output enable (1/0 → output/input). Reading back gives the last value written. If core 0 and core 1 both write to
GPIO_HI_OE simultaneously (or to a SET/CLR/XOR alias), the result is as though the write from core 0 took place first,
and the write from core 1 was then applied to that intermediate result.
In the Non-secure SIO, Secure-only GPIOs (as per ACCESSCTRL) ignore writes, and their output status reads back as
zero. This is also true for SET/CLR/XOR aliases of this register.
Table 30. GPIO_HI_OE
RegisterBits Description Type Reset
31:28 QSPI_SD : Output enable value for QSPI SD0 (MOSI), SD1 (MISO), SD2 and SD3
pinsRW 0x0
27 QSPI_CSN : Output enable value for QSPI CSn pin RW 0x0
26 QSPI_SCK : Output enable value for QSPI SCK pin RW 0x0
25 USB_DM : Output enable value for USB D- pin RW 0x0
RP2350 Datasheet
3.1. SIO 64
Bits Description Type Reset
24 USB_DP : Output enable value for USB D+ pin RW 0x0
23:16 Reserved. - -
15:0 GPIO : Output enable value for GPIO32…47 RW 0x0000
SIO: GPIO_OE_SET Register
Offset : 0x038
Description
GPIO0…31 output enable set
Table 31.
GPIO_OE_SET RegisterBits Description Type Reset
31:0 Perform an atomic bit-set on GPIO_OE, i.e. GPIO_OE |= wdata WO 0x00000000
SIO: GPIO_HI_OE_SET Register
Offset : 0x03c
Description
Output enable set for GPIO32…47, QSPI IOs and USB pins.
Perform an atomic bit-set on GPIO_HI_OE, i.e. GPIO_HI_OE |= wdata
Table 32.
GPIO_HI_OE_SET
RegisterBits Description Type Reset
31:28 QSPI_SD WO 0x0
27 QSPI_CSN WO 0x0
26 QSPI_SCK WO 0x0
25 USB_DM WO 0x0
24 USB_DP WO 0x0
23:16 Reserved. - -
15:0 GPIO WO 0x0000
SIO: GPIO_OE_CLR Register
Offset : 0x040
Description
GPIO0…31 output enable clear
Table 33.
GPIO_OE_CLR RegisterBits Description Type Reset
31:0 Perform an atomic bit-clear on GPIO_OE, i.e. GPIO_OE &= ~wdata WO 0x00000000
SIO: GPIO_HI_OE_CLR Register
Offset : 0x044
Description
Output enable clear for GPIO32…47, QSPI IOs and USB pins.
Perform an atomic bit-clear on GPIO_HI_OE, i.e. GPIO_HI_OE &= ~wdata
RP2350 Datasheet
3.1. SIO 65
Table 34.
GPIO_HI_OE_CLR
RegisterBits Description Type Reset
31:28 QSPI_SD WO 0x0
27 QSPI_CSN WO 0x0
26 QSPI_SCK WO 0x0
25 USB_DM WO 0x0
24 USB_DP WO 0x0
23:16 Reserved. - -
15:0 GPIO WO 0x0000
SIO: GPIO_OE_XOR Register
Offset : 0x048
Description
GPIO0…31 output enable XOR
Table 35.
GPIO_OE_XOR
RegisterBits Description Type Reset
31:0 Perform an atomic bitwise XOR on GPIO_OE, i.e. GPIO_OE ^= wdata WO 0x00000000
SIO: GPIO_HI_OE_XOR Register
Offset : 0x04c
Description
Output enable XOR for GPIO32…47, QSPI IOs and USB pins.
Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. GPIO_HI_OE ^= wdata
Table 36.
GPIO_HI_OE_XOR
RegisterBits Description Type Reset
31:28 QSPI_SD WO 0x0
27 QSPI_CSN WO 0x0
26 QSPI_SCK WO 0x0
25 USB_DM WO 0x0
24 USB_DP WO 0x0
23:16 Reserved. - -
15:0 GPIO WO 0x0000
SIO: FIFO_ST Register
Offset : 0x050
Description
Status register for inter-core FIFOs (mailboxes).
There is one FIFO in the core 0 → core 1 direction, and one core 1 → core 0. Both are 32 bits wide and 8 words
deep.
Core 0 can see the read side of the 1 →0 FIFO (RX), and the write side of 0 →1 FIFO (TX).
Core 1 can see the read side of the 0 →1 FIFO (RX), and the write side of 1 →0 FIFO (TX).
The SIO IRQ for each core is the logical OR of the VLD, WOF and ROE fields of its FIFO_ST register.
RP2350 Datasheet
3.1. SIO 66
Table 37. FIFO_ST
RegisterBits Description Type Reset
31:4 Reserved. - -
3 ROE : Sticky flag indicating the RX FIFO was read when empty. This read was
ignored by the FIFO.WC 0x0
2 WOF : Sticky flag indicating the TX FIFO was written when full. This write was
ignored by the FIFO.WC 0x0
1 RDY : Value is 1 if this core’s TX FIFO is not full (i.e. if FIFO_WR is ready for
more data)RO 0x1
0 VLD: Value is 1 if this core’s RX FIFO is not empty (i.e. if FIFO_RD is valid) RO 0x0
SIO: FIFO_WR Register
Offset : 0x054
Table 38. FIFO_WR
RegisterBits Description Type Reset
31:0 Write access to this core’s TX FIFO WF 0x00000000
SIO: FIFO_RD Register
Offset : 0x058
Table 39. FIFO_RD
RegisterBits Description Type Reset
31:0 Read access to this core’s RX FIFO RF -
SIO: SPINLOCK_ST Register
Offset : 0x05c
Table 40.
SPINLOCK_ST
RegisterBits Description Type Reset
31:0 Spinlock state
A bitmap containing the state of all 32 spinlocks (1=locked).
Mainly intended for debugging.RO 0x00000000
SIO: INTERP0_ACCUM0 Register
Offset : 0x080
Table 41.
INTERP0_ACCUM0
RegisterBits Description Type Reset
31:0 Read/write access to accumulator 0 RW 0x00000000
SIO: INTERP0_ACCUM1 Register
Offset : 0x084
Table 42.
INTERP0_ACCUM1
RegisterBits Description Type Reset
31:0 Read/write access to accumulator 1 RW 0x00000000
SIO: INTERP0_BASE0 Register
Offset : 0x088
RP2350 Datasheet
3.1. SIO 67
Table 43.
INTERP0_BASE0
RegisterBits Description Type Reset
31:0 Read/write access to BASE0 register. RW 0x00000000
SIO: INTERP0_BASE1 Register
Offset : 0x08c
Table 44.
INTERP0_BASE1
RegisterBits Description Type Reset
31:0 Read/write access to BASE1 register. RW 0x00000000
SIO: INTERP0_BASE2 Register
Offset : 0x090
Table 45.
INTERP0_BASE2
RegisterBits Description Type Reset
31:0 Read/write access to BASE2 register. RW 0x00000000
SIO: INTERP0_POP_LANE0 Register
Offset : 0x094
Table 46.
INTERP0_POP_LANE0
RegisterBits Description Type Reset
31:0 Read LANE0 result, and simultaneously write lane results to both
accumulators (POP).RO 0x00000000
SIO: INTERP0_POP_LANE1 Register
Offset : 0x098
Table 47.
INTERP0_POP_LANE1
RegisterBits Description Type Reset
31:0 Read LANE1 result, and simultaneously write lane results to both
accumulators (POP).RO 0x00000000
SIO: INTERP0_POP_FULL Register
Offset : 0x09c
Table 48.
INTERP0_POP_FULL
RegisterBits Description Type Reset
31:0 Read FULL result, and simultaneously write lane results to both accumulators
(POP).RO 0x00000000
SIO: INTERP0_PEEK_LANE0 Register
Offset : 0x0a0
Table 49.
INTERP0_PEEK_LANE
0 RegisterBits Description Type Reset
31:0 Read LANE0 result, without altering any internal state (PEEK). RO 0x00000000
SIO: INTERP0_PEEK_LANE1 Register
Offset : 0x0a4
RP2350 Datasheet
3.1. SIO 68
Table 50.
INTERP0_PEEK_LANE
1 RegisterBits Description Type Reset
31:0 Read LANE1 result, without altering any internal state (PEEK). RO 0x00000000
SIO: INTERP0_PEEK_FULL Register
Offset : 0x0a8
Table 51.
INTERP0_PEEK_FULL
RegisterBits Description Type Reset
31:0 Read FULL result, without altering any internal state (PEEK). RO 0x00000000
SIO: INTERP0_CTRL_LANE0 Register
Offset : 0x0ac
Description
Control register for lane 0
Table 52.
INTERP0_CTRL_LANE
0 RegisterBits Description Type Reset
31:26 Reserved. - -
25 OVERF : Set if either OVERF0 or OVERF1 is set. RO 0x0
24 OVERF1 : Indicates if any masked-off MSBs in ACCUM1 are set. RO 0x0
23 OVERF0 : Indicates if any masked-off MSBs in ACCUM0 are set. RO 0x0
22 Reserved. - -
21 BLEND : Only present on INTERP0 on each core. If BLEND mode is enabled:
- LANE1 result is a linear interpolation between BASE0 and BASE1, controlled
by the 8 LSBs of lane 1 shift and mask value (a fractional number between
0 and 255/256ths)
- LANE0 result does not have BASE0 added (yields only the 8 LSBs of lane 1
shift+mask value)
- FULL result does not have lane 1 shift+mask value added (BASE2 + lane 0
shift+mask)
LANE1 SIGNED flag controls whether the interpolation is signed or unsigned.RW 0x0
20:19 FORCE_MSB : ORed into bits 29:28 of the lane result presented to the
processor on the bus.
No effect on the internal 32-bit datapath. Handy for using a lane to generate
sequence
of pointers into flash or SRAM.RW 0x0
18 ADD_RAW : If 1, mask + shift is bypassed for LANE0 result. This does not
affect FULL result.RW 0x0
17 CROSS_RESULT : If 1, feed the opposite lane’s result into this lane’s
accumulator on POP.RW 0x0
16 CROSS_INPUT : If 1, feed the opposite lane’s accumulator into this lane’s shift
+ mask hardware.
Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the
shift+mask bypass)RW 0x0
15 SIGNED : If SIGNED is set, the shifted and masked accumulator value is sign-
extended to 32 bits
before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits
when read by processor.RW 0x0
RP2350 Datasheet
3.1. SIO 69
Bits Description Type Reset
14:10 MASK_MSB : The most-significant bit allowed to pass by the mask (inclusive)
Setting MSB < LSB may cause chip to turn inside-outRW 0x00
9:5 MASK_LSB : The least-significant bit allowed to pass by the mask (inclusive) RW 0x00
4:0 SHIFT : Right-rotate applied to accumulator before masking. By appropriately
configuring the masks, left and right shifts can be synthesised.RW 0x00
SIO: INTERP0_CTRL_LANE1 Register
Offset : 0x0b0
Description
Control register for lane 1
Table 53.
INTERP0_CTRL_LANE
1 RegisterBits Description Type Reset
31:21 Reserved. - -
20:19 FORCE_MSB : ORed into bits 29:28 of the lane result presented to the
processor on the bus.
No effect on the internal 32-bit datapath. Handy for using a lane to generate
sequence
of pointers into flash or SRAM.RW 0x0
18 ADD_RAW : If 1, mask + shift is bypassed for LANE1 result. This does not
affect FULL result.RW 0x0
17 CROSS_RESULT : If 1, feed the opposite lane’s result into this lane’s
accumulator on POP.RW 0x0
16 CROSS_INPUT : If 1, feed the opposite lane’s accumulator into this lane’s shift
+ mask hardware.
Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the
shift+mask bypass)RW 0x0
15 SIGNED : If SIGNED is set, the shifted and masked accumulator value is sign-
extended to 32 bits
before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits
when read by processor.RW 0x0
14:10 MASK_MSB : The most-significant bit allowed to pass by the mask (inclusive)
Setting MSB < LSB may cause chip to turn inside-outRW 0x00
9:5 MASK_LSB : The least-significant bit allowed to pass by the mask (inclusive) RW 0x00
4:0 SHIFT : Right-rotate applied to accumulator before masking. By appropriately
configuring the masks, left and right shifts can be synthesised.RW 0x00
SIO: INTERP0_ACCUM0_ADD Register
Offset : 0x0b4
RP2350 Datasheet
3.1. SIO 70
Table 54.
INTERP0_ACCUM0_AD
D RegisterBits Description Type Reset
31:24 Reserved. - -
23:0 Values written here are atomically added to ACCUM0
Reading yields lane 0’s raw shift and mask value (BASE0 not added).RW 0x000000
SIO: INTERP0_ACCUM1_ADD Register
Offset : 0x0b8
Table 55.
INTERP0_ACCUM1_AD
D RegisterBits Description Type Reset
31:24 Reserved. - -
23:0 Values written here are atomically added to ACCUM1
Reading yields lane 1’s raw shift and mask value (BASE1 not added).RW 0x000000
SIO: INTERP0_BASE_1AND0 Register
Offset : 0x0bc
Table 56.
INTERP0_BASE_1AND
0 RegisterBits Description Type Reset
31:0 On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.
Each half is sign-extended to 32 bits if that lane’s SIGNED flag is set.WO 0x00000000
SIO: INTERP1_ACCUM0 Register
Offset : 0x0c0
Table 57.
INTERP1_ACCUM0
RegisterBits Description Type Reset
31:0 Read/write access to accumulator 0 RW 0x00000000
SIO: INTERP1_ACCUM1 Register
Offset : 0x0c4
Table 58.
INTERP1_ACCUM1
RegisterBits Description Type Reset
31:0 Read/write access to accumulator 1 RW 0x00000000
SIO: INTERP1_BASE0 Register
Offset : 0x0c8
Table 59.
INTERP1_BASE0
RegisterBits Description Type Reset
31:0 Read/write access to BASE0 register. RW 0x00000000
SIO: INTERP1_BASE1 Register
Offset : 0x0cc
RP2350 Datasheet
3.1. SIO 71
Table 60.
INTERP1_BASE1
RegisterBits Description Type Reset
31:0 Read/write access to BASE1 register. RW 0x00000000
SIO: INTERP1_BASE2 Register
Offset : 0x0d0
Table 61.
INTERP1_BASE2
RegisterBits Description Type Reset
31:0 Read/write access to BASE2 register. RW 0x00000000
SIO: INTERP1_POP_LANE0 Register
Offset : 0x0d4
Table 62.
INTERP1_POP_LANE0
RegisterBits Description Type Reset
31:0 Read LANE0 result, and simultaneously write lane results to both
accumulators (POP).RO 0x00000000
SIO: INTERP1_POP_LANE1 Register
Offset : 0x0d8
Table 63.
INTERP1_POP_LANE1
RegisterBits Description Type Reset
31:0 Read LANE1 result, and simultaneously write lane results to both
accumulators (POP).RO 0x00000000
SIO: INTERP1_POP_FULL Register
Offset : 0x0dc
Table 64.
INTERP1_POP_FULL
RegisterBits Description Type Reset
31:0 Read FULL result, and simultaneously write lane results to both accumulators
(POP).RO 0x00000000
SIO: INTERP1_PEEK_LANE0 Register
Offset : 0x0e0
Table 65.
INTERP1_PEEK_LANE
0 RegisterBits Description Type Reset
31:0 Read LANE0 result, without altering any internal state (PEEK). RO 0x00000000
SIO: INTERP1_PEEK_LANE1 Register
Offset : 0x0e4
Table 66.
INTERP1_PEEK_LANE
1 RegisterBits Description Type Reset
31:0 Read LANE1 result, without altering any internal state (PEEK). RO 0x00000000
SIO: INTERP1_PEEK_FULL Register
Offset : 0x0e8
RP2350 Datasheet
3.1. SIO 72
Table 67.
INTERP1_PEEK_FULL
RegisterBits Description Type Reset
31:0 Read FULL result, without altering any internal state (PEEK). RO 0x00000000
SIO: INTERP1_CTRL_LANE0 Register
Offset : 0x0ec
Description
Control register for lane 0
Table 68.
INTERP1_CTRL_LANE
0 RegisterBits Description Type Reset
31:26 Reserved. - -
25 OVERF : Set if either OVERF0 or OVERF1 is set. RO 0x0
24 OVERF1 : Indicates if any masked-off MSBs in ACCUM1 are set. RO 0x0
23 OVERF0 : Indicates if any masked-off MSBs in ACCUM0 are set. RO 0x0
22 CLAMP : Only present on INTERP1 on each core. If CLAMP mode is enabled:
- LANE0 result is shifted and masked ACCUM0, clamped by a lower bound of
BASE0 and an upper bound of BASE1.
- Signedness of these comparisons is determined by LANE0_CTRL_SIGNEDRW 0x0
21 Reserved. - -
20:19 FORCE_MSB : ORed into bits 29:28 of the lane result presented to the
processor on the bus.
No effect on the internal 32-bit datapath. Handy for using a lane to generate
sequence
of pointers into flash or SRAM.RW 0x0
18 ADD_RAW : If 1, mask + shift is bypassed for LANE0 result. This does not
affect FULL result.RW 0x0
17 CROSS_RESULT : If 1, feed the opposite lane’s result into this lane’s
accumulator on POP.RW 0x0
16 CROSS_INPUT : If 1, feed the opposite lane’s accumulator into this lane’s shift
+ mask hardware.
Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the
shift+mask bypass)RW 0x0
15 SIGNED : If SIGNED is set, the shifted and masked accumulator value is sign-
extended to 32 bits
before adding to BASE0, and LANE0 PEEK/POP appear extended to 32 bits
when read by processor.RW 0x0
14:10 MASK_MSB : The most-significant bit allowed to pass by the mask (inclusive)
Setting MSB < LSB may cause chip to turn inside-outRW 0x00
9:5 MASK_LSB : The least-significant bit allowed to pass by the mask (inclusive) RW 0x00
4:0 SHIFT : Right-rotate applied to accumulator before masking. By appropriately
configuring the masks, left and right shifts can be synthesised.RW 0x00
SIO: INTERP1_CTRL_LANE1 Register
Offset : 0x0f0
Description
Control register for lane 1
RP2350 Datasheet
3.1. SIO 73
Table 69.
INTERP1_CTRL_LANE
1 RegisterBits Description Type Reset
31:21 Reserved. - -
20:19 FORCE_MSB : ORed into bits 29:28 of the lane result presented to the
processor on the bus.
No effect on the internal 32-bit datapath. Handy for using a lane to generate
sequence
of pointers into flash or SRAM.RW 0x0
18 ADD_RAW : If 1, mask + shift is bypassed for LANE1 result. This does not
affect FULL result.RW 0x0
17 CROSS_RESULT : If 1, feed the opposite lane’s result into this lane’s
accumulator on POP.RW 0x0
16 CROSS_INPUT : If 1, feed the opposite lane’s accumulator into this lane’s shift
+ mask hardware.
Takes effect even if ADD_RAW is set (the CROSS_INPUT mux is before the
shift+mask bypass)RW 0x0
15 SIGNED : If SIGNED is set, the shifted and masked accumulator value is sign-
extended to 32 bits
before adding to BASE1, and LANE1 PEEK/POP appear extended to 32 bits
when read by processor.RW 0x0
14:10 MASK_MSB : The most-significant bit allowed to pass by the mask (inclusive)
Setting MSB < LSB may cause chip to turn inside-outRW 0x00
9:5 MASK_LSB : The least-significant bit allowed to pass by the mask (inclusive) RW 0x00
4:0 SHIFT : Right-rotate applied to accumulator before masking. By appropriately
configuring the masks, left and right shifts can be synthesised.RW 0x00
SIO: INTERP1_ACCUM0_ADD Register
Offset : 0x0f4
Table 70.
INTERP1_ACCUM0_AD
D RegisterBits Description Type Reset
31:24 Reserved. - -
23:0 Values written here are atomically added to ACCUM0
Reading yields lane 0’s raw shift and mask value (BASE0 not added).RW 0x000000
SIO: INTERP1_ACCUM1_ADD Register
Offset : 0x0f8
Table 71.
INTERP1_ACCUM1_AD
D RegisterBits Description Type Reset
31:24 Reserved. - -
23:0 Values written here are atomically added to ACCUM1
Reading yields lane 1’s raw shift and mask value (BASE1 not added).RW 0x000000
SIO: INTERP1_BASE_1AND0 Register
Offset : 0x0fc
RP2350 Datasheet
3.1. SIO 74
Table 72.
INTERP1_BASE_1AND
0 RegisterBits Description Type Reset
31:0 On write, the lower 16 bits go to BASE0, upper bits to BASE1 simultaneously.
Each half is sign-extended to 32 bits if that lane’s SIGNED flag is set.WO 0x00000000
SIO: SPINLOCK0, SPINLOCK1, …, SPINLOCK30, SPINLOCK31 Registers
Offsets : 0x100, 0x104, …, 0x178, 0x17c
Table 73. SPINLOCK0,
SPINLOCK1, …,
SPINLOCK30,
SPINLOCK31
RegistersBits Description Type Reset
31:0 Reading from a spinlock address will:
- Return 0 if lock is already locked
- Otherwise return nonzero, and simultaneously claim the lock
Writing (any value) releases the lock.
If core 0 and core 1 attempt to claim the same lock simultaneously, core 0
wins.
The value returned on success is 0x1 << lock number.RW 0x00000000
SIO: DOORBELL_OUT_SET Register
Offset : 0x180
Table 74.
DOORBELL_OUT_SET
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 Trigger a doorbell interrupt on the opposite core.
Write 1 to a bit to set the corresponding bit in DOORBELL_IN on the opposite
core. This raises the opposite core’s doorbell interrupt.
Read to get the status of the doorbells currently asserted on the opposite
core. This is equivalent to that core reading its own DOORBELL_IN status.RW 0x00
SIO: DOORBELL_OUT_CLR Register
Offset : 0x184
RP2350 Datasheet
3.1. SIO 75
Table 75.
DOORBELL_OUT_CLR
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 Clear doorbells which have been posted to the opposite core. This register is
intended for debugging and initialisation purposes.
Writing 1 to a bit in DOORBELL_OUT_CLR clears the corresponding bit in
DOORBELL_IN on the opposite core. Clearing all bits will cause that core’s
doorbell interrupt to deassert. Since the usual order of events is for software
to send events using DOORBELL_OUT_SET, and acknowledge incoming events
by writing to DOORBELL_IN_CLR, this register should be used with caution to
avoid race conditions.
Reading returns the status of the doorbells currently asserted on the other
core, i.e. is equivalent to that core reading its own DOORBELL_IN status.WC 0x00
SIO: DOORBELL_IN_SET Register
Offset : 0x188
Table 76.
DOORBELL_IN_SET
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 Write 1s to trigger doorbell interrupts on this core. Read to get status of
doorbells currently asserted on this core.RW 0x00
SIO: DOORBELL_IN_CLR Register
Offset : 0x18c
Table 77.
DOORBELL_IN_CLR
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 Check and acknowledge doorbells posted to this core. This core’s doorbell
interrupt is asserted when any bit in this register is 1.
Write 1 to each bit to clear that bit. The doorbell interrupt deasserts once all
bits are cleared. Read to get status of doorbells currently asserted on this
core.WC 0x00
SIO: PERI_NONSEC Register
Offset : 0x190
Description
Detach certain core-local peripherals from Secure SIO, and attach them to Non-secure SIO, so that Non-secure
software can use them. Attempting to access one of these peripherals from the Secure SIO when it is attached to
the Non-secure SIO, or vice versa, will generate a bus error.
This register is per-core, and is only present on the Secure SIO.
Most SIO hardware is duplicated across the Secure and Non-secure SIO, so is not listed in this register.
Table 78.
PERI_NONSEC
RegisterBits Description Type Reset
31:6 Reserved. - -
5 TMDS : IF 1, detach TMDS encoder (of this core) from the Secure SIO, and
attach to the Non-secure SIO.RW 0x0
RP2350 Datasheet
3.1. SIO 76
Bits Description Type Reset
4:2 Reserved. - -
1 INTERP1 : If 1, detach interpolator 1 (of this core) from the Secure SIO, and
attach to the Non-secure SIO.RW 0x0
0 INTERP0 : If 1, detach interpolator 0 (of this core) from the Secure SIO, and
attach to the Non-secure SIO.RW 0x0
SIO: RISCV_SOFTIRQ Register
Offset : 0x1a0
Description
Control the assertion of the standard software interrupt (MIP.MSIP) on the RISC-V cores.
Unlike the RISC-V timer, this interrupt is not routed to a normal system-level interrupt line, so can not be used by the Arm
cores.
It is safe for both cores to write to this register on the same cycle. The set/clear effect is accumulated across both
cores, and then applied. If a flag is both set and cleared on the same cycle, only the set takes effect.
Table 79.
RISCV_SOFTIRQ
RegisterBits Description Type Reset
31:10 Reserved. - -
9 CORE1_CLR : Write 1 to atomically clear the core 1 software interrupt flag.
Read to get the status of this flag.RW 0x0
8 CORE0_CLR : Write 1 to atomically clear the core 0 software interrupt flag.
Read to get the status of this flag.RW 0x0
7:2 Reserved. - -
1 CORE1_SET : Write 1 to atomically set the core 1 software interrupt flag. Read
to get the status of this flag.RW 0x0
0 CORE0_SET : Write 1 to atomically set the core 0 software interrupt flag. Read
to get the status of this flag.RW 0x0
SIO: MTIME_CTRL Register
Offset : 0x1a4
Description
Control register for the RISC-V 64-bit Machine-mode timer. This timer is only present in the Secure SIO, so is only
accessible to an Arm core in Secure mode or a RISC-V core in Machine mode.
Note whilst this timer follows the RISC-V privileged specification, it is equally usable by the Arm cores. The interrupts
are routed to normal system-level interrupt lines as well as to the MIP.MTIP inputs on the RISC-V cores.
Table 80.
MTIME_CTRL RegisterBits Description Type Reset
31:4 Reserved. - -
3 DBGPAUSE_CORE1 : If 1, the timer pauses when core 1 is in the debug halt
state.RW 0x1
2 DBGPAUSE_CORE0 : If 1, the timer pauses when core 0 is in the debug halt
state.RW 0x1
1 FULLSPEED : If 1, increment the timer every cycle (i.e. run directly from the
system clock), rather than incrementing on the system-level timer tick input.RW 0x0
RP2350 Datasheet
3.1. SIO 77
Bits Description Type Reset
0 EN: Timer enable bit. When 0, the timer will not increment automatically. RW 0x1
SIO: MTIME Register
Offset : 0x1b0
Table 81. MTIME
RegisterBits Description Type Reset
31:0 Read/write access to the high half of RISC-V Machine-mode timer. This
register is shared between both cores. If both cores write on the same cycle,
core 1 takes precedence.RW 0x00000000
SIO: MTIMEH Register
Offset : 0x1b4
Table 82. MTIMEH
RegisterBits Description Type Reset
31:0 Read/write access to the high half of RISC-V Machine-mode timer. This
register is shared between both cores. If both cores write on the same cycle,
core 1 takes precedence.RW 0x00000000
SIO: MTIMECMP Register
Offset : 0x1b8
Table 83. MTIMECMP
RegisterBits Description Type Reset
31:0 Low half of RISC-V Machine-mode timer comparator. This register is core-
local, i.e., each core gets a copy of this register, with the comparison result
routed to its own interrupt line.
The timer interrupt is asserted whenever MTIME is greater than or equal to
MTIMECMP. This comparison is unsigned, and performed on the full 64-bit
values.RW 0xffffffff
SIO: MTIMECMPH Register
Offset : 0x1bc
Table 84.
MTIMECMPH RegisterBits Description Type Reset
31:0 High half of RISC-V Machine-mode timer comparator. This register is core-
local.
The timer interrupt is asserted whenever MTIME is greater than or equal to
MTIMECMP. This comparison is unsigned, and performed on the full 64-bit
values.RW 0xffffffff
SIO: TMDS_CTRL Register
Offset : 0x1c0
Description
Control register for TMDS encoder.
RP2350 Datasheet
3.1. SIO 78
Table 85. TMDS_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 CLEAR_BALANCE : Clear the running DC balance state of the TMDS encoders.
This bit should be written once at the beginning of each scanline.SC 0x0
27 PIX2_NOSHIFT : When encoding two pixels’s worth of symbols in one cycle (a
read of a PEEK/POP_DOUBLE register), the second encoder sees a shifted
version of the colour data register.
This control disables that shift, so that both encoder layers see the same pixel
data. This is used for pixel doubling.RW 0x0
26:24 PIX_SHIFT : Shift applied to the colour data register with each read of a POP
alias register.
Reading from the POP_SINGLE register, or reading from the POP_DOUBLE
register with PIX2_NOSHIFT set (for pixel doubling), shifts by the indicated
amount.
Reading from a POP_DOUBLE register when PIX2_NOSHIFT is clear will shift
by double the indicated amount. (Shift by 32 means no shift.)RW 0x0
Enumerated values:
0x0 → 0: Do not shift the colour data register.
0x1 → 1: Shift the colour data register by 1 bit
0x2 → 2: Shift the colour data register by 2 bits
0x3 → 4: Shift the colour data register by 4 bits
0x4 → 8: Shift the colour data register by 8 bits
0x5 → 16: Shift the colour data register by 16 bits
23 INTERLEAVE : Enable lane interleaving for reads of
PEEK_SINGLE/POP_SINGLE.
When interleaving is disabled, each of the 3 symbols appears as a contiguous
10-bit field, with lane 0 being the least-significant and starting at bit 0 of the
register.
When interleaving is enabled, the symbols are packed into 5 chunks of 3 lanes
times 2 bits (30 bits total). Each chunk contains two bits of a TMDS symbol
per lane, with lane 0 being the least significant.RW 0x0
22:21 Reserved. - -
20:18 L2_NBITS : Number of valid colour MSBs for lane 2 (1-8 bits, encoded as 0
through 7). Remaining LSBs are masked to 0 after the rotate.RW 0x0
17:15 L1_NBITS : Number of valid colour MSBs for lane 1 (1-8 bits, encoded as 0
through 7). Remaining LSBs are masked to 0 after the rotate.RW 0x0
14:12 L0_NBITS : Number of valid colour MSBs for lane 0 (1-8 bits, encoded as 0
through 7). Remaining LSBs are masked to 0 after the rotate.RW 0x0
RP2350 Datasheet
3.1. SIO 79
Bits Description Type Reset
11:8 L2_ROT : Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in
order to get the MSB of the lane 2 (red) colour data aligned with the MSB of
the 8-bit encoder input.
For example, for RGB565 (red most significant), red is bits 15:11, so should be
right-rotated by 8 bits to align with bits 7:3 of the encoder input.RW 0x0
7:4 L1_ROT : Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in
order to get the MSB of the lane 1 (green) colour data aligned with the MSB of
the 8-bit encoder input.
For example, for RGB565, green is bits 10:5, so should be right-rotated by 3
bits to align with bits 7:2 of the encoder input.RW 0x0
3:0 L0_ROT : Right-rotate the 16 LSBs of the colour accumulator by 0-15 bits, in
order to get the MSB of the lane 0 (blue) colour data aligned with the MSB of
the 8-bit encoder input.
For example, for RGB565 (red most significant), blue is bits 4:0, so should be
right-rotated by 13 to align with bits 7:3 of the encoder input.RW 0x0
SIO: TMDS_WDATA Register
Offset : 0x1c4
Table 86.
TMDS_WDATA
RegisterBits Description Type Reset
31:0 Write-only access to the TMDS colour data register. WO 0x00000000
SIO: TMDS_PEEK_SINGLE Register
Offset : 0x1c8
Table 87.
TMDS_PEEK_SINGLE
RegisterBits Description Type Reset
31:0 Get the encoding of one pixel’s worth of colour data, packed into a 32-bit value
(3x10-bit symbols).
The PEEK alias does not shift the colour register when read, but still advances
the running DC balance state of each encoder. This is useful for pixel
doubling.RF 0x00000000
SIO: TMDS_POP_SINGLE Register
Offset : 0x1cc
RP2350 Datasheet
3.1. SIO 80
Table 88.
TMDS_POP_SINGLE
RegisterBits Description Type Reset
31:0 Get the encoding of one pixel’s worth of colour data, packed into a 32-bit
value. The packing is 5 chunks of 3 lanes times 2 bits (30 bits total). Each
chunk contains two bits of a TMDS symbol per lane. This format is intended
for shifting out with the HSTX peripheral on RP2350.
The POP alias shifts the colour register when read, as well as advancing the
running DC balance state of each encoder.RF 0x00000000
SIO: TMDS_PEEK_DOUBLE_L0 Register
Offset : 0x1d0
Table 89.
TMDS_PEEK_DOUBLE_
L0 RegisterBits Description Type Reset
31:0 Get lane 0 of the encoding of two pixels' worth of colour data. Two 10-bit
TMDS symbols are packed at the bottom of a 32-bit word.
The PEEK alias does not shift the colour register when read, but still advances
the lane 0 DC balance state. This is useful if all 3 lanes' worth of encode are to
be read at once, rather than processing the entire scanline for one lane before
moving to the next lane.RF 0x00000000
SIO: TMDS_POP_DOUBLE_L0 Register
Offset : 0x1d4
Table 90.
TMDS_POP_DOUBLE_L
0 RegisterBits Description Type Reset
31:0 Get lane 0 of the encoding of two pixels' worth of colour data. Two 10-bit
TMDS symbols are packed at the bottom of a 32-bit word.
The POP alias shifts the colour register when read, according to the values of
PIX_SHIFT and PIX2_NOSHIFT.RF 0x00000000
SIO: TMDS_PEEK_DOUBLE_L1 Register
Offset : 0x1d8
Table 91.
TMDS_PEEK_DOUBLE_
L1 RegisterBits Description Type Reset
31:0 Get lane 1 of the encoding of two pixels' worth of colour data. Two 10-bit
TMDS symbols are packed at the bottom of a 32-bit word.
The PEEK alias does not shift the colour register when read, but still advances
the lane 1 DC balance state. This is useful if all 3 lanes' worth of encode are to
be read at once, rather than processing the entire scanline for one lane before
moving to the next lane.RF 0x00000000
SIO: TMDS_POP_DOUBLE_L1 Register
Offset : 0x1dc
RP2350 Datasheet
3.1. SIO 81
Table 92.
TMDS_POP_DOUBLE_L
1 RegisterBits Description Type Reset
31:0 Get lane 1 of the encoding of two pixels' worth of colour data. Two 10-bit
TMDS symbols are packed at the bottom of a 32-bit word.
The POP alias shifts the colour register when read, according to the values of
PIX_SHIFT and PIX2_NOSHIFT.RF 0x00000000
SIO: TMDS_PEEK_DOUBLE_L2 Register
Offset : 0x1e0
Table 93.
TMDS_PEEK_DOUBLE_
L2 RegisterBits Description Type Reset
31:0 Get lane 2 of the encoding of two pixels' worth of colour data. Two 10-bit
TMDS symbols are packed at the bottom of a 32-bit word.
The PEEK alias does not shift the colour register when read, but still advances
the lane 2 DC balance state. This is useful if all 3 lanes' worth of encode are to
be read at once, rather than processing the entire scanline for one lane before
moving to the next lane.RF 0x00000000
SIO: TMDS_POP_DOUBLE_L2 Register
Offset : 0x1e4
Table 94.
TMDS_POP_DOUBLE_L
2 RegisterBits Description Type Reset
31:0 Get lane 2 of the encoding of two pixels' worth of colour data. Two 10-bit
TMDS symbols are packed at the bottom of a 32-bit word.
The POP alias shifts the colour register when read, according to the values of
PIX_SHIFT and PIX2_NOSHIFT.RF 0x00000000
3.2. Interrupts
Each core is equipped with an internal interrupt controller, with 52 interrupt inputs. For the most part each core has
exactly the same interrupts routed to it, though there are some exceptions, referred to as core-local interrupts , where
there is an individual per-core interrupt source mapped to the same interrupt number on each core:
•Cross-core FIFO interrupts: SIO_IRQ_FIFO  and SIO_IRQ_FIFO_NS  (Section 3.1.5 )
•Cross-core doorbell interrupts: SIO_IRQ_BELL  and SIO_IRQ_BELL_NS  (Section 3.1.6 )
•RISC-V platform timer (also usable by Arm cores): SIO_IRQ_MTIMECMP  (Section 3.1.8 )
•GPIO interrupts: IO_IRQ_BANK0 , IRQ_IO_BANK0_NS , IO_IRQ_QSPI , IO_IRQ_QSPI_NS  (Section 9.5 )
The remaining interrupt inputs have the same interrupt source mirrored identically on both cores. Non-core-local
interrupts should only be enabled in the interrupt controller of a single core at a time, and will be serviced by the core
whose interrupt controller they are enabled in.
Table 95. System-level
interrupt numbering.
All interrupts are
routed to both
processors.IRQ Interrupt Source IRQ Interrupt Source IRQ Interrupt Source IRQ Interrupt Source IRQ Interrupt Source
0 TIMER0_IRQ_0 11 DMA_IRQ_1 22 IO_IRQ_BANK0_NS 33 UART0_IRQ 44 POWMAN_IRQ_POW
1 TIMER0_IRQ_1 12 DMA_IRQ_2 23 IO_IRQ_QSPI 34 UART1_IRQ 45 POWMAN_IRQ_TIMER
2 TIMER0_IRQ_2 13 DMA_IRQ_3 24 IO_IRQ_QSPI_NS 35 ADC_IRQ_FIFO 46 SPAREIRQ_IRQ_0
RP2350 Datasheet
3.2. Interrupts 82
IRQ Interrupt Source IRQ Interrupt Source IRQ Interrupt Source IRQ Interrupt Source IRQ Interrupt Source
3 TIMER0_IRQ_3 14 USBCTRL_IRQ 25 SIO_IRQ_FIFO 36 I2C0_IRQ 47 SPAREIRQ_IRQ_1
4 TIMER1_IRQ_0 15 PIO0_IRQ_0 26 SIO_IRQ_BELL 37 I2C1_IRQ 48 SPAREIRQ_IRQ_2
5 TIMER1_IRQ_1 16 PIO0_IRQ_1 27 SIO_IRQ_FIFO_NS 38 OTP_IRQ 49 SPAREIRQ_IRQ_3
6 TIMER1_IRQ_2 17 PIO1_IRQ_0 28 SIO_IRQ_BELL_NS 39 TRNG_IRQ 50 SPAREIRQ_IRQ_4
7 TIMER1_IRQ_3 18 PIO1_IRQ_1 29 SIO_IRQ_MTIMECMP 40 PROC0_IRQ_CTI 51 SPAREIRQ_IRQ_5
8 PWM_IRQ_WRAP_0 19 PIO2_IRQ_0 30 CLOCKS_IRQ 41 PROC1_IRQ_CTI
9 PWM_IRQ_WRAP_1 20 PIO2_IRQ_1 31 SPI0_IRQ 42 PLL_SYS_IRQ
10 DMA_IRQ_0 21 IO_IRQ_BANK0 32 SPI1_IRQ 43 PLL_USB_IRQ
On RP2350, only the lower 46 IRQ signals are connected to system-level interrupt sources, and IRQs 46 to 51 are
hardwired to zero (never firing). These six spare interrupts, referred to as SPAREIRQ_IRQ_0  through SPAREIRQ_IRQ_5  in the
table, are deliberately reserved for the cores to interrupt themselves (via the Arm NVIC_ISPR0  registers or the Hazard3
MEIFA  CSR), for example, when an interrupt handler wants to schedule a "bottom half" handler for work that must be
done after exiting the interrupt handler, but before returning to the code running in the foreground.
Nested interrupts are supported in hardware: a lower-priority interrupt can be pre-empted by a higher-priority interrupt or
fault, and will resume once the higher-priority handler returns. The pre-emption priority order is determined by the
interrupt priority registers starting from NVIC_IPR0  (Cortex-M33) or the MEIPRA  interrupt priority array CSR (Hazard3).
When there is a choice of multiple interrupts to be entered at the same dynamic priority, the interrupt with the lowest
IRQ number is chosen as a tie-breaker. The system-level IRQ numbering has been chosen to generally put higher-priority
interrupts at lower IRQ numbers for this reason, though the true priority is often dependent on the specific application.
3.2.1. Non-maskable interrupt (NMI)
The system IRQ signals can be routed to the Cortex-M33 non-maskable interrupt (NMI) input, by setting the bit for that
IRQ number in NMI_MASK0  or NMI_MASK1 . The non-maskable interrupt ignores the processor’s interrupt
enable/disable state (PRIMASK), and can pre-empt any other active interrupt. NMIs are generally used for emergent
circumstances that require the processor’s unconditional attention, such as loss of PLL lock or power supply integrity.
The NMI mask registers are core-local, so each core can have a different combination of interrupts routed to its NMI
input. The NMI mask, along with all other EPPB registers, is reset by a warm reset of that core. This avoids an issue on
RP2040 where the NMI mask could be left set following a processor reset.
In addition to system-level interrupts, the non-maskable interrupt is asserted when an integrity check is failed in the
redundancy coprocessor (RCP, Section 3.6.3 ). This behaviour cannot be disabled, but a correctly-programmed RCP
does not trigger under normal voltage, frequency, and temperature conditions. Likewise, if user code does not execute
any RCP instructions, the RCP will never trigger. The RCP NMI output is asserted on both cores when an integrity check
fails, and is de-asserted by a warm processor reset.
3.2.2. Further reading on interrupts
This section describes the routing of system-level interrupt requests to the processor subsystem. It omits important
details such as the processor’s response to receiving an interrupt, and how processors choose which system-level
interrupt requests to subscribe to. The following is a selection of relevant information for these topics:
•Section 3.7.2.5  describes the Cortex-M33’s internal interrupt controller, the NVIC
•Register listings starting from NVIC_ISER0  describe controls for NVIC operation
•Section 3.7.4.6  is an overview of Cortex-M33 exception handling
RP2350 Datasheet
3.2. Interrupts 83
•The Armv8-M Architecture Reference Manual  describes detailed architecture rules for exception handling
•Section 3.8.4  describes standard RISC-V trap handling
•Section 3.8.4.2  describes the standard RISC-V external, timer and software interrupt requests, and how they are
connected on RP2350
•Section 3.8.6.1  describes the Xh3irq interrupt controller, which provides priority-controlled interrupt support for the
system-level interrupts on Hazard3
•Each peripheral has its own interrupt registers which control the assertion of its system-level interrupts listed in
Table 95  — see peripheral documentation for more information
3.3. Event signals (Arm)
Using the WFE instruction, the Cortex-M33 can enter a sleep state until an "event" (or interrupt) takes place. It can also
generate events using the SEV instruction. RP2350 cross-wires event signals between the two processors: an event sent
by one processor will be received on the other.
NOTE
The event flag is "sticky": if both processors send an event ( SEV) simultaneously, then enter the sleep state ( WFE), they
will both wake immediately. This prevents the processors from getting stuck in a sleep state in this scenario.
Processors also receive an event signal from the global monitor if their reservation is lost due to a write by a different
master, in accordance with Armv8-M architecture requirements.
While in a WFE (or WFI) sleep state, the processor shuts off its internal clock gates to reduce power consumption. When
both  processors are in a sleep state and the DMA is inactive, all of RP2350 can enter a sleep state, disabling clocks on
unused infrastructure such as the bus fabric. The rest of RP2350 wakes automatically when either of the processors
wakes. See Section 6.5.2 .
3.4. Event signals (RISC-V)
The Hazard3 h3.block  instruction halts processor execution until an unblock signal is received. The h3.unblock  instruction
sends an unblock signal to other processors. These NOP-compatible hint instructions are documented in Section
3.8.6.3 .
On RP2350 the Hazard3 unblock in/out signals are cross-connected between the two processors, and each processor’s
unblock output is also fed back into its input. The global monitor also posts an unblock signal to each core when that
core loses a reservation due to an access by another core or the system DMA.
The Hazard3 MSLEEP  CSR defines how deep a sleep the processor will enter when executing a h3.block  instruction. By
default this is a simple pipeline stall, but the processor can also gate its own clock and negotiate the system-level clock
wake/sleep state with the clocks block ( Section 6.5.2 ).
The h3.unblock  instruction is "sticky": an h3.block  will fall through immediately if any unblock signal has been received
since the last time the processor executed an h3.block  instruction.
3.5. Debug
The Serial Wire Debug (SWD) bus provides access to hardware and software debug features including:
•Loading firmware into SRAM or external flash memory
RP2350 Datasheet
3.3. Event signals (Arm) 84
•Control of processor execution: run/halt, step, set breakpoints, other standard debug functionality
•Access to processor architectural state
•Access to memory and memory-mapped IO via the system bus
•Configuring the CoreSight trace hardware (Arm processors only)
The SWD bus is exposed on two dedicated pins, SWCLK and SWDIO. See Table 1430  for the pin definitions for SWCLK
and SWDIO, and see Table 1440  for additional information on their specifications.
A single SW-DP provides access to RP2350’s debug subsystem from the external SWCLK and SWDIO pins. The DP is
multidrop-capable, but use of multidrop SWD is not mandatory. All hardware in the debug subsystem, with the exception
of the RP-AP, can also be accessed directly from the system bus using the self-hosted debug window starting at
CORESIGHT_PERIPH_BASE .
External Pads
Self-hosted 
Debug APB
Arm
Core 0Arm
Core 1
RISC-V
Core 0RISC-V
Core 1RISC-V
Debug
ModuleSW-DP
ROM
Table
(0x00000)AHB-AP:
Core 0
(0x02000)AHB-AP:
Core 1
(0x04000)Timestamp
Generator
(0x06000)ATB
Funnel
(0x07000)TPIU
(0x08000)CTI
(0x09000)APB-AP:
RISC-V
(0x0a000)RP-AP
(0x80000)APB CrossbarSWD MuxInternal Probe Bitbang System BusFigure 10. RP2350
debug topology. An
SW-DP connects the
external SWD pins to
internal debug
hardware. The ROM
table lists debug
components, for
automatic discovery.
AHB-APs provide
debug access to Arm
processors, and an
APB-AP provides
access to a standard
RISC-V Debug Module.
The RP-AP provides
Raspberry-Pi-specific
controls such as
rescue reset and
debug key entry.
Remaining
components are for
Arm trace.
The numbers in brackets in Figure 10  are the addresses of the debug components within the debug address space.
These correspond to values written to the SW-DP SELECT register for SWD accesses, or offsets from
CORESIGHT_PERIPH_BASE  for self-hosted debug access. All APs are accessible through the SW-DP, and all except the
RP-AP are also accessible through self-hosted debug.
The SW-DP and RP-AP are in the always-on power domain, and are available once external power is applied and the
power-on reset (POR) time has elapsed. All other APs in Figure 10  are available only once:
1.the power manager (POWMAN) has sequenced the first power up of the switched core domain
2.the OTP PSM has read critical hardware configuration flags from OTP
3.the system clock ( clk_sys) is running
3.5.1. Connecting to the SW-DP
The SW-DP defaults to the Dormant state at power-up or assertion of the external reset (RUN) pin. A Dormant-to-SWD
sequence must be issued before beginning SWD operations. See the Arm Debug Interface specification, version 6, for
details of Dormant/SWD state switching: https://developer.arm.com/documentation/ihi0074/latest/
After a power-on, the following sequence can be used to connect to the SW-DP:
1.At least 8 × SWCLK cycles with SWDIO high.
RP2350 Datasheet
3.5. Debug 85
2.The 128-bit Selection Alert sequence: 0x19bc0ea2 , 0xe3ddafe9 , 0x86852d95 , 0x6209f392 , LSB-first.
3.Four SWCLK cycles with SWDIO low.
4.SWD activation code sequence : 0x1a, LSB first.
5.At least 50 × SWCLK cycles with SWDIO high (line reset).
6.A DPIDR read to exit the Reset state
In order to wake up the system from a low power (P1.x) state, set the CDBGPWRUPREQ in the DP CTRL/STAT register,
then poll CDBGPWRUPACK in the same register until set. In low-power states, only the SW-DP and RP-AP are accessible,
as the remaining debug logic is unpowered.
3.5.2. Arm debug
There are two AHB5 Mem-APs, at offsets 0x02000 and 0x04000 in the debug address space, which are used to debug the
two Arm Cortex-M33 processors. Each Mem-AP is an AHB5 manager which accesses a 32-bit downstream address
space. This is the same address space accessed by a processor’s load/store instructions, which includes system-level
hardware such as memory and peripherals, and processor-internal hardware on the processor’s private peripheral bus
(PPB). Certain PPB registers are visible only when accessed from the Mem-AP, not when accessed by software running
on the processor.
The AHB5 Mem-AP’s own register map is defined in Arm’s ADIv6 specification. Generally this is only of interest to those
implementing their own debug translator, and the Mem-AP can be thought of simply as a bridge between a DP (such as
RP2350’s SW-DP) and a downstream address space.
The standard Arm debug registers used to debug software running on the Cortex-M33 can be found documented in the
Armv8-M Architecture Reference Manual , or the Cortex-M33 Technical Reference Manual, available from Arm Ltd. This
datasheet also documents the core’s internal registers in Section 3.7.5 .
The Mem-APs can access system peripherals and memory at exactly the same addresses they would be accessed by
software running on the processor. However, the privilege and security of Mem-AP accesses may be different from the
security state of the software running on the processor at the point it halted: the privilege and security of Mem-AP
accesses is configured explicitly via its control and status word (CSW) register. Care must be taken when debugging
Non-secure software which accesses the SIO, for example, because by default the debugger may access the Secure
alias of the SIO, not the Non-secure alias which software will have been accessing.
The bus filters configured by the ACCESSCTRL bus access permission registers ( Section 10.6.2 ) treat bus accesses
originating from the Mem-APs as distinct from bus accesses originating from software running on the processor. This
means it is possible to lock software out from a peripheral, whilst still allowing debugger access.
3.5.3. RISC-V debug
There is a single APB Mem-AP, at offset 0x0a000 in the debug address space, which provides access only to the RISC-V
Debug Module (DM). The DM is a standard component which the debugger uses to enumerate RISC-V harts present in
the system, debug software running on each hart, and access the system bus. It is defined in the RISC-V debug
specification, of which RP2350 implements version 0.13.2.
From the point of view of the RISC-V debug specification, the SW-DP and APB Mem-AP function jointly as the Debug
Transport Module for this system. The DM is located at offset 0x0 in the APB-AP’s downstream address space, and the
registers are word-sized and byte-addressed, meaning the DM register addresses in the debug specification must be
multiplied by 4 to get the correct APB address.
On RP2350, each core possesses exactly one hardware thread (hart). Core 0 has a hart ID of 0, and core 1 has a hart ID
of 1. These hart IDs match the hart index used in the DM. This DM is also equipped with the hart array mask select
extension, which allows multiple cores to be reset/halted/resumed simultaneously.
The DM is equipped with the System Bus Access (SBA) extension, which allows the debugger to access the system bus
without halting either core. This can be used for minimally intrusive debug techniques like Segger RTT. SBA accesses
RP2350 Datasheet
3.5. Debug 86
arbitrate with core 1’s load/store port to access the system bus, but they are treated as distinct from core 1’s accesses
for the purpose of bus filtering ( Section 10.6.2 ), which means it is possible to lock software out of a peripheral whilst
retaining debug access. Processor load/stores in Debug mode are also treated as debug accesses for the purpose of
bus filtering.
The DM is able to reset each core individually using the dmcontrol.hartreset  control. This resets only the selected
processor. The dmcontrol.ndmreset  resets both processors only, which is the minimum requirement in the RISC-V debug
specification. A full system reset, which includes the DM, can be performed using the SYSRESETREQ control in the SW-
DP, a switched core domain reset configured in POWMAN and initiated by the watchdog, or any full-system reset such
as the RUN pin. A PSM reset initiated by the watchdog can reset almost all system-level hardware except for the DM,
but note that the DM becomes momentarily inaccessible whilst the system clock’s clock generator is reset, which is the
reason for dmcontrol.ndmreset  resetting the processors only.
For details on the processor side of RISC-V debug, see Section 3.8.5 . See also the Hazard3 source code at
github.com/Wren6991/Hazard3 , which includes the DM implementation under the hdl/debug/dm/  directory.
3.5.4. Debug power domains
The SW-DP and the RP-AP are in the always-on power domain. This means they are available even when the system is in
its lowest-power state, with the switched core domain (which includes the processors) fully powered down.
The remainder of the debug hardware is in the switched core domain. This is the same domain as the processors and
system peripherals.
Setting the CDBGPWRUPREQ bit in the SW-DP’s CTRL/STAT register will force a power up of the switched core domain,
making the remaining debug hardware available. This power up takes some time, as it is sequenced by the 32 kHz low-
power oscillator ( Section 8.4 ), so the CDBGPWRUPACK bit must be polled to wait for the system to power up before
attempting to access any APs other than the RP-AP. See Arm’s ADIv6 specification for the SW-DP’s register listing.
Note that the RP-AP is accessible without asserting CDBGPWRUPREQ, as it is always powered.
3.5.5. Software control of SWD pins
The DBGFORCE  register in SYSCFG can be used to detach the SW-DP from the external debug pads, and instead bitbang
the internal SWD signals directly from software. This is intended for a debug probe running on one core being used to
debug the other core. For other use cases it is generally cleaner to use the self-hosted debug access to interface with
the APs directly from the system bus.
3.5.6. Self-hosted debug
All APs shown in Figure 10 , except for the RP-AP, have direct memory-mapped access from the system bus. This is
known as self-hosted debug, because with care it allows running a debug host (i.e. a debugger) directly on-system. It
can also be used to access the trace hardware, which can be used for self-hosted trace using the trace DMA FIFO. By
default only Secure access is permitted, as the processor debug presents an opportunity for Non-secure code to
interfere with the Secure context and/or perform Secure bus accesses.
The self-hosted debug window starts at address 0x40140000  (CORESIGHT_PERIPH_BASE ). The offsets of the APs within
this window are the same as the APs' addresses when accessed from the SW-DP.
Because of the blocking nature of the AHB-AP’s DRW register, and its interactions with the Cortex-M33’s arbitration of
AHB-AP accesses with load/stores, certain accesses have potential to cause bus lockup due to circular bus stall
dependencies. In particular, cores may not access their own AHB-APs through the self-hosted debug window, and AHB-
APs may not access AHB-APs through the self-hosted debug window — attempting to do so will immediately return a
bus fault. To reduce the opportunities for deadlock, a full APB crossbar is used to connect the SW-DP and the self-
hosted debug port to the APs, so that for example self-hosted use of the Arm trace hardware will not interfere with an
external debugger attaching via the AHB-APs.
RP2350 Datasheet
3.5. Debug 87
There are some cases where a bus deadlock can not be avoided, such as a core using the other core’s AHB-AP, via the
self-hosted debug window, to access some other APB peripheral:
1.The access upstream of the APB’s DRW register will not complete until the downstream access completes
2.The downstream access will not complete until it is granted access to the system APB bridge
3.Access to the APB bridge will not be granted until the upstream access, which is occupying the system APB bridge,
completes
4.See point 1.
This situation can arise when running a self-hosted debugger on one core, and debugging code on the other core which
accesses APB addresses. The deadlock is eventually broken when the APB bridge’s 65536-cycle timeout expires,
abandoning the transfer and returning a bus error to the origin of the upstream access. To avoid this, software should
detect when it is about to use an AP to access an APB address (an address starting with 0x4), and perform the access
directly instead of using the Mem-AP.
This type of deadlock does not occur when the debugger accesses the bus with RISC-V System Bus Access, because
the bus transfer upstream of the DM does not block on completion of the downstream access.
3.5.7. Trace
3.5.7.1. Overview
The ATB trace subsystem is based on the Coresight SoC-600M architecture, as shown in Figure 11 .
Upsizer 8/16 AT Buffer
AT Buffer
AT Buffer
AT BufferUpsizer 8/16
Upsizer 8/16
Upsizer 8/16Timestamp
Generator
FunnelAT Buffer
Trace 
FIFOTPIUITM
ETMATBI
Trace port75 MHz4 bit DDR
Internal Trace Capture
DMA ControllerATBE
Cortex-M33
Raspberry PiSoC-600MFigure 11. Trace
Subsystem
The trace subsystem captures trace messages from each of the Cortex-M33 ITM/ETM components, merges them into
a single trace bus, and sends off-chip through the 4-bit DDR trace port for subsequent capture and analysis by a trace
port analyser.
This allows the developer to review a detailed log of software executed on the processors. The advantage over
conventional hardware debug is that it does this without halting the processors or affecting their execution timing, so
you can diagnose software issues that are hard to reproduce under a debugger.
The trace subsystem comprises the following main components:
•Timestamp Generator: Timestamps propagate to both Cortex-M33 processors, and are applied to ETM and ITM
output so that the relative timing of their trace streams can be recovered.
•Cortex-M33 ETM: Embedded Trace Macrocell, for real-time instruction flow messages generated from
observations of the Cortex-M33’s execution.
•Cortex-M33 ITM: Instruction Trace Macrocell, for software-generated messages.
•ATB Funnel: Merges the Cortex-M33 trace sources into a single trace stream using the timestamps from the
Timestamp Generator.
•TPIU: Trace Port Interface Unit, outputs trace data over trace port pins. The source-synchronous trace interface is
4-bits DDR, up to 75 MHz clock, giving a maximum trace data rate of up to 600 Mb/s.
RP2350 Datasheet
3.5. Debug 88
•Trace FIFO: Optionally captures the 32-bit TPIU trace stream on-device, from which point the DMA can transfer to
main system SRAM.
See the Arm CoreSight ETM-M33 Technical Reference Manual  for information about the Cortex-M33 ETM. See the SoC-
600M Technical Reference Manual  for information about the other trace components in Figure 11
The trace output clock is fixed at one half of clk_sys. At the maximum system frequency of 150 MHz this yields a
75 MHz TPIU output clock. The trace throughput is reduced at lower system clock frequencies, though this is rarely an
issue in practice as the processor instruction throughput (and therefore the demand for trace output bandwidth) scales
accordingly.
3.5.7.2. Trace FIFO
Trace output goes to one of two data sinks:
•The four-bit TPIU interface streams data out of the chip through GPIOs, for capture by an external probe
•The trace FIFO streams data into SRAM via the system DMA
The bandwidth of the DMA is greater than the bandwidth of the TPIU interface. Capturing into an on-chip buffer also
allows trace to operate through a comparatively low-speed SWD probe without restricting trace bandwidth.
The operation is similar to a micro-trace buffer (MTB). However, all of system SRAM is available for trace. You can also
use other DMA endpoints like the PIO and HSTX to implement your own trace data sinks, for example if you would
prefer a wider and lower-frequency bus than the TPIU provides.
You must enable DMA access to the trace FIFO registers by setting the DMA bit in the ACCESSCTRL CORESIGHT_TRACE 
register before attempting to DMA from this FIFO. Configure the DMA for DREQ 53 to select the trace FIFO.
3.5.7.3. List of trace FIFO registers
The trace FIFO registers start at a base address of 0x50700000  (defined as CORESIGHT_TRACE_BASE  in the SDK).
Table 96. List of
CORESIGHT_TRACE
registersOffset Name Info
0x0 CTRL_STATUS Control and status register
0x4 TRACE_CAPTURE_FIFO FIFO for trace data captured from the TPIU
CORESIGHT_TRACE : CTRL_STATUS Register
Offset : 0x0
Description
Control and status register
Table 97.
CTRL_STATUS
RegisterBits Description Type Reset
31:2 Reserved. - -
1 TRACE_CAPTURE_FIFO_OVERFLOW : This status flag is set high when trace
data has been dropped due to the FIFO being full at the point trace data was
sampled. Write 1 to acknowledge and clear the bit.RW 0x0
RP2350 Datasheet
3.5. Debug 89
Bits Description Type Reset
0 TRACE_CAPTURE_FIFO_FLUSH : Set to 1 to continuously hold the trace FIFO in
a flushed state and prevent overflow.
Before clearing this flag, configure and start a DMA channel with the correct
DREQ for the TRACE_CAPTURE_FIFO register.
Clear this flag to begin sampling trace data, and set once again once the trace
capture buffer is full. You must configure the TPIU in order to generate trace
packets to be captured, as well as components like the ETM further upstream
to generate the event stream propagated to the TPIU.RW 0x1
CORESIGHT_TRACE : TRACE_CAPTURE_FIFO Register
Offset : 0x4
Description
FIFO for trace data captured from the TPIU
Table 98.
TRACE_CAPTURE_FIF
O RegisterBits Description Type Reset
31:0 RDATA : Read from an 8 x 32-bit FIFO containing trace data captured from the
TPIU.
Hardware pushes to the FIFO on rising edges of clk_sys, when either of the
following is true:
* TPIU TRACECTL output is low (normal trace data)
* TPIU TRACETCL output is high, and TPIU TRACEDATA0 and TRACEDATA1
are both low (trigger packet)
These conditions are in accordance with Arm Coresight Architecture Spec
v3.0 section D3.3.3: Decoding requirements for Trace Capture Devices
The data captured into the FIFO is the full 32-bit TRACEDATA bus output by
the TPIU. Note that the TPIU is a DDR output at half of clk_sys, therefore this
interface can capture the full 32-bit TPIU DDR output bandwidth as it samples
once per active edge of the TPIU output clock.RF 0x00000000
3.5.8. Rescue reset
A rescue reset is a full system reset, similar to asserting the RUN pin low, which also sets a flag telling the bootrom to
halt before running any user software. This is performed over the SWD bus using the RP-AP, and can be performed even
when system clocks are stopped and the switched core power domain is powered down. This is used in the case where
the chip has locked up, for example if code has been programmed into flash which permanently halts the system clock:
since the debugger can no longer communicate with the processors to return the system to a working state, more
drastic action is needed. This functionality was provided by the Rescue DP on RP2040, but on RP2350 it is provided by
the RP-AP, to avoid mandatory use of multidrop SWD.
A rescue is invoked by setting and then clearing the CTRL .RESCUE_RESTART bit in the RP-AP. This causes a hard reset
of the chip, and sets CHIP_RESET .RESCUE_FLAG to indicate that a rescue reset took place. The bootrom checks this
flag almost immediately in the initial boot process (before watchdog, flash or USB boot), acknowledges by clearing the
bit, then halts the processor. This leaves the system in a safe state, with the system clock running, so that the debugger
can reattach to the cores and load fresh code.
RP2350 Datasheet
3.5. Debug 90
3.5.9. Security
By default, the SWD debug access port allows an external debugger to access all system memory and peripherals, and
to observe and change the execution of software running on the processors. If boot signature enforcement is enabled
(Section 10.1.1 ), debug access becomes a security concern, as it is able to sidestep this protection. To account for this,
RP2350 supports progressively locking down the debug port using configuration in on-chip OTP storage.
Conceptually there are two control bits: debug disable, and secure debug disable. Debug disable is intended to
completely cut off debug access to the processors and the system bus, whilst the secure debug disable forbids Secure
bus accesses, and halting of processors in the Secure state, but still allows Non-secure software to be debugged as
normal. There are two ways to set these control bits:
•Setting the relevant OTP critical flag: CRIT1 .DEBUG_DISABLE or CRIT1 .SECURE_DEBUG_DISABLE to set the debug
disable or secure debug disable, respectively
•Installing a 128-bit fixed debug key as OTP key 5 or 6 ( Section 3.5.9.2 )
OTP configuration changes take effect at the next reset of the OTP block.
Once debug has been disabled, software can re-enable debug using the OTP DEBUGEN  register, which allows the secure
and overall debug enable to be cleared individually for each processor. For example, Secure software may implement a
shell where users can authenticate using a cryptographic challenge to enable debug on systems where it is disabled by
default. The DEBUGEN register belongs to the processor cold reset domain, so it is preserved over a PSM reset starting
from as early as OTP (the second PSM stage). This allows almost a full system reset without losing debug access.
To avoid accidental writes of the DEBUGEN  register, its bits can be individually locked using the matching bits in
DEBUGEN_LOCK .
This offers increasing levels of debug protection:
1.Fully open: no keys installed and no OTP debug disable flags are set. This is the most convenient configuration for
product development.
2.Access with key only: at least one key is installed, but no OTP debug disable flags are set.
3.No access even with key (an OTP debug disable flag is set), but Secure code can enable debug access by writing
to DEBUGEN .
4.No access even with key (an OTP debug disable flag is set), and DEBUGEN  is locked by DEBUGEN_LOCK .
3.5.9.1. Effects of debug disables
The secure debug disable flag ( CRIT1 .SECURE_DEBUG_DISABLE) has the following effects:
•Set Secure AP enable signals for Arm core 0 and core 1 AHB-APs to 0.
◦This prevents the APs from performing Secure bus accesses (including to the PPB).
◦Status is reported in the SDeviceEn  flag of the AHB-AP CSW register.
•Set the Cortex-M33 SPIDEN and SPNIDEN signals for both cores to 0.
◦This prevents the cores from being halted or traced whilst in the Secure state.
•Disable the factory test JTAG interface ( Section 10.10 ).
RP2350 Datasheet
3.5. Debug 91
NOTE
Both AHB-APs' CSW.HNONSEC  bits default to 0, generating Secure bus accesses. If the secure debug disable flag is set,
these bits must be set to 1 to generate Non-Secure bus accesses.
The debug disable flag ( CRIT1 .DEBUG_DISABLE) has all of the effects of the secure debug disable flag. It also has the
following additional effects:
•Set AP enable signals for Arm core 0 and core 1 AHB-APs to 0.
◦This prevents the APs from performing any bus accesses at all (including to the PPB).
◦Status is reported in the DeviceEn  flag of the AHB-AP CSW register.
•Set AP enable signal for RISC-V DM APB-AP to 0.
◦This prevents the AP from accessing the RISC-V Debug Module.
◦Status is reported in the DeviceEn  flag of the APB-AP CSW register.
•Set DBGEN and NIDEN signals for the CTI to 0.
On RISC-V CRIT1 .SECURE_DEBUG_DISABLE has no useful effect. Debug-mode accesses from the cores always have
Secure and Privileged bus attributes, except when reduced by FORCE_CORE_NS . Likewise, System Bus Access via the
Debug Module is always Secure and Privileged, unless FORCE_CORE_NS .CORE1 is set, in which case it is Non-secure
and Privileged. Use the CRIT1 .DEBUG_DISABLE flag on RISC-V.
3.5.9.2. Debug keys
Section 13.5.2  describes the OTP hardware access keys. Hardware reads OTP access keys into hidden registers as part
of the OTP power-up sequence which takes place after an OTP reset, and the corresponding OTP locations then
become inaccessible. OTP keys 5 and 6 are special in that they control access to the SWD debug hardware in addition to
functioning as normal OTP page keys.
A debug key is a 128-bit fixed challenge. Installing a debug key in OTP locks down debug access, and it remains locked
until the debug host writes a matching key value through the RP-AP DBGKEY  register. This is a write-only interface.
To install a debug key, first program the OTP locations starting from KEY5_0  or KEY6_0 . These locations are ECC-
protected. Once you have programmed the 128-bit key value and read it back to confirm the correct value is
programmed, write the raw bit pattern 0x010101  to KEY5_VALID  or KEY6_VALID  to mark the key as valid. The validity
takes effect at the next reset of the OTP block.
Once a key is valid, the OTP storage locations for that key become inaccessible for both reads and writes. Only the OTP
power-up state machine ( Section 13.3.4 ) can read the key.
The effect of installing debug keys depends on which of key 5 and 6 are installed:
•If key 5 or key 6 is valid, and no matching key (either) has been entered through the RP-AP, all debug is disabled.
This has the same effect as setting CRIT1 .DEBUG_DISABLE.
•If key 5 is valid, and no matching key (key 5 specifically) has been entered through the RP-AP, Secure debug is
disabled. This has the same effect as writing CRIT1 .SECURE_DEBUG_DISABLE.
When both keys are installed, key 5 provides both Secure and Non-secure debug access, and key 6 provides Non-secure
debug access only. When only a single key is installed, that key provides both Secure and Non-secure debug access.
To enter a key over SWD, first write a 1 to DBGKEY .RESET. Then sequentially write 128 bits to DBGKEY .DATA, each
accompanied by a 1 written to DBGKEY .PUSH. Write the data LSB-first, starting with the lowest-numbered OTP row.
Assuming you wrote a value that matched one of the installed debug keys, debug unlocks after the 128th push. The
SDeviceEn  and DeviceEn  flags in the Mem-AP CSW registers indicate success or failure.
Failure to supply a matching key through the RP-AP disables debug if it would otherwise be enabled. However, supplying
a key does not enable if it is already disabled for other reasons. For example, if CRIT1 .DEBUG_DISABLE is set, and
RP2350 Datasheet
3.5. Debug 92
DEBUGEN  is clear, debug is be disabled no matter the state of the debug keys and the RP-AP.
3.5.10. RP-AP
The RP-AP is a small register block which is always accessible over SWD. RP-AP access does not require the switched
core domain to be powered up, or any internal system clock generators to be running.
3.5.10.1. List of registers
The RP-AP registers start at offset 0x80000 in the debug address space, which is accessed via address 0x80000 in the SW-
DP’s SELECT register. Unlike the other APs, it can not be accessed directly from the system bus.
Table 99. List of
RP_AP registersOffset Name Info
0x000 CTRL This register is primarily used for DFT but can also be used to
overcome some power up problems. However, it should not be
used to force power up of domains. Use DBG_POW_OVRD for
that.
0x004 DBGKEY Serial key load interface (write-only)
0x008 DBG_POW_STATE_SWCORE This register indicates the state of the power sequencer for the
switched-core domain.
The sequencer timing is managed by the POWMAN_SEQ_*
registers. See the header file for those registers for more
information on the timing.
Power up of the domain commences by clearing bit 0 (IS_PD)
then bits 1-8 are set in sequence. Bit 8 (IS_PU) indicates the
sequence is complete.
Power down of the domain commences by clearing bit 8 (IS_PU)
then bits 7-1 are cleared in sequence. Bit 0 (IS_PU) is then set to
indicate the sequence is complete.
Bits 9-11 describe the states of the power manager clocks which
change as clock generators in the switched-core become
available following switched-core power up.
This bus can be sent to GPIO for debug. See
DBG_POW_OUTPUT_TO_GPIO in the DBG_POW_OVRD register.
0x00c DBG_POW_STATE_XIP This register indicates the state of the power sequencer for the
XIP domain.
The sequencer timing is managed by the POWMAN_SEQ_*
registers. See the header file for those registers for more
information on the timing.
Power up of the domain commences by clearing bit 0 (IS_PD)
then bits 1-8 are set in sequence. Bit 8 (IS_PU) indicates the
sequence is complete.
Power down of the domain commences by clearing bit 8 (IS_PU)
then bits 7-1 are cleared in sequence. Bit 0 (IS_PU) is then set to
indicate the sequence is complete.
RP2350 Datasheet
3.5. Debug 93
Offset Name Info
0x010 DBG_POW_STATE_SRAM0 This register indicates the state of the power sequencer for the
SRAM0 domain.
The sequencer timing is managed by the POWMAN_SEQ_*
registers. See the header file for those registers for more
information on the timing.
Power up of the domain commences by clearing bit 0 (IS_PD)
then bits 1-8 are set in sequence. Bit 8 (IS_PU) indicates the
sequence is complete.
Power down of the domain commences by clearing bit 8 (IS_PU)
then bits 7-1 are cleared in sequence. Bit 0 (IS_PU) is then set to
indicate the sequence is complete.
0x014 DBG_POW_STATE_SRAM1 This register indicates the state of the power sequencer for the
SRAM1 domain.
The sequencer timing is managed by the POWMAN_SEQ_*
registers. See the header file for those registers for more
information on the timing.
Power up of the domain commences by clearing bit 0 (IS_PD)
then bits 1-8 are set in sequence. Bit 8 (IS_PU) indicates the
sequence is complete.
Power down of the domain commences by clearing bit 8 (IS_PU)
then bits 7-1 are cleared in sequence. Bit 0 (IS_PU) is then set to
indicate the sequence is complete.
0x018 DBG_POW_OVRD This register allows external control of the power sequencer
outputs for all the switched power domains. If any of the power
sequencers stall at any stage then force power up operation of
all domains by running this sequence:
- set DBG_POW_OVRD = 0x3b to force small power switches on,
large power switches off, resets on and isolation on
- allow time for the domain power supplies to reach full rail
- set DBG_POW_OVRD = 0x3b to force large power switches on
- set DBG_POW_OVRD = 0x37 to remove isolation
- set DBG_POW_OVRD = 0x17 to remove resets
0x01c DBG_POW_OUTPUT_TO_GPIO Send some, or all, bits of DBG_POW_STATE_SWCORE to gpios.
Bit 0 sends bit 0 of DBG_POW_STATE_SWCORE to GPIO 34
Bit 1 sends bit 1 of DBG_POW_STATE_SWCORE to GPIO 35
Bit 2 sends bit 2 of DBG_POW_STATE_SWCORE to GPIO 36
.
.
Bit 11 sends bit 11 of DBG_POW_STATE_SWCORE to GPIO 45
0xdfc IDR Standard Coresight ID Register
RP_AP : CTRL Register
Offset : 0x000
Description
This register is primarily used for DFT but can also be used to overcome some power up problems. However, it
should not be used to force power up of domains. Use DBG_POW_OVRD for that.
Table 100. CTRL
Register
RP2350 Datasheet
3.5. Debug 94
Bits Description Type Reset
31 RESCUE_RESTART : Allows debug of boot problems by restarting the chip with
minimal boot code execution. Write to 1 to put the chip in reset then write to 0
to restart the chip with the rescue flag set. The rescue flag is in the
POWMAN_CHIP_RESET register and is read by boot code. The rescue flag is
cleared by writing 0 to POWMAN_CHIP_RESET_RESCUE_FLAG or by resetting
the chip by any means other than RESCUE_RESTART.RW 0x0
30 SPARE : Unused RW 0x0
29:7 Reserved. - -
6 DBG_FRCE_GPIO_LPCK : Allows chip start-up when the Low Power Oscillator
(LPOSC) is inoperative or malfunctioning and also allows the initial power
sequencing rate to be adjusted. Write to 1 to force the LPOSC output to be
driven from a GPIO (gpio20 on 80-pin package, gpio34 on the 60-pin package).
If the LPOSC is inoperative or malfunctioning it may also be necessary to set
the LPOSC_STABLE_FRCE bit in this register. The user must provide a clock on
the GPIO. For normal operation use a clock running at around 32kHz.
Adjusting the frequency will speed up or slow down the initial power-up
sequence.RW 0x0
5 LPOSC_STABLE_FRCE : Allows the chip to start-up even though the Low Power
Oscillator (LPOSC) is failing to set its stable flag. Initial power sequencing is
clocked by LPOSC at around 32kHz but does not start until the LPOSC
declares itself to be stable. If the LPOSC is otherwise working correctly the
chip will boot when this bit is set. If the LPOSC is not working then
DBG_FRCE_GPIO_LPCK must be set and an external clock provided.RW 0x0
4 POWMAN_DFT_ISO_OFF : Holds the isolation gates between power domains in
the open state. This is intended to hold the gates open for DFT and power
manager debug. It is not intended to force the isolation gates open. Use the
overrides in DBG_POW_OVRD to force the isolation gates open or closed.RW 0x0
3 POWMAN_DFT_PWRON : Holds the power switches on for all domains. This is
intended to keep the power on for DFT and debug, rather than for switching
the power on. The power switches are not sequenced and the sudden demand
for current could cause the always-on power domain to brown out. This
register is in the always-on domain therefore chaos could ensue. It is
recommended to use the DBG_POW_OVRD controls instead.RW 0x0
2 POWMAN_DBGMODE : This prevents the power manager from powering down
and resetting the switched-core power domain. It is intended for DFT and for
debugging the power manager after the chip has booted. It cannot be used to
force initial power on because it simultaneously deasserts the reset.RW 0x0
1 JTAG_FUNCSEL : Multiplexes the JTAG ports onto GPIO0-3 RW 0x0
0 JTAG_TRSTN : Resets the JTAG module. Active low. RW 0x0
RP_AP : DBGKEY Register
Offset : 0x004
Description
Serial key load interface (write-only)
Table 101. DBGKEY
RegisterBits Description Type Reset
31:3 Reserved. - -
RP2350 Datasheet
3.5. Debug 95
Bits Description Type Reset
2 RESET : Reset (before sending a new key) RW 0x0
1 PUSH RW 0x0
0 DATA RW 0x0
RP_AP : DBG_POW_STATE_SWCORE Register
Offset : 0x008
Description
This register indicates the state of the power sequencer for the switched-core domain.
The sequencer timing is managed by the POWMAN_SEQ_* registers. See the header file for those registers for more
information on the timing.
Power up of the domain commences by clearing bit 0 (IS_PD) then bits 1-8 are set in sequence. Bit 8 (IS_PU)
indicates the sequence is complete.
Power down of the domain commences by clearing bit 8 (IS_PU) then bits 7-1 are cleared in sequence. Bit 0 (IS_PU)
is then set to indicate the sequence is complete.
Bits 9-11 describe the states of the power manager clocks which change as clock generators in the switched-core
become available following switched-core power up.
This bus can be sent to GPIO for debug. See DBG_POW_OUTPUT_TO_GPIO in the DBG_POW_OVRD register.
Table 102.
DBG_POW_STATE_SW
CORE RegisterBits Description Type Reset
31:12 Reserved. - -
11 USING_FAST_POWCK : Indicates the source of the power manager clock. On
switched-core power up the clock switches from the LPOSC to clk_ref and this
flag will be set. clk_ref will be running from the ROSC initially but will switch to
XOSC when it comes available. On switched-core power down the clock
switches to LPOSC and this flag will be cleared.RO 0x0
10 WAITING_POWCK : Indicates the switched-core power sequencer is waiting for
the power manager clock to update. On switched-core power up the clock
switches from the LPOSC to clk_ref. clk_ref will be running from the ROSC
initially but will switch to XOSC when it comes available. On switched-core
power down the clock switches to LPOSC.
If the switched-core power up sequence stalls with this flag active then it
means clk_ref is not running which indicates a problem with the ROSC. If that
happens then set DBG_POW_RESTART_FROM_XOSC in the DBG_POW_OVRD
register to avoid using the ROSC.
If the switched-core power down sequence stalls with this flag active then it
means LPOSC is not running. The solution is to not stop LPOSC when the
switched-core power domain is powered.RO 0x0
9 WAITING_TIMCK : Indicates that the switched-core power sequencer is waiting
for the AON-Timer to update. On switched-core power-up there is nothing to
be done. The AON-Timer continues to run from the LPOSC so this flag will not
be set. Software decides whether to switch the AON-Timer clock to XOSC (via
clk_ref). On switched-core power-down the sequencer will switch the AON-
Timer back to LPOSC if software switched it to XOSC. During the switchover
the WAITING_TIMCK flag will be set. If the switched-core power down
sequence stalls with this flag active then the only recourse is to reset the chip
and change software to not select XOSC as the AON-Timer source.RO 0x0
8 IS_PU : Indicates the power somain is fully powered up. RO 0x0
7 RESET_FROM_SEQ : Indicates the state of the reset to the power domain. RO 0x0
RP2350 Datasheet
3.5. Debug 96
Bits Description Type Reset
6 ENAB_ACK : Indicates the state of the enable to the power domain. RO 0x0
5 ISOLATE_FROM_SEQ : Indicates the state of the isolation control to the power
domain.RO 0x0
4 LARGE_ACK : Indicates the state of the large power switches for the power
domain.RO 0x0
3 SMALL_ACK2 : The small switches are split into 3 chains. In the power up
sequence they are switched on separately to allow management of the VDD
rise time. In the power down sequence they switch off simultaneously with the
large power switches.
This bit indicates the state of the last element in small power switch chain 2.RO 0x0
2 SMALL_ACK1 : This bit indicates the state of the last element in small power
switch chain 1.RO 0x0
1 SMALL_ACK0 : This bit indicates the state of the last element in small power
switch chain 0.RO 0x0
0 IS_PD : Indicates the power somain is fully powered down. RO 0x0
RP_AP : DBG_POW_STATE_XIP Register
Offset : 0x00c
Description
This register indicates the state of the power sequencer for the XIP domain.
The sequencer timing is managed by the POWMAN_SEQ_* registers. See the header file for those registers for more
information on the timing.
Power up of the domain commences by clearing bit 0 (IS_PD) then bits 1-8 are set in sequence. Bit 8 (IS_PU)
indicates the sequence is complete.
Power down of the domain commences by clearing bit 8 (IS_PU) then bits 7-1 are cleared in sequence. Bit 0 (IS_PU)
is then set to indicate the sequence is complete.
Table 103.
DBG_POW_STATE_XIP
RegisterBits Description Type Reset
31:9 Reserved. - -
8 IS_PU : Indicates the power somain is fully powered up. RO 0x0
7 RESET_FROM_SEQ : Indicates the state of the reset to the power domain. RO 0x0
6 ENAB_ACK : Indicates the state of the enable to the power domain. RO 0x0
5 ISOLATE_FROM_SEQ : Indicates the state of the isolation control to the power
domain.RO 0x0
4 LARGE_ACK : Indicates the state of the large power switches for the power
domain.RO 0x0
3 SMALL_ACK2 : The small switches are split into 3 chains. In the power up
sequence they are switched on separately to allow management of the VDD
rise time. In the power down sequence they switch off simultaneously with the
large power switches.
This bit indicates the state of the last element in small power switch chain 2.RO 0x0
2 SMALL_ACK1 : This bit indicates the state of the last element in small power
switch chain 1.RO 0x0
1 SMALL_ACK0 : This bit indicates the state of the last element in small power
switch chain 0.RO 0x0
RP2350 Datasheet
3.5. Debug 97
Bits Description Type Reset
0 IS_PD : Indicates the power somain is fully powered down. RO 0x0
RP_AP : DBG_POW_STATE_SRAM0 Register
Offset : 0x010
Description
This register indicates the state of the power sequencer for the SRAM0 domain.
The sequencer timing is managed by the POWMAN_SEQ_* registers. See the header file for those registers for more
information on the timing.
Power up of the domain commences by clearing bit 0 (IS_PD) then bits 1-8 are set in sequence. Bit 8 (IS_PU)
indicates the sequence is complete.
Power down of the domain commences by clearing bit 8 (IS_PU) then bits 7-1 are cleared in sequence. Bit 0 (IS_PU)
is then set to indicate the sequence is complete.
Table 104.
DBG_POW_STATE_SR
AM0 RegisterBits Description Type Reset
31:9 Reserved. - -
8 IS_PU : Indicates the power somain is fully powered up. RO 0x0
7 RESET_FROM_SEQ : Indicates the state of the reset to the power domain. RO 0x0
6 ENAB_ACK : Indicates the state of the enable to the power domain. RO 0x0
5 ISOLATE_FROM_SEQ : Indicates the state of the isolation control to the power
domain.RO 0x0
4 LARGE_ACK : Indicates the state of the large power switches for the power
domain.RO 0x0
3 SMALL_ACK2 : The small switches are split into 3 chains. In the power up
sequence they are switched on separately to allow management of the VDD
rise time. In the power down sequence they switch off simultaneously with the
large power switches.
This bit indicates the state of the last element in small power switch chain 2.RO 0x0
2 SMALL_ACK1 : This bit indicates the state of the last element in small power
switch chain 1.RO 0x0
1 SMALL_ACK0 : This bit indicates the state of the last element in small power
switch chain 0.RO 0x0
0 IS_PD : Indicates the power somain is fully powered down. RO 0x0
RP_AP : DBG_POW_STATE_SRAM1 Register
Offset : 0x014
Description
This register indicates the state of the power sequencer for the SRAM1 domain.
The sequencer timing is managed by the POWMAN_SEQ_* registers. See the header file for those registers for more
information on the timing.
Power up of the domain commences by clearing bit 0 (IS_PD) then bits 1-8 are set in sequence. Bit 8 (IS_PU)
indicates the sequence is complete.
Power down of the domain commences by clearing bit 8 (IS_PU) then bits 7-1 are cleared in sequence. Bit 0 (IS_PU)
is then set to indicate the sequence is complete.
RP2350 Datasheet
3.5. Debug 98
Table 105.
DBG_POW_STATE_SR
AM1 RegisterBits Description Type Reset
31:9 Reserved. - -
8 IS_PU : Indicates the power somain is fully powered up. RO 0x0
7 RESET_FROM_SEQ : Indicates the state of the reset to the power domain. RO 0x0
6 ENAB_ACK : Indicates the state of the enable to the power domain. RO 0x0
5 ISOLATE_FROM_SEQ : Indicates the state of the isolation control to the power
domain.RO 0x0
4 LARGE_ACK : Indicates the state of the large power switches for the power
domain.RO 0x0
3 SMALL_ACK2 : The small switches are split into 3 chains. In the power up
sequence they are switched on separately to allow management of the VDD
rise time. In the power down sequence they switch off simultaneously with the
large power switches.
This bit indicates the state of the last element in small power switch chain 2.RO 0x0
2 SMALL_ACK1 : This bit indicates the state of the last element in small power
switch chain 1.RO 0x0
1 SMALL_ACK0 : This bit indicates the state of the last element in small power
switch chain 0.RO 0x0
0 IS_PD : Indicates the power somain is fully powered down. RO 0x0
RP_AP : DBG_POW_OVRD Register
Offset : 0x018
Description
This register allows external control of the power sequencer outputs for all the switched power domains. If any of
the power sequencers stall at any stage then force power up operation of all domains by running this sequence:
•set DBG_POW_OVRD = 0x3b to force small power switches on, large power switches off, resets on and
isolation on
•allow time for the domain power supplies to reach full rail
•set DBG_POW_OVRD = 0x3b to force large power switches on
•set DBG_POW_OVRD = 0x37 to remove isolation
•set DBG_POW_OVRD = 0x17 to remove resets
Table 106.
DBG_POW_OVRD
RegisterBits Description Type Reset
31:7 Reserved. - -
6 DBG_POW_RESTART_FROM_XOSC : By default the system begins boot as
soon as a clock is available from the ROSC, then it switches to the XOSC when
it is available. This is done because the XOSC takes several ms to start up. If
there is a problem with the ROSC then the default behaviour can be changed
to not use the ROSC and wait for XOSC. However, this requires a mask change
to modify the reset value of the Power Manager START_FROM_XOSC register.
To allow experimentation the default can be temporarily changed by setting
this register bit to 1. After setting this bit the core must be reset by a Coresight
dprst or a rescue reset (see RESCUE_RESTART in the RP_AP_CTRL register
above). A power-on reset, brown-out reset or RUN pin reset will reset this
control and revert to the default behaviour.RW 0x0
RP2350 Datasheet
3.5. Debug 99
Bits Description Type Reset
5 DBG_POW_RESET : When DBG_POW_OVRD_RESET=1 this register bit controls
the resets for all domains. 1 = reset. 0 = not reset.RW 0x0
4 DBG_POW_OVRD_RESET : Enables DBG_POW_RESET to control the resets for
the power manager and the switched-core. Essentially that is everythjing
except the Coresight 2-wire interface and the RP_AP registers.RW 0x0
3 DBG_POW_ISO : When DBG_POW_OVRD_ISO=1 this register bit controls the
isolation gates for all domains. 1 = isolated. 0 = not isolated.RW 0x0
2 DBG_POW_OVRD_ISO : Enables DBG_POW_ISO to control the isolation gates
between domains.RW 0x0
1 DBG_POW_OVRD_LARGE_REQ : Turn on the large power switches for all
domains. This should not be done until sufficient time has been allowed for
the small switches to bring the supplies up. Switching the large switches on
too soon risks browning out the always-on domain and corrupting these very
registers.RW 0x0
0 DBG_POW_OVRD_SMALL_REQ : Turn on the small power switches for all
domains. This switches on chain 0 for each domain and switches off chains 2
& 3 and the large power switch chain. This will bring the power up for all
domains without browning out the always-on power domain.RW 0x0
RP_AP : DBG_POW_OUTPUT_TO_GPIO Register
Offset : 0x01c
Description
Send some, or all, bits of DBG_POW_STATE_SWCORE to gpios.
Bit 0 sends bit 0 of DBG_POW_STATE_SWCORE to GPIO 34
Bit 1 sends bit 1 of DBG_POW_STATE_SWCORE to GPIO 35
Bit 2 sends bit 2 of DBG_POW_STATE_SWCORE to GPIO 36
1.+
2.+ Bit 11 sends bit 11 of DBG_POW_STATE_SWCORE to GPIO 45
Table 107.
DBG_POW_OUTPUT_T
O_GPIO RegisterBits Description Type Reset
31:12 Reserved. - -
11:0 ENABLE RW 0x000
RP_AP : IDR Register
Offset : 0xdfc
Table 108. IDR
RegisterBits Description Type Reset
31:0 Standard Coresight ID Register RO -
3.6. Cortex-M33 coprocessors
The Cortex-M33 features a coprocessor port which transfers up to 64 bits per cycle between the processor and certain
closely-coupled hardware. The Cortex-M33’s built-in floating-point unit is an example of such a coprocessor, but
RP2350 adds three device-specific coprocessors to this interface. The following sections document these
coprocessors.
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 100
Before accessing a coprocessor from Secure code, that coprocessor must first be enabled by setting the corresponding
bit in the CPACR. Before accessing from the Non-secure state, the corresponding bits in the NSACR and CPACR_NS
registers must be set.
The RISC-V processors on RP2350 do not have access to the Cortex-M33 coprocessors.
3.6.1. GPIO coprocessor (GPIOC)
Coprocessor port 0 provides low-overhead access from the Cortex-M33 processors to the GPIO registers in the SIO
(Section 3.1.3 ). This enables a single coprocessor instruction to sample all 48 GPIOs, or to set/clear/write any single
GPIO, among other functionality.
Non-secure accesses are filtered according to the GPIO_NSMASK0  and GPIO_NSMASK1  registers in ACCESSCTRL.
GPIOs not granted for Non-secure use will ignore writes from the Non-secure state, and read back as zero when read
from the Non-secure state.
3.6.1.1. OUT mask write instructions
These instructions write to multiple bits in the SIO GPIO_OUT  and GPIO_HI_OUT  registers.
Mnemonic Armv8-M Instruction Operation
gpioc_lo_out_put mcr p0, #0, Rt, c0, c0 sio_hw→gpio_out = Rt;
gpioc_lo_out_xor mcr p0, #1, Rt, c0, c0 sio_hw→gpio_togl = Rt;
gpioc_lo_out_set mcr p0, #2, Rt, c0, c0 sio_hw→gpio_set = Rt;
gpioc_lo_out_clr mcr p0, #3, Rt, c0, c0 sio_hw→gpio_clr = Rt;
gpioc_hi_out_put mcr p0, #0, Rt, c0, c1 sio_hw→gpio_hi_out = Rt;
gpioc_hi_out_xor mcr p0, #1, Rt, c0, c1 sio_hw→gpio_hi_togl = Rt;
gpioc_hi_out_set mcr p0, #2, Rt, c0, c1 sio_hw→gpio_hi_set = Rt;
gpioc_hi_out_clr mcr p0, #3, Rt, c0, c1 sio_hw→gpio_hi_clr = Rt;
gpioc_hilo_out_put mcrr p0, #0, Rt, Rt2, c0 Simultaneously: sio_hw→gpio_out = Rt;  sio_hw→gpio_hi_out = Rt2;
gpioc_hilo_out_xor mcrr p0, #1, Rt, Rt2, c0 Simultaneously: sio_hw→gpio_togl = Rt;  sio_hw→gpio_hi_togl = Rt2;
gpioc_hilo_out_set mcrr p0, #2, Rt, Rt2, c0 Simultaneously: sio_hw→gpio_set = Rt;  sio_hw→gpio_hi_set = Rt2;
gpioc_hilo_out_clr mcrr p0, #3, Rt, Rt2, c0 Simultaneously: sio_hw→gpio_clr = Rt;  sio_hw→gpio_hi_clr = Rt2;
3.6.1.2. OE mask write instructions
These instructions write to multiple bits in the SIO GPIO_OE  and GPIO_HI_OE  registers.
Mnemonic Armv8-M Instruction Operation
gpioc_lo_oe_put mcr p0, #0, Rt, c0, c4 sio_hw→gpio_oe = Rt;
gpioc_lo_oe_xor mcr p0, #1, Rt, c0, c4 sio_hw→gpio_oe_togl = Rt;
gpioc_lo_oe_set mcr p0, #2, Rt, c0, c4 sio_hw→gpio_oe_set = Rt;
gpioc_lo_oe_clr mcr p0, #3, Rt, c0, c4 sio_hw→gpio_oe_clr = Rt;
gpioc_hi_oe_put mcr p0, #0, Rt, c0, c5 sio_hw→gpio_hi_oe = Rt;
gpioc_hi_oe_xor mcr p0, #1, Rt, c0, c5 sio_hw→gpio_hi_oe_togl = Rt;
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 101
Mnemonic Armv8-M Instruction Operation
gpioc_hi_oe_set mcr p0, #2, Rt, c0, c5 sio_hw→gpio_hi_oe_set = Rt;
gpioc_hi_oe_clr mcr p0, #3, Rt, c0, c5 sio_hw→gpio_hi_oe_clr = Rt;
gpioc_hilo_oe_put mcrr p0, #0, Rt, Rt2, c4 Simultaneously: sio_hw→gpio_oe = Rt;  sio_hw→gpio_hi_oe = Rt2;
gpioc_hilo_oe_xor mcrr p0, #1, Rt, Rt2, c4 Simultaneously: sio_hw→gpio_oe_togl = Rt;  sio_hw→gpio_hi_oe_togl =
Rt2;
gpioc_hilo_oe_set mcrr p0, #2, Rt, Rt2, c4 Simultaneously: sio_hw→gpio_oe_set = Rt;  sio_hw→gpio_hi_oe_set =
Rt2;
gpioc_hilo_oe_clr mcrr p0, #3, Rt, Rt2, c4 Simultaneously: sio_hw→gpio_oe_clr = Rt;  sio_hw→gpio_hi_oe_clr =
Rt2;
3.6.1.3. Single-bit write instructions
These instructions write to a single, indexed bit in either the GPIO_OUT  and GPIO_HI_OUT  registers, or the GPIO_OE  and
GPIO_HI_OE  registers.
Mnemonic Armv8-M Instruction Operation
gpioc_bit_out_put mcrr p0, #4, Rt, Rt2, c0 Write a 1-bit value to any output. Equivalent to: if (Rt2 & 1)
gpioc_hilo_out_set(1ull << Rt); else gpioc_hilo_out_clr(1ull << Rt);
gpioc_bit_out_xor mcr p0, #5, Rt, c0, c0 Unconditionally toggle any single output. Equivalent to:
gpioc_hilo_out_xor(1ull << Rt);
gpioc_bit_out_set mcr p0, #6, Rt, c0, c0 Unconditionally set any single output. Equivalent to:
gpioc_hilo_out_set(1ull << Rt);
gpioc_bit_out_clr mcr p0, #7, Rt, c0, c0 Unconditionally clear any single output. Equivalent to:
gpioc_hilo_out_clr(1ull << Rt);
gpioc_bit_out_xor2 mcrr p0, #5, Rt, Rt2, c0 Conditionally toggle any single output. Equivalent to:
gpioc_hilo_out_xor((uint64_t)(Rt2 & 1) << Rt);
gpioc_bit_out_set2 mcrr p0, #6, Rt, Rt2, c0 Conditionally set any single output. Equivalent to:
gpioc_hilo_out_set((uint64_t)(Rt2 & 1) << Rt);
gpioc_bit_out_clr2 mcrr p0, #7, Rt, Rt2, c0 Conditionally clear any single output. Equivalent to:
gpioc_hilo_out_clr((uint64_t)(Rt2 & 1) << Rt);
gpioc_bit_oe_put mcrr p0, #4, Rt, Rt2, c4 Write a 1-bit value to any output enable. Equivalent to: if (Rt2 & 1)
gpioc_hilo_oe_set(1ull << Rt); else gpioc_hilo_oe_clr(1ull << Rt);
gpioc_bit_oe_xor mcr p0, #5, Rt, c0, c4 Unconditionally toggle any output enable. Equivalent to:
gpioc_hilo_oe_xor(1ull << Rt);
gpioc_bit_oe_set mcr p0, #6, Rt, c0, c4 Unconditionally set any output enable (set to output). Equivalent to:
gpioc_hilo_oe_set(1ull << Rt);
gpioc_bit_oe_clr mcr p0, #7, Rt, c0, c4 Unconditionally clear any output enable (set to input). Equivalent to:
gpioc_hilo_oe_clr(1ull << Rt);
gpioc_bit_oe_xor2 mcrr p0, #5, Rt, Rt2, c4 Conditionally toggle any output enable. Equivalent to:
gpioc_hilo_oe_xor((uint64_t)(Rt2 & 1) << Rt);
gpioc_bit_oe_set2 mcrr p0, #6, Rt, Rt2, c4 Conditionally set any output enable (set to output). Equivalent to:
gpioc_hilo_oe_set((uint64_t)(Rt2 & 1) << Rt);
gpioc_bit_oe_clr2 mcrr p0, #7, Rt, Rt2, c4 Conditionally clear any output enable (set to input). Equivalent to:
gpioc_hilo_oe_clr((uint64_t)(Rt2 & 1) << Rt);
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 102
3.6.1.4. Indexed mask write instructions
These instructions write to a single, dynamically selected 32-bit GPIO register.
Mnemonic Armv8-M Instruction Operation
gpioc_index_out_put mcrr p0, #8, Rt, Rt2, c0 Write Rt to a GPIO output register selected by Rt2.
gpioc_index_out_xor mcrr p0, #9, Rt, Rt2, c0 Toggle bits Rt in a GPIO output register selected by Rt2.
gpioc_index_out_set mcrr p0, #10, Rt, Rt2, c0 Set bits Rt in a GPIO output register selected by Rt2.
gpioc_index_out_clr mcrr p0, #11, Rt, Rt2, c0 Clear bits Rt in a GPIO output register selected by Rt2.
gpioc_index_oe_put mcrr p0, #8, Rt, Rt2, c4 Write Rt to a GPIO output enable register selected by Rt2
gpioc_index_oe_xor mcrr p0, #9, Rt, Rt2, c4 Toggle bits Rt in a GPIO output enable register selected by Rt2.
gpioc_index_oe_set mcrr p0, #10, Rt, Rt2, c4 Set bits Rt in a GPIO output enable register selected by Rt2 (i.e. set
to output).
gpioc_index_oe_clr mcrr p0, #11, Rt, Rt2, c4 Clear bits Rt in a GPIO output enable register selected by Rt2 (i.e. set
to input).
3.6.1.5. Read instructions
These instructions read from either the GPIO_OUT  and GPIO_HI_OUT  registers; the GPIO_OE  and GPIO_HI_OE  registers;
or the GPIO_IN  and GPIO_HI_IN  registers.
Mnemonic Armv8-M Instruction Operation
gpioc_lo_out_get mrc p0, #0, Rt, c0, c0 Read back the lower 32-bit output register. Equivalent to: Rt =
sio_hw→gpio_out;
gpioc_hi_out_get mrc p0, #0, Rt, c0, c1 Read back the upper 32-bit output register. Equivalent to: Rt =
sio_hw→gpio_hi_out;
gpioc_hilo_out_get mrrc p0, #0, Rt, Rt2, c0 Read back two 32-bit output registers in a single operation.
Equivalent to: Rt = sio_hw→gpio_out;  and simultaneously Rt2 =
sio_hw→gpio_hi_out << 32);
gpioc_lo_oe_get mrc p0, #0, Rt, c0, c4 Read back the lower 32-bit output enable register. Equivalent to: Rt
= sio_hw→gpio_oe;
gpioc_hi_oe_get mrc p0, #0, Rt, c0, c5 Read back the upper 32-bit output enable register. Equivalent to: Rt
= sio_hw→gpio_hi_oe;
gpioc_hilo_oe_get mrrc p0, #0, Rt, Rt2, c4 Read back two 32-bit output enable registers in a single operation.
Equivalent to: Rt = sio_hw→gpio_oe;  and simultaneously Rt2 =
sio_hw→gpio_hi_oe << 32);
gpioc_lo_in_get mrc p0, #0, Rt, c0, c8 Sample the lower 32 GPIOs. Equivalent to: Rt = sio_hw→gpio_in;
gpioc_hi_in_get mrc p0, #0, Rt, c0, c9 Sample the upper 32 GPIOs. Equivalent to: Rt = sio_hw→gpio_hi_in;
gpioc_hilo_in_get mrrc p0, #0, Rt, Rt2, c8 Sample 64 GPIOs on the same cycle. Equivalent to: Rt =
sio_hw→gpio_in;  and simultaneously Rt2 = sio_hw→gpio_hi_in << 32);
3.6.1.6. Interpreting instruction fields
The type of coprocessor instruction —  mrc, mrrc, mcr and mcrr — specifies the direction of the transfer (read/write) and the
number of Arm registers being transferred (one or two).
Bits 3:2 of the first coprocessor register number field, CRm, identify the group of registers being accessed. Values 0, 1 and
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 103
2 refer to the output, output enable and input registers respectively.
Bit 0 of the first coprocessor register number field, CRm, may be used to distinguish which register in a group is being
accessed. Bit 1 is reserved to allow more registers to be indexed on future chips with more GPIOs.
For writes, bits 1:0 of the instruction’s opc1 field specify the type of write operation: values 0, 1, 2, 3 map to normal write,
XOR, set and clear operations respectively. Bits 3:2 of the opc1 field are used to indicate the addressing mode for the
register or individual bit being accessed. Their exact interpretation depends on the instruction.
Any combinations not listed in the preceding tables are reserved for future use.
3.6.2. Double-precision coprocessor (DCP)
Each Cortex-M33 CPU core is equipped with two instances of a double-precision coprocessor that provides acceleration
of double-precision floating point operations including add, subtract, multiply, divide and square root. The design is
implemented in just a few thousand gates and so occupies much less silicon die area than a full double-precision
floating-point unit.
Nevertheless, these coprocessors considerably speed up basic double-precision operations compared to pure software
implementations. The coprocessors also offer support for some single-precision operations and conversions.
The two coprocessor instances are assigned to the Secure and Non-secure domains. Coprocessor number 4 always
maps to the coprocessor used for the current processor security state. Coprocessor number 5 always maps to the Non-
secure coprocessor instance, but is accessible only from Secure code. This duplication avoids saving and restoring the
coprocessor context during Secure/Non-secure state transitions.
3.6.2.1. CPU interface
As with the other coprocessors, the accelerator connects to the CPU over a 64-bit bus. Two words of data can be
transferred per cycle over that bus using the following instructions:
•MCRR: move two integer registers to coprocessor
•MRRC: move two integer registers from coprocessor
There are also single-register versions of these instructions, including ones that allow the CPU’s flags to be loaded from
the coprocessor. The CPU issues CDP instructions to trigger operations within the coprocessor without transferring any
data.
3.6.2.2. Internal architecture
A block diagram of the accelerator is shown in Figure 12 .
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 104
Figure 12. Block
diagram of double-
precision accelerator
At the heart of the design are:
•two sets of registers, each designed to hold an unpacked double-precision value
•a 9-bit status register
Unlike a conventional FPU, the accelerator does not contain a full register bank. Not only does this save die area, it also
means that saving and restoring the coprocessor’s state is very fast: in fact, the entire state fits within six 32-bit words
and hence can be saved to, or restored from, the CPU in three instructions.
The accelerator contains a wide adder, capable of adding two mantissa values and three exponent values
simultaneously. There is also a shifter that can either perform a logical right shift by a given amount, or normalise a
denormalised mantissa and report the amount of shift required to do so. A considerable amount of hardware in the
shifter is shared between these two operating modes.
Control logic, shown at the top of the diagram, decodes coprocessor instructions and configures the accelerator’s
functional units and datapath multiplexers in order to execute the desired operation. Each coprocessor instruction takes
a single cycle, so coprocessor operations cannot stall the CPU.
A floating-point operation such as addition or subtraction is carried out by executing a fixed (or 'canned') sequence of
instructions as follows:
1.One or two MCRR instructions to write the operands to the coprocessor.
2.A number of CDP (and possibly other) instructions that together perform the operation itself.
3.An MRRC or MRC instruction to read back the result.
The hardware handles special cases involving zeroes, NaNs, and infinities, as well as rounding, underflow and overflow.
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 105
The accelerator does not contain a multiplier array, as that would occupy a considerable amount of die area. Instead,
the mantissas of the operands of a multiplication operation are brought back into the CPU to take advantage of the fast
long multiply instructions available there. The coprocessor handles the processing of exponents.
Division and square root operations also involve data moving back and forth between coprocessor and CPU. To assist
with these operations, the coprocessor contains two small lookup tables (implemented as random logic) that provide
initial approximations used in the divide and square root algorithms. The coprocessor handles the processing of
exponents.
The accelerator is only meant to be used with the canned instruction sequences that implement basic floating-point
operations. The state of the accelerator is not guaranteed to be preserved from the end of one canned sequence to the
beginning of the next: see the discussion of the 'engaged' flag in the status register below.
3.6.2.3. Registers
X and Y mantissa registers
The X and Y mantissa registers ( xm and ym) are each 64 bits wide. They can be read and written directly by the CPU;
the xm register can also store the lower part of the result from the adder. When a value is written to the coprocessor
using a 'write unpacked' MCRR instruction, the top two bits of the mantissa register are set to 01 and the next most
significant bits are filled from the mantissa field of the floating-point operand. The low-order bits of the mantissa
register are cleared.
X and Y exponent registers
The X and Y exponent registers ( xe and ye) are each 14 bits wide. They can be read and written directly by the CPU;
the xe register can also store the higher part of the result from the adder. When a value is written to the coprocessor
using a 'write unpacked' MCRR instruction, the exponent register is set from the exponent field of the floating-point
operand.
X and Y flag registers
The X and Y flag registers ( xf and yf) are each four bits wide. They can be read and written directly by the CPU. The
flag register stores information about the type of floating-point number represented in the corresponding mantissa
and exponent registers: its sign, whether it is a zero, whether it is an infinity, and whether it is a NaN. When a value
is written to the coprocessor using a 'write unpacked' MCRR instruction, the bits of the flag register are updated
according to the type of the floating-point operand.
Status register
The status register contains nine bits. It can be read and written directly by the CPU. The least significant six bits of
the register store the shift required to align the two operands of an addition or subtraction; the next two bits
indicate whether the value represented by (xe, xm)  is greater than, equal to, or less than the value represented by
(ye, ym)  - in other words, whether the magnitude of the value stored in the X registers is greater than, equal to, or
less than the magnitude of the value stored in the Y registers. These status bits are set in the first step of an
addition, subtraction or comparison operation after the operands have been loaded.
The final bit of the status register indicates whether the coprocessor is 'engaged'. The engaged flag is set by all
coprocessor instructions that occur at the beginning or in the middle of the canned instruction sequences. It is cleared
by those instructions used at the end of a canned sequence to read back a final result.
3.6.2.4. State save and restore
An interrupt handler can test the engaged flag to determine whether it has pre-empted an in-progress operation on the
same coprocessor. If the engaged flag is set, the handler can save (and restore) the coprocessor state before using the
coprocessor. If the engaged flag is clear, the save (and restore) step can be skipped. If this approach is implemented,
the state of the accelerator must be regarded as undefined when not within one of the canned instruction sequences.
Three MRRC instructions are provided to copy the six words of state in the coprocessor into integer registers in the CPU,
from where they can, for example, be pushed onto the stack. The last of these instructions clears the engaged flag.
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 106
Similarly, three MCRR instructions are provided to restore the state of the coprocessor from integer registers, including the
state of the engaged flag.
3.6.2.5. Instruction summary
As mentioned above, it is intended that the coprocessor instructions are only used as part of canned sequences.
Nevertheless, for completeness, a list of the available instructions is given here with an outline of their effects.
MCRR instructions are shown in Table 109 .
Table 109. MCRR
instructionsMnemonic Effect Used by
WXMD write xm direct restore status
WYMD write ym direct restore status
WEFD write xe,xf,ye,yf,other status direct restore status
WXUP write xm,xe,xf unpacked double-precision double-precision binary
operations
WYUP write ym,ye,yf unpacked double-precision double-precision binary
operations
WXYU write xm,xe,xf,ym,ye,yf two unpacked single-precision single-precision binary
operations
WXMS write xm bit 0=0/1 if data zero/nonzero dmul
WXMO write xm direct OR into b0, add exponents, XOR signs dmul
WXDD write xm direct; subtract exponents, XOR signs ddiv
WXDQ write xm direct, offset exponent dsqrt
WXUC write X unsigned int+252+232, Y=252+232conversions from
unsigned int
WXIC write X signed int+252+232, Y=252+232conversions from signed
int
WXDC write X unpacked double-precision, Y=252+232conversions from double-
precision
WXFC write X unpacked single-precision, Y=252+232conversions from single-
precision
WXFM write xm direct, add exponents, XOR signs fmul
WXFD write xm direct, subtract exponents, XOR signs fdiv
WXFQ write xm direct, offset exponent fsqrt
CDP instructions are shown in Table 110 .
Table 110. CDP
instructionsMnemonic Effect Used by
INIT zero all registers
ADD0 compare X-Y, set status add, sub, cmp
ADD1 xm:=±xm+±ym>>s or ± ym+±xm>>s add
SUB1 xm:=±xm–±ym>>s or –± ym±xm>>s sub
SQR0 xe=xe/2, xm=xm<<0:1 sqrt
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 107
Mnemonic Effect Used by
NORM normalise
NRDF normalise and round single-precision single-precision
operations, conversions
to single-precision
NRDD normalise and round double-precision double-precision
operations, conversions
to double-precision
NTDC normalise and truncate double-precision pre-integer conversion truncating conversions to
int
NRDC normalise and round double-precision pre-integer conversion rounding conversions to
int
MRRC and MRC instructions are shown in Table 111 .
Table 111. MRRC and
MRC instructionsMnemonic Effect Used by
RXVD read xf,VERSION direct dclassify, check version
RCMP read processed status dcmp
RDFA read FADD result packed from X fadd
RDFS read FSUB result packed from X fsub
RDFM read FMUL result packed from X fmul
RDFD read FDIV result packed from X fdiv
RDFQ read FSQRT result packed from X fsqrt
RDFG read general float result packed from X double-precision to
single-precision
conversion
RDUC read unsigned integer conversion result from X conversions to unsigned
int
RDIC read signed integer conversion result from X conversions to signed int
RXMD read xm direct save status
RYMD read ym direct, engaged=0 save status
REFD read xe,xf,ye,yf,other status direct save status
RXMS read xm Q62-s dmul, ddiv, dsqrt
RYMS read ym Q62-s dmul, ddiv
RXYH read ym hi, xm hi fmul, fdiv
RYMR read ym hi, recip approximation lo fdiv, ddiv
RXMQ read xm hi, rsqrt approximation lo fsqrt, dsqrt
RDDA read DADD result packed from X dadd
RDDS read DSUB result packed from X dsub
RDDM read DMUL result packed from X dmul
RDDD read DDIV result packed from X ddiv
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 108
Mnemonic Effect Used by
RDDQ read DSQRT result packed from X dsqrt
RDDG read general double result packed from X single-precision to
double-precision
conversion
Alongside each MRRC and MRC instruction is a variant starting P (for 'peek') instead of R that has the same function but
preserves the engaged flag. RXMD is identical to PXMD; REFD is identical to PEFD.
The SDK includes macros to generate Arm assembler from the mnemonics above in the file dcp_instr.inc.S  in the SDK ,
for example turning WXUP r0,r1  into mcrr p4,#1,r0,r1,c0 .
3.6.2.6. Example canned sequence
The assembly code sequence to implement a callable double-precision addition operation is shown in Table 112 .
Table 112. Assembly
code sequence to
implement a callable
double-precision
addition operationArm assembler Coprocessor mnemonic Action
mcrr p4,#1,r0,r1,c0 WXUP r0,r1 write R0 and R1 unpacked double-precision into X
mcrr p4,#1,r2,r3,c1 WYUP r2,r3 write R2 and R3 unpacked double-precision into Y
cdp p4,#0,c0,c0,c1,#0 ADD0 compare X and Y; set status and alignment shift
cdp p4,#1,c0,c0,c1,#0 ADD1 add/subtract (depending on status and signs) xm and ym
aligned, write result to xm
cdp p4,#8,c0,c0,c0,#1 NRDD normalise and round double-precision result
mrrc p4,#1,r0,r1,c0 RDDA r0,r1 read R0 and R1 packed double-precision from X, including
special-value processing for addition
bx r14 return from function
Logic in the coprocessor ensures, for example, that the ADD1 instruction shifts the smaller argument, that xm and ym are
negated as required before being sent to the adder, and that the larger exponent is used as the basis for the subsequent
normalisation.
3.6.2.7. Using the coprocessor via the SDK library
The SDK pico_double  library automatically uses the coprocessor for double-precision floating-point calculations. This is
the simplest way to take advantage of the coprocessor, but it entails a few cycles of overhead for each operation. Not
only is there the overhead involved in a function call and return, but for safety the general-purpose implementations in
the SDK always test the engaged flag, saving and restoring the coprocessor state to and from the stack as needed. That
ensures that the functions work correctly if used in interrupt handlers, without additional intervention.
3.6.2.8. Using the coprocessor directly
The SDK includes macros to generate canned sequences for standard operations in the file dcp_canned.inc.S  in the SDK .
These allow the callable double-precision addition operation listed above, for example, to be written as:
dcp_dadd_m r0,r1, r0,r1,r2,r3  @ result in r0,r1; operands in r0,r1 and r2,r3
bx r14
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 109
dcp_dadd_m  is a macro which expands into the sequence of coprocessor instructions given above. This macro allows you
to specify the integer registers to be used for the operands and the result, which means that using these macros directly
not only avoids function call and return overhead, it also avoids the extra overhead associated with argument
marshalling.
The more complex macros also require you to specify 'scratch' registers that they can use for storing intermediate
results. The following function, which calculates the dot product of two three-element vectors of doubles pointed to by
R0 and R1, illustrates this:
push {r4-r9,r14}
ldrd r3,r4,[r0],#8                                     @ load x ₀
ldrd r5,r6,[r1],#8                                     @ load y ₀
dcp_dmul_m r7,r8, r3,r4,r5,r6, r3,r4,r5,r6,r12,r14,r9  @ compute x ₀y₀ ①
ldrd r3,r4,[r0],#8                                     @ load x ₁
ldrd r5,r6,[r1],#8                                     @ load y ₁
dcp_dmul_m r3,r4, r3,r4,r5,r6, r3,r4,r5,r6,r12,r14,r9  @ compute x ₁y₁ ①
dcp_dadd_m r7,r8, r3,r4,r7,r8                          @ compute x ₀y₀+x₁y₁
ldrd r3,r4,[r0],#8                                     @ load x ₂
ldrd r5,r6,[r1],#8                                     @ load y ₂
dcp_dmul_m r3,r4, r3,r4,r5,r6, r3,r4,r5,r6,r12,r14,r9  @ compute x ₂y₂ ①
dcp_dadd_m r0,r1, r3,r4,r7,r8                          @ compute x ₀y₀+x₁y₁+x₂y₂ ②
pop {r4-r9,r15}
1.r3, r4, r5, r6, r12, r14, and r9 are scratch registers.
2.stores the result in r0, r1.
NOTE
This example does not check the engaged flag. If used in interrupt handlers or in multi-threaded applications, a
suitable test would have to be added. For example, see the SDK implementation of __aeabi_dadd  for an efficient way
to do this. The test only needs to be performed once, at the beginning of the function, so the overhead in this case
would be relatively small.
The following example demonstrates how to use the coprocessor:
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/dcp/hello_dcp/hello_dcp.c  Lines 18 - 109
 18 extern double dcp_dot                          (double*p,double*q,int n);
 19 extern double dcp_dotx                          (float*p,float*q,int n);
 20 extern float  dcp_iirx                          (float x,float*temp,float*coeff,int order);
 21 extern void   dcp_butterfly_radix2              (double*x,double*y);
 22 extern void   dcp_butterfly_radix2_twiddle_dif  (double*x,double*y,double*tf);
 23 extern void   dcp_butterfly_radix2_twiddle_dit  (double*x,double*y,double*tf);
 24 extern void   dcp_butterfly_radix4              (double*w,double*x,double*y,double*z);
 25 
 26 static void dcp_test0 () {
 27     double u[3]={1,2,3};
 28     double v[3]={4,5,6};
 29     double w;
 30     w=dcp_dot(u,v,3);
 31     printf("(1,2,3).(4,5,6)=%g \n",w);
 32 }
 33 
 34 static void dcp_test1 () {
 35     float u[3]={1+pow(2,-20),2,3};
 36     float v[3]={1-pow(2,-20),5,6};
 37     double w;
 38     w=dcp_dotx (u,v,3);
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 110
 39     printf("(1+pow(2,-20),2,3).(1-pow(2,-20),5,6)=%.17g \n",w);
 40 }
 41 
 42 static void dcp_test2 () {
 43   int t;
 44   float w;
 45 // filter coefficients calculated using Octave as follows:
 46 // octave> pkg load signal
 47 // octave> format long
 48 // octave> [b,a]=cheby1(2,1,.5)
 49 // b = 0.307043201259064   0.614086402518128   0.307043201259064
 50 // a = 1.000000000000000e+00   6.406405700380895e-02   3.139684953186774e-01
 51 // and tested as follows:
 52 // octave> filter(b,a,[1 zeros(1,19)])
 53     float coeff[5]={0.3070432,0.3139685,0.6140864,0.06406406 ,0.3070432};
 54     float temp[4]={0};
 55     printf("IIR filter impulse response: \n");
 56     for(t=0;t<20;t++) {
 57         w=dcp_iirx (t?0:1,temp,coeff,2);
 58         printf("y[%2d]=%g \n",t,w);
 59     }
 60 }
 61 
 62 static void dcp_test3 () {
 63     double x[2]={2,3};
 64     double y[2]={5,7};
 65     dcp_butterfly_radix2 (x,y);
 66     printf("Radix-2 butterfly of (2+3j,5+7j)=(%g%+gj,%g%+gj) \n",x[0],x[1],y[0],y[1]);
 67 }
 68 
 69 static void dcp_test4 () {
 70     double x[2]={2,3};
 71     double y[2]={5,7};
 72     double t[2]={1.5,2.5};
 73     dcp_butterfly_radix2_twiddle_dif (x,y,t);
 74     printf("Radix-2 DIF butterfly of (2+3j,5+7j) with twiddle factor
    (1.5+2.5j)=(%g%+gj,%g%+gj) \n",x[0],x[1],y[0],y[1]);
 75 }
 76 
 77 static void dcp_test5 () {
 78     double x[2]={2,3};
 79     double y[2]={5,7};
 80     double t[2]={1.5,2.5};
 81     dcp_butterfly_radix2_twiddle_dit (x,y,t);
 82     printf("Radix-2 DIT butterfly of (2+3j,5+7j) with twiddle factor
    (1.5+2.5j)=(%g%+gj,%g%+gj) \n",x[0],x[1],y[0],y[1]);
 83 }
 84 
 85 static void dcp_test6 () {
 86     double w[2]={2,3};
 87     double x[2]={5,7};
 88     double y[2]={11,17};
 89     double z[2]={41,43};
 90     dcp_butterfly_radix4 (w,x,y,z);
 91     printf("Radix-4 butterfly of (2+3j,5+7j,11+17j,41+43j)=(%g%+gj,%g%+gj,%g%+gj,%g%+gj) \n"
    ,w[0],w[1],x[0],x[1],y[0],y[1],z[0],z[1]);
 92 }
 93 
 94 int main() {
 95     stdio_init_all ();
 96 
 97     printf("Hello, DCP! \n");
 98 
 99     dcp_test0 ();
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 111
100     dcp_test1 ();
101     dcp_test2 ();
102     dcp_test3 ();
103     dcp_test4 ();
104     dcp_test5 ();
105     dcp_test6 ();
106 
107     return 0;
108 }
There are also further examples in the dcp/ directory in the Pico Examples  repository.
3.6.2.9. IEEE 754 compliance
The canned instruction sequences provide IEEE-compliant operations with the exception that denormals are flushed to
zero on input and output. Zeroes, NaNs and infinities are correctly handled. Rounding is to nearest, even on tie.
Faster versions of division and square root operations, named ddiv_fast  and dsqrt_fast  respectively, are available. These
do not always give correctly rounded results but do have a guaranteed error before rounding of less than 0.5ulp ('units in
last place'), which in particular means that if there is an exact representation of the result then that is what is returned.
3.6.2.10. Benchmarks
Table 113  gives cycle counts for various floating-point operations using the accelerator with inlined code, compared to
some typical ranges of benchmarks for (a) fully-fledged hardware double-precision FPUs; and (b) pure software
implementations.
Table 113. Cycle
counts for floating-
point operations using
the acceleratorOperation Using
coprocessorFull hardware (latency) Software only
dadd 6 2-6 70-90
dsub 6 2-6 70-90
dmul 17 3-7 75-90
ddiv 51 13-60 135-600
ddiv_fast 32
dsqrt 49 15-62 130-650
dsqrt_fast 38
dcmp 4
dclassify 2
integer to/from double 5
3.6.3. Redundancy coprocessor (RCP)
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 112
Control Signals
TagCanary GenerationComparison
Decode ErrorSalt Register
Fault Flag
Sequence Counter+1Instruction DecodeCPOPC CPRDATA[31:0]CPWDATA[63:0]Opcode Phase Data PhaseFigure 13. The
redundancy
coprocessor
implements hardware-
checked assertions, to
aid control flow and
data flow integrity
checking. Its two-
phase pipeline is
closely coupled to the
Cortex-M33 pipeline. A
64-bit salt register
holds a once-per-boot
random number, which
is used to generate
and validate stack
canary values and
generate
pseudorandom delay
sequences on RCP
instructions. Other
comparison functions
provide more general
hardware-checked
assertion support.
The redundancy coprocessor (RCP) is used in the RP2350 bootrom to provide hardware-assisted mitigation against
fault injection and return-oriented programming attacks. This includes the following instructions:
•generate and validate stack canary values based on a per-boot random seed
•assert that certain points in the program are executed in the correct order without missing steps
•validate booleans stored as one of two valid bit patterns in a 32-bit word
•validate 32-bit integers stored redundantly in two words with an XOR parity mask
•halt the processor upon reaching a software-detected panic condition
Section 3.6.3.7  lists the RCP instruction set in full. RCP instruction encodings contain a parity bit; executing an invalid
instruction or an instruction with bad parity triggers an RCP fault.
Each Cortex-M33 processor is equipped with a single RCP instance, mapped as coprocessor number 7 in the
coprocessor opcode space. The two RCP instances are linked: an RCP fault on one core immediately triggers a fault on
the other. RCP faults have two steps:
1.The non-maskable interrupt (NMI) is asserted. It remains asserted until a warm reset of the processor.
2.Any further RCP instructions stall the coprocessor port until a warm reset of the processor. This stall cannot be
interrupted, as the processor is already in the NMI state.
The RP2350 bootrom implements the NMI and HardFault vectors with an rcp_panic  instruction. This instruction
unconditionally stalls the coprocessor port. This prevents the processor from retiring any more instructions until either
a debugger connects to reset the processors, or the processors reset through some other mechanism (such as the
system watchdog timer). The processor quickly reaches a quiescent state that reduces vulnerability to further fault
injection (deliberate or otherwise).
Each core’s RCP has a 64-bit seed value ( Section 3.6.3.1 ). The RCP uses this value to generate stack canary values and
to add short pseudorandom delays to RCP instructions. Both RCP instances are seeded by core 0 during the early boot
path in the bootrom using the system true-random number generator ( Section 12.12 ). Running any RCP instruction
before providing a salt value triggers an RCP fault. The use of random data in stack canary values makes it difficult to
reuse return-oriented-programming stack payloads across multiple boots.
Figure 13  gives a dataflow-level overview of the RCP hardware. The RCP is structured as a two-phase pipeline which
overlays the Cortex-M33 execution pipeline. It exchanges data with the core via a 64-bit incoming bus (CPWDATA) and
a 32-bit outgoing bus (CPRDATA). The Cortex-M33 can issue two register reads to the coprocessor in one cycle through
the CPWDATA bus. The RCP leverages this throughput for some of its assertion instructions, such as rcp_iequal , which
raises a fault when two Arm registers do not contain the same 32-bit value.
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 113
The 8-bit tag value in Figure 13  is an 8-bit instruction immediate value encoded by the instruction CRn and CRm fields.
These 8-bit values are used to uniquely identify functions for canary value generation so that stack frames are not
interchangeable between functions. They also provide 8-bit counter values for rcp_count_set  and rcp_count_check 
instructions. Encoding the tags using the CRn and CRm fields makes RCP instruction sequences more compact, as it
obviates additional instructions to materialise these small constants in registers and pass them through CPWDATA.
This also makes the tag values less vulnerable to glitching, because the instruction opcode fields are available earlier in
the cycle than the register values passed on CPWDATA.
RCP instructions may also execute in the Non-secure state, with certain differences to prevent Non-secure code from
triggering RCP faults or observing the value of the salt register. This supports Non-secure software executing shared
ROM routines which contain RCP instructions, but does not allow probing of the RCP’s internal state from a Non-secure
context. Section 3.6.3.2  gives further details and rationale for Non-secure execution support.
Certain details are elided from Figure 13  for clarity, such as the delay counter used for pseudorandom instruction
delays, and the logic for suppressing faults under Non-secure execution. This behaviour is described in full in the
following sections.
3.6.3.1. Salt register
Each RCP instance is provisioned with a 64-bit salt register , which provides a seed for stack canary values and random
instruction delays. This is expected to be initialised with a random value early in the boot process: the RP2350 bootrom
uses the true random number generator to generate the salt values.
Initially the salt register is in the invalid  state. This state only allows the following operations:
•Checking the valid state of the salt register, via rcp_canary_status
•Writing a salt via rcp_salt_core0  or rcp_salt_core1 , which writes a 64-bit value to that core’s salt register, and
changes its state to valid
When the salt register is in the invalid state, executing any RCP instruction other than those listed above unconditionally
triggers an RCP fault . This makes it difficult to skip RCP initialisation via fault injection, because the RP2350 bootrom
contains a high density of RCP instructions.
Similarly, attempting to write to an already-valid RCP salt register triggers an RCP fault. There is no reason to initialise
the RCP salt register twice, so this case is detected as an anomaly that indicates loss of control flow integrity.
Core 0’s coprocessor port writes the salt registers for both cores' RCP instances to simplify multicore interactions
during early boot. In the RP2350 bootrom, core 1’s first steps lock down its MPU execute permissions to a small region
of the ROM containing its wait-for-launch code, and then poll for its RCP salt to become valid once core 0 has cleared
boot memory, performed some minimal hardware setup, and generated the RCP salts.
When core 0 is switched to RISC-V architecture and core 1 is Arm, the core 1 salt register is forcibly marked as valid to
permit core 1 to execute the ROM. This has no impact on secure boot because RISC-V cores are only enabled when
secure boot is disabled; the ability to set core 0 to RISC-V already implies subversion of secure boot.
3.6.3.2. Access from Non-secure
Setting bit 7 of the Cortex-M33 NSACR register permits Non-secure code to set bit 7 of CPACR_NS , which in turn enables Non-
secure access to the RCP. Non-secure RCP access is useful for executing shared Secure/Non-secure routines which
contain RCP instructions. For example, the memcpy implementation in the RP2350 bootrom is shared by Secure code in
the main boot path, and Non-secure code such as the USB bootloader.
Since an RCP fault is fatal for all software running on the system, Non-secure must not be able to trigger RCP faults at
will. Similarly, if Non-secure code were able to read out the RCP salt register, it would make it easier to engineer stack
payloads which can control Secure execution without triggering RCP faults. Therefore the RCP handles Non-secure
accesses differently from Secure:
•Masks read data to all-zeroes
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 114
•Ignores write data: any instruction which would generate a data-dependent RCP fault becomes a no-op
•Reports coprocessor errors instead of RCP faults for invalid instructions, which the processor maps to the Non-
secure UNDEFINSTR UsageFault
•Skips the pseudorandom instruction delay: all RCP instructions execute in one cycle, assuming the Cortex-M33 is
able to issue them at one instruction per cycle
The lack of pseudorandom instruction delays makes it more difficult for Non-secure code to extract the seed value used
to add delays to Secure execution of RCP instructions.
3.6.3.3. Instruction validation
The RCP applies the following rules to all coprocessor instructions which target coprocessor 7:
•The number of 1 bits in the Opc1 field, plus the instruction parity bit, must be an even number.
◦For mcr, mrc and cdp instructions, bit 0 of the Opc2 field encodes the parity bit.
◦For mcrr, bit 3 of the CRm field encodes the parity bit.
•The instruction must not be an mrrc (64-bit coprocessor-to-core)
•For mcr instructions (32-bit core-to-coprocessor):
◦The Opc1 field must be in the range 0 through 6.
◦If there is no 8-bit tag (i.e. any other than rcp_canary_check , rcp_count_check , rcp_count_set ), the CRn and CRm
opcode fields must be all-zeroes.
•For mrc instructions (32-bit coprocessor-to-core):
◦The Opc1 field must be in the range 0 through 2.
◦For instructions other than rcp_canary_get  and rcp_canary_check , the CRn and CRm opcode fields must be all-
zeroes.
•For mcrr instructions (64-bit core-to-coprocessor):
◦The Opc1 field must be in the range 0 through 8.
◦For rcp_salt_core*  instructions, bits 2:0 of the CRm field must be 0 or 1 (referred to as rcp_salt_core0  and
rcp_salt_core1  respectively).
◦For all other mcrr instructions, bits 2:0 of the CRm field must be 0.
The terms Opc1, Opc2, CRm and CRn in the description above refer to standard encoding fields in the Arm T32 instruction
encoding for coprocessor instructions. See the Armv8-M Architecture Reference Manual  for full details of the encoding
and assembler syntax.
Any coprocessor instruction targeting coprocessor 7 that fails these validation rules will result in one of two outcomes,
depending on the security domain in which the instruction is executed:
•Secure execution of an invalid instruction is an immediate, unconditional RCP fault. The RCP asserts the core’s
non-maskable interrupt signal, and any further RCP instructions stall the coprocessor port indefinitely. This
continues until the core receives a warm reset. This also triggers RCP faults on other cores: for more information,
see Section 3.6.3.4 .
•Non-secure execution of an invalid instruction returns an error on the opcode-phase coprocessor interface, which
is interpreted as a Non-secure UNDEFINSTR UsageFault by the core. For a full description of this Armv8-M-specific
fault, see the Armv8-M Architecture Reference Manual .
3.6.3.4. Cross-core triggering
An RCP fault indicates that the integrity of the software environment is compromised. Though the fault may originate on
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 115
a single processor, all processors which share the same trusted memory may behave unpredictably if they continue to
execute, since:
•The physical condition which caused one processor to misexecute in a detectable way, such as low supply voltage,
may cause other processors to misexecute in a manner which was not detected.
•The processor which triggered an RCP fault may already have corrupted shared, trusted memory contents in a way
that interferes with the other processor’s operation, (e.g. corrupting the other core’s stack).
Therefore, an RCP fault on one core also triggers an RCP fault on other cores. Because RP2350 has two cores, an RCP
fault on core 0 always triggers a fault on core 1, and an RCP fault on core 1 always triggers a fault on core 0.
Core 0 
TriggerCore 0 
NMI Core 0 
FaultD Q
Core 1 
NMI Core 1 
TriggerCore 1 
FaultD QFigure 14. Triggering
an RCP fault on one
core also triggers a
fault on the other
core. Triggers
accumulate into a
fault register, which
remains set until the
core resets. The NMI
asserts when the fault
register is set.
Each core locally ORs in the trigger signal from the other core. The outputs of the two OR gates on the left are logically
equivalent, but the gates are kept local to the core to minimise delay routing the core’s own fault trigger to its own fault
register.
3.6.3.5. Stack canary values
Canaries are values written to the stack on function entry and validated on function exit, to assure that:
•The exit matches the entry (i.e. when leaving through the back door, you entered through the front door)
•The stack was not completely overwritten in the course of executing the function
This helps to mitigate two classes of attack:
•Fault injection: any physical fault condition which corrupts the program counter or causes a wild indirect branch is
likely to cause the processor to execute a function epilogue which does not match the prologue. Any branch into
the middle of a function is likely to eventually reach the epilogue.
•Return-oriented programming: deliberate stack corruption can redirect control flow through a sequence of function
tails which perform arbitrary operations. The stack may be corrupted by exploiting missing bounds checks on
stack buffer operations. Random canary values make it difficult to craft such a stack payload.
Return-oriented programming mitigation is particularly important to account for in the bootrom because the bootrom
exposes an API surface that is mapped at a known location at runtime (it is physically always mapped at 0x00000000 ).
This provides a well-known exploit surface similar to the C standard library.
The RCP supports canary values with two canary-specific instructions:
•rcp_canary_get  generates a 32-bit value for an 8-bit tag as a function of the salt register
•rcp_canary_check  validates a 32-bit value for an 8-bit tag and raises an RCP fault if the value does not match that
produced by an rcp_canary_get  for the same tag.
The 32-bit canary value is as follows:
•Bits 7:0: all-zero
•Bits 15:8: XOR of bits 7:0 of the salt with (AND of bits 31:24 of the salt with the 8-bit tag)
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 116
•Bits 23:16: XOR of bits 15:8 of the salt with (AND of bits 39:32 of the salt with the bitwise NOT of the 8-bit tag)
•Bits 31:24: XOR of bits 23:16 of the salt with the 8-bit tag
The following code demonstrates how you might calculate the 32-bit canary value in C:
uint32_t  canary_value (uint64_t  salt, uint8_t tag) {
    uint32_t  tag_expanded  =
        (uint32_t )tag |
        ((uint32_t )~tag << 8)
        ((uint32_t )tag << 16);
    tag_expanded  &= (0xff0000u  | ((salt >> 24) & 0x00ffffu ));
    uint32_t  result24  = tag_expanded  ^ salt;
    return result24  << 8;
}
This canary value is chosen such that:
•Different tags are guaranteed to yield different canary values
•For any two different tags, each is a function of at least one salt bit that the other is not a function of (so it is
difficult to calculate canaries for different tags even if one value is known)
•Null-terminated string operations on the stack terminate before reading or writing a canary
Each function should use a different canary tag, to prevent a stack frame for one function being used to return through
another function’s epilogue. Avoid using canary values for purposes other than stack canaries.
The RP2350 bootrom uses 8-bit tags in the range 0x40 through 0xbf. The remaining tags are free for use in user code.
3.6.3.6. Pseudorandom instruction delays
By default, all RCP instructions execute with a pseudorandom delay in the range of 0 to 127 cycles. These delays make
it more difficult for an outside observer to precisely time a fault injection event with respect to an RCP instruction, or the
critical code path it protects.
NOTE
In certain usage situations, RCP delays can expose a side-channel where processor state can be inferred. See
RP2350-E26  for details.
Setting bit 12 of the first halfword of an instruction disables the pseudorandom delay for that instruction only. The
instruction executes in a single cycle, assuming the Cortex-M33 does not insert stall cycles due to other micro-
architectural constraints. To set this bit, assemble the *2 variant of any given coprocessor instruction ( e.g. mrc2 rather
than mrc). In the NonSecure state, RCP instructions always execute without delay.
The RCP implements instruction execution delays by stalling the coprocessor opcode interface during the opcode
phase (shown in the Figure 13  pipeline diagram). The Cortex-M33 may choose to abandon a stalled coprocessor
instruction due to an interrupt. When this happens, the delay counter continues counting down, waiting for the delay
period to elapse. If the Cortex-M33 issues another RCP instruction whilst the delay counter is still running (either in the
interrupt, or after returning to the interrupted RCP instruction), this instruction executes once the existing countdown
completes. However, if the delay counter of an abandoned instruction has already expired before the next RCP
instruction executes, the next instruction samples a pseudorandom delay count, and begins a new countdown.
The pseudorandom delay sequence is a function of bits 63:40 of the salt value. As such, the pattern of delays is unique
per-boot, provided each boot writes a different 64-bit value to the salt register.
The pseudorandom number generator (PRNG) used for delays implements a number of small linear feedback shift
registers (LFSRs) in bits 63:40 of the salt register, and returns a nonlinear function of the 24-bit state. The LFSR feedback
functions on the 24-bit state are:
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 117
•Bits 23:20: 4-bit LFSR with taps 0xc
•Bits 19:15: 5-bit LFSR with taps 0x14
•Bits 14:8: 7-bit LFSR with taps 0x60
•Bits 7:0: 8-bit LFSR with taps 0xb4
The LFSRs are implemented by shifting the XOR reduction of (state AND taps) into the LSB with each state update.
When an LFSR’s state is all-zeroes, a one bit is shifted into the LSB. The LFSR state advances each time a random
number is generated: this happens when executing an instruction with a pseudorandom delay, or when executing a
rcp_random_byte  instruction.
Each bit of the pseudorandom output is the XOR of six bits of the 24-bit state, XORed with the majority-3 vote of three
other bits of the state:
Output Bit XOR Taps Majority-3 Taps
7 7 17 6 16 13 8 9 12 21
6 14 21 19 6 16 13 4 14 6
5 7 5 2 18 11 1 18 14 7
4 4 19 17 0 18 7 18 11 3
3 23 12 7 16 14 5 17 3 15
2 15 13 20 21 8 12 7 22 9
1 4 16 11 18 9 6 14 21 16
0 11 3 4 19 10 14 1 2 9
Bits 6:0 of this function are used for pseudorandom instruction delays, producing delays in the range of 0 to 127 cycles.
The delay is applied in addition to the one-cycle base cost of executing a coprocessor instruction. The full 8-bit result is
available through the rcp_random_byte  instruction.
This is a simple pseudorandom number generator which makes it difficult to recover the initial 24-bit state from a small
number of observations. It accomplishes this by making the observation size much smaller than the state size and
using a non-linear combination function for the output. It has a number of statistical aberrations which make it
unsuitable for general random number generation (not to mention its small state size). For high-quality random number
generation, either use the system true-random number generator (TRNG) directly, or use a high-quality software PRNG
with a large state seeded from the TRNG.
Note that the 24 MSBs of the salt value used to seed the delay PRNG do not overlap with the 40 LSBs used to generate
stack canary values. Therefore measuring the random delays externally provides no information on the canary values.
3.6.3.7. Instruction listing
The Cortex-M33 processors access the RCP using mcr, mcrr, mrc, and cdp instructions. The Armv8-M Architecture
Reference Manual  describes the intricacies of these instructions in relation to the processor’s architectural state, but
from the coprocessor’s point of view:
•mcr writes a 32-bit value to the coprocessor from a single Arm integer register
•mcrr writes a 64-bit value to the coprocessor from a pair of Arm integer registers
•mrc reads a 32-bit value from the coprocessor, writing to either a single Arm integer register or to the processor
status flags
•cdp performs some internal coprocessor operation without exchanging data with the processor
For each mcr, mcrr, mrc and cdp instruction, the RCP also accepts the matching mcr2, mcrr2, mrc2, and cdp2 opcode variant.
These opcodes differ only in bit 12. The plain versions have a pseudorandom delay of up to 127 cycles on their
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 118
execution, whereas the 2-suffixed versions have no such delay.
Most RCP instructions are in the form of hardware-checked assertions. The phrase "asserts that" in the following
instruction listings means that, if some asserted condition is not true, the coprocessor raises an RCP fault.
3.6.3.7.1. Initialisation
rcp_salt_core0
Asserts that the core 0 salt register is currently invalid. Writes a 64-bit value, and marks it as valid.
Opcode:
mcrr p7, #8, Rt, Rt2, c0
Rt is the 32 LSBs of the salt, Rt2 is the 32 MSBs.
rcp_salt_core1
Asserts that the core 1 salt register is currently invalid. Writes a 64-bit value, and marks it as valid.
Opcode:
mcrr p7, #8, Rt, Rt2, c1
rcp_canary_status
Returns a true or false bit pattern ( 0xa500a500  or 0x00c300c3  respectively) that indicates whether the salt register for
this core has been initialised.
Opcode:
mrc p7, #1, Rt, c0, c0, #0
Invoking with Rt = 0xf sets the Arm N and C flags if and only if the salt register is valid.
If the salt has not been initialised, any operation other than initialising the salt or checking the canary status triggers
an RCP fault.
This opcode is used on core 0 to skip the RCP initialisation sequence if the bootrom has been re-entered without a
reset under debugger control, and on core 1 to wait for its RCP salt to be initialised.
3.6.3.7.2. Canary
rcp_canary_get
Gets a 32-bit canary value as a function of the salt register and the 8-bit tag encoded by two 4-bit coprocessor
register numbers CRn and CRm. CRn contains the four MSBs, CRm the four LSBs.
Opcode:
mrc p7, #0, Rt, CRn, CRm, #1
Section 3.6.3.5  specifies the 32-bit value returned by this instruction, but you should treat this as an opaque value to
be consumed by rcp_canary_check .
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 119
rcp_canary_check
Asserts that a value matches the result of an rcp_canary_get  with the same 8-bit tag. The tag is encoded by two 4-bit
coprocessor register numbers, CRn and CRm. CRn contains the four MSBs, CRm the four LSBs.
Opcode:
mcr p7, #0, Rt, CRn, CRm, #1
3.6.3.7.3. Boolean validation
The RCP defines 0xa500a500  as the true value for 32-bit booleans, and 0x00c300c3  as the false value. All other bit patterns
are poison, and trigger an RCP fault when consumed by any RCP boolean instructions. These values are chosen as they
are valid immediates in Armv8-M Main.
This provides limited runtime type checking to ensure that boolean values are used in boolean contexts. The RP2350
bootrom occasionally uses redundant operations to generate booleans in a way that results in an invalid bit pattern if
the two redundant operations do not return the same value, such as when checking boot flags in OTP.
rcp_bvalid
Asserts that Rt is a valid boolean ( 0xa500a500  or 0x00c300c3 ).
Opcode:
mcr p7, #1, Rt, c0, c0, #0
rcp_btrue
Asserts that Rt is true (0xa500a500 ).
Opcode:
mcr p7, #2, Rt, c0, c0, #0
rcp_bfalse
Asserts that Rt is false (0x00c300c3 ).
Opcode:
mcr p7, #3, Rt, c0, c0, #1
rcp_b2valid
Asserts that Rt and Rt2 are both valid booleans.
Opcode:
mcrr p7, #0, Rt, Rt2, c8
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 120
rcp_b2and
Asserts that Rt and Rt2 are both true.
Opcode:
mcrr p7, #1, Rt, Rt2, c0
rcp_b2or
Asserts that both Rt and Rt2 are valid, and at least one is true.
mcrr p7, #2, Rt, Rt2, c0
rcp_bxorvalid
Asserts that Rt XOR Rt2 is a valid boolean. The XOR mask is generally a fixed bit pattern used to validate the origin
of the boolean, such as a return value from a critical function.
Opcode:
mcrr p7, #3, Rt, Rt2, c8
rcp_bxortrue
Asserts that Rt XOR Rt2 is true.
Opcode:
mcrr p7, #4, Rt, Rt2, c0
rcp_bxorfalse
Asserts that Rt XOR Rt2 is false.
Opcode:
mcrr p7, #5, Rt, Rt2, c8
3.6.3.7.4. Integer Validation
rcp_ivalid
Asserts that Rt XOR Rt2 is equal to 0x96009600 . This is used to validate 32-bit integers stored redundantly in two
memory words. The XOR difference provides assurance that two parallel chains of integer operations have not
mixed.
Opcode:
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 121
mcrr p7, #6, Rt, Rt2, c8
rcp_iequal
Asserts that Rt is equal to Rt2. Useful for general software assertions that are worth checking in hardware.
Opcode:
mcrr p7, #7, Rt, Rt2, c0
3.6.3.7.5. Random
rcp_random_byte
Returns a random 8-bit value generated from the upper 24 bits of the 64-bit salt value. Bits 31:8 of the result are all-
zero.
Opcode:
mrc p7, #2, Rt, c0, c0, #0
This is the same PRNG used for random delay values. It is mainly exposed for debugging purposes, and should not
be used for general software RNG purposes because the 24-bit state space is inadequate for scenarios where the
quality and predictability of the random numbers is important.
This instruction never has an execution delay. Once the Cortex-M33 issues the coprocessor access, it always
completes in one cycle.
3.6.3.7.6. Sequence count checking
These instructions are used to assert that a sequence of operations happens in the correct order. The count is
initialised to an 8-bit value at the beginning of such a sequence, then repeatedly checked, incrementing with each check.
If the 8-bit check value does not match the current counter value, the coprocessor raises an RCP fault.
rcp_count_set
Writes an 8-bit count value to the RCP sequence counter. Encodes the 8-bit value using two 4-bit coprocessor
numbers: CRn provides the MSBs, CRm the LSBs.
Opcode:
mcr p7, #4, r0, CRn, CRm, #0
rcp_count_check
Asserts that an 8-bit count value matches the current value of the RCP sequence counter. Increments the counter
by one, wrapping back to 0x00 after reaching 0xff. Encodes the 8-bit count value using two 4-bit coprocessor
numbers: CRn provides the MSBs, CRm the LSBs.
Opcode:
RP2350 Datasheet
3.6. Cortex-M33 coprocessors 122
mcr p7, #5, r0, CRn, CRm, #1
3.6.3.7.7. Panic
rcp_panic
Stalls the coprocessor port forever. If the processor abandons the coprocessor access, asserts NMI and continues
stalling the coprocessor port. Also immediately raises an RCP fault on other cores.
Opcode:
cdp p7, #0, c0, c0, c0, #1
Software executes an rcp_panic  instruction when it detects a condition that makes it unsafe to continue executing
the current program. The RCP responds by stalling the processor’s CDP access forever, which should cause the
processor to stop fetching and executing instructions.
The processor is allowed to abandon a stalled coprocessor instruction when interrupted, which may cause it to
continue executing in an unsafe state. The RCP responds to an abandoned transfer by asserting the non-maskable
interrupt, pre-empting the interrupt handler that caused the coprocessor access to be abandoned. This should
swiftly encounter another RCP instruction and once again stall the processor, this time without allowing
interruption.
Panic is specified in this way, instead of gating the processor clock, so the debugger can still attach cleanly to the
processor after a panic.
3.6.4. Floating point unit
The Cortex-M33 cores on RP2350 are configured with the standard Arm single-precision floating point unit (FPU).
Coprocessor ports 10 and 11 access the FPU.
The Arm floating point extension is documented in the Armv8-M Architecture Reference Manual .
Applications built with the SDK use the FPU automatically by default. For example, calculations with the float data type
in C automatically use the standard FPU, while calculations with the double data type automatically use the RP2350
double-precision coprocessor ( Section 3.6.2 ).
3.7. Cortex-M33 processor
Arm Documentation
Much of the following is excerpted from the Cortex-M33 Technical Reference Manual . Used with
permission.
The Arm Cortex-M33 processor is a low gate count, highly energy-efficient processor intended for microcontroller and
embedded applications. The processor is based on the Armv8-M architecture and is primarily for use in environments
where security is an important consideration.
RP2350 Datasheet
3.7. Cortex-M33 processor 123
NOTE
Full details of the Arm Cortex-M33 processor can be found in the Technical Reference Manual .
3.7.1. Features
The Arm Cortex-M33 processor provides the following features and benefits:
•An in-order issue pipeline
•Thumb-2 technology; for more information, see the Armv8-M Architecture Reference Manual
•Little-endian data accesses
•A Nested Vectored Interrupt Controller (NVIC) closely integrated with the processor
•A Floating Point Unit (FPU) supporting single-precision arithmetic
•Support for exception-continuable instructions, such as LDM, LDMDB, STM, STMDB, PUSH, POP, VLDM, VSTM,
VPUSH, and VPOP
•A low-cost debug solution that provides the ability to implement:
◦Breakpoints
◦Watchpoints
◦Tracing
◦System profiling
◦Support for printf()  style debugging through an Instrumentation Trace Macrocell (ITM)
•Support for the Embedded Trace Macrocell (ETM) instruction trace option; for more information, see the Arm
CoreSight ETM-M33 Technical Reference Manual
•A coprocessor interface for external hardware accelerators
•Low-power features including architectural clock gating, sleep mode, and a power-aware system with Wake-up
Interrupt Controller (WIC)
•A memory system that includes memory protection and security attribution
3.7.2. Configuration
Each Arm Cortex-M33 processor in RP2350 is configured with the following features:
•FPU: Single precision FPU
•DSP: DSP extension
•SECEXT : Security extensions
•CPIF: coprocessor interface
•MPU_NS: 8 non-secure MPU regions
•MPU_S: 8 secure MPU regions
•SAU: 8 SAU regions
•IRQ: 52 external interrupts
•IRQLVL: 4 exception priority bits
•DBGLVL: Full debug set: 4 watchpoint, 8 breakpoint comparators, debug monitor
RP2350 Datasheet
3.7. Cortex-M33 processor 124
•ITM: DWT  and ITM trace
•ETM : ETM trace
•MTB : no MTB trace
•WIC: Wake up interrupt controller
•WICLINES: 55: All external interrupts and 3 internal events: NMI, RVEX, Debug
•CTI: Cross trigger interface
•RAR: reset all registers on power up
•UNCROSS_I_D : Modify internal address map
•SBIST: no SBIST features
•CDE modules not used
•CDERTLID: RTL ID for system with multi Cortex-M33: 16
Architectural clock gating allows the processor core to support SLEEP and DEEPSLEEP power states by disabling the
clock to parts of the processor core. Power gating is not supported.
Each Cortex-M33 core has its own interrupt controller that can individually mask out interrupt sources as required. The
same interrupts route to both Cortex-M33 cores.
The processor supports the following interfaces:
•Code AHB (C-AHB) interface
•System AHB (S-AHB) interface
•External PPB (EPPB) APB interface
•Debug AHB (D-AHB) interface
The processor implements the following optional interfaces:
•Arm TrustZone technology, using the Armv8-M Security Extension supporting Secure and Non-secure states
•Memory Protection Units (MPUs), which you can configure to protect regions of memory
•Floating-point arithmetic functionality with support for single precision arithmetic
•Support for ETM trace
3.7.2.1. Modifications by Raspberry Pi
3.7.2.1.1. UNCROSS_I_D
The original Cortex-M33 processor design routes the following operations to either the Code or System port:
•instruction fetch
•load/stores
•debugger accesses
Accesses below address 0x20000000  route to the Code port. All other accesses route to the System port.
This routing strategy makes contention possible on both the internal bus matrix and the main system AHB5 crossbar.
The Cortex-M33 Technical Reference Manual  describes this strategy in detail.
In RP2350, Raspberry Pi modified the Cortex-M33 bus matrix to:
•route all instruction fetch operations to the Code port
RP2350 Datasheet
3.7. Cortex-M33 processor 125
•route all load/stores and debugger accesses to the System port
This eliminates internal conflicts and improves performance in certain software use cases, e.g. when allocating both
code and data from a single unified SRAM pool.
In Section 3.7.2 , we refer to this feature as UNCROSS_I_D .
There are no other modifications to the Cortex-M33 processor.
NOTE
This datasheet may refer to the Cortex-M33 Code and System ports as the instruction and data ports respectively (I
and D), to reflect this modification to the core’s integrated bus matrix.
3.7.2.2. Interfaces
The processor has various external interfaces:
Code and System AHB interfaces
Harvard AHB bus architecture supporting exclusive transactions and security state.
System AHB interface
The System AHB (S-AHB) interface is used for any instruction fetch and data access to the memory-mapped SRAM,
Peripheral, External RAM and External device, or Vendor_SYS regions of the Armv8-M memory map.
Code AHB interface
The Code AHB (C-AHB) interface is used for any instruction fetch and data access to the Code region of the Armv8-
M memory map.
External Private Peripheral Bus
The External PPB (EPPB) APB interface enables access to CoreSight-compatible debug and trace components in a
system connected to the processor.
Secure attribution interface
The processor has an interface that connects to an external Implementation Defined Attribution Unit (IDAU), which
enables your system to set security attributes based on address.
ATB interfaces
The ATB interfaces output trace data for debugging. The ATB interfaces are compatible with the CoreSight
architecture. See the Arm CoreSight Architecture Specification v2.0 for more information. The instruction ATB
interface is used by the ETM, and the instrumentation ATB interface is used by the Instrumentation Trace Macrocell
(ITM).
Micro Trace Buffer interfaces
The Micro Trace Buffer (MTB) AHB slave interface and SRAM interface are for the CoreSight Micro Trace Buffer.
Coprocessor interface
The coprocessor interface is designed for closely coupled external accelerator hardware.
Debug AHB interface
The Debug AHB (D-AHB) slave interface allows a debugger access to registers, memory, and peripherals. The D-
AHB interface provides debug access to the processor and the complete memory map.
Cross Trigger Interface
The processor includes a Cross Trigger Interface (CTI) Unit that has an interface that is suitable for connection to
external CoreSight components using a Cross Trigger Matrix (CTM).
Power control interface
The processor supports a number of internal power domains that can be enabled and disabled using Q-channel
interfaces connected to a Power Management Unit (PMU) in the system.
RP2350 Datasheet
3.7. Cortex-M33 processor 126
3.7.2.3. Security attribution and memory protection
The Cortex-M33 processor supports the Armv8-M Protected Memory System Architecture (PMSA) that provides
programmable support for memory protection  using a number of software controllable regions. RP2350 supports 8
programmable regions.
PMSA allows privileged software to assign access permissions to a memory region. When unprivileged software
attempts to access the region, a fault exception is triggered. PMSA includes fault status registers that allow an
exception handler to determine the source of the fault, apply corrective action, and notify the system. This reduces the
potential impact of incorrectly-written application code.
The Cortex-M33 processor also includes support for defining memory regions as Secure or Non-secure, as defined in
the Armv8-M Security Extension. This protects memory regions from accesses with an inappropriate level of security.
3.7.2.4. Floating-point unit (FPU)
The FPU provides:
•Instructions for single-precision (C programming language float type) data-processing operations
•Instructions for double-precision (C programming language double type) load and store operations
•Combined multiply-add instructions for increased precision (Fused MAC)
•Hardware support for conversion, addition, subtraction, multiplication, accumulate, division, and square-root
•Hardware support for denormals and all IEEE Standard 754-2008 rounding modes
•Thirty-two 32-bit single-precision registers or sixteen 64-bit double-precision registers
•Lazy floating-point context save
3.7.2.4.1. Lazy floating-point context save
This FPU function delays automated stacking of floating-point state until the ISR attempts to execute a floating-point
instruction. This reduces the latency to enter the ISR and removes floating-point context save for ISRs that do not use
floating-point.
3.7.2.5. NVIC
The Nested Vectored Interrupt Controller NVIC prioritizes external interrupt signals. Software can set the priority of each
interrupt. The NVIC and the Cortex-M33 processor core are closely coupled, providing low latency interrupt processing
and efficient processing of late arriving interrupts.
NOTE
"Nested" refers to the fact that interrupts can themselves be interrupted, by higher-priority interrupts. "Vectored"
refers to the hardware dispatching each interrupt to a distinct handler routine specified by a vector table. For more
details about nesting and vectoring behaviour, see the Armv8-M Architecture Reference Manual .
All NVIC registers are only accessible using word transfers. Any attempt to read or write a halfword or byte individually
is unpredictable.
NVIC registers are always little-endian.
The Nested Vectored Interrupt Controller (NVIC) is closely integrated with the core to achieve low-latency interrupt
processing.
Functions of the NVIC include:
RP2350 Datasheet
3.7. Cortex-M33 processor 127
•External interrupts, configurable from 1 to 480 using a contiguous or non-contiguous mapping. This is configured
at implementation.
•Configurable levels of interrupt priority from 8 to 256. This is configured at implementation.
•Dynamic reprioritisation of interrupts.
•Priority grouping. This enables selection of pre-empting interrupt levels and non-pre-empting interrupt levels.
•Support for tail-chaining and late arrival of interrupts. This enables back-to-back interrupt processing without the
overhead of state saving and restoration between interrupts.
•Support for the Armv8-M Security Extension. Secure interrupts can be prioritized above any Non-secure interrupt.
3.7.2.6. Cross Trigger Interface Unit (CTI)
The CTI enables the debug logic, MTB, and ETM to interact with each other and with other CoreSight ™ components.
3.7.2.7. ETM
The ETM provides instruction-only capabilities.
3.7.2.8. MTB
The MTB provides a simple low-cost execution trace solution for the Cortex-M33 processor.
Trace is written to an SRAM interface, and can be extracted using a dedicated AHB slave interface (M-AHB) on the
processor. The MTB can be controlled by memory-mapped registers in the PPB region or by events generated by the
DWT or through the CTI.
See the Arm CoreSight MTB-M33 Technical Reference Manual  for more information.
3.7.2.9. Debug and trace
Debug and trace components include a configurable Breakpoint Unit (BPU) used to implement breakpoints and a
configurable Data Watchpoint and Trace (DWT) unit used to implement watchpoints, data tracing, and system profiling.
Other debug and trace components include:
•ITM for support of printf()  style debugging, using instrumentation trace
•Interfaces suitable for:
◦Passing on-chip data through a Trace Port Interface Unit (TPIU) to a Trace Port Analyzer (TPA) via a 4-bit DDR
output selected as a GPIO function (see Section 3.5.7 )
◦A ROM table to allow debuggers to determine which components are implemented in the Cortex-M33
processor
◦Debugger access to all memory and registers in the system, including access to memory-mapped devices,
access to internal core registers when the core is halted, and access to debug control registers even when
reset is asserted
3.7.3. Compliance
The processor complies with, or implements, the relevant Arm architectural standards and protocols, and relevant
external standards.
RP2350 Datasheet
3.7. Cortex-M33 processor 128
3.7.3.1. Arm architecture
The processor is compliant with the following:
•Armv8-M Main Extension
•Armv8-M Security Extension
•Armv8-M Protected Memory System Architecture (PMSA)
•Armv8-M Floating-point Extension
•Armv8-M Digital Signal Processing (DSP) Extension
•Armv8-M Debug Extension
•Armv8-M Flash Patch Breakpoint (FPB) architecture version 2.0
3.7.3.2. Bus architecture
The processor provides external interfaces that comply with the AMBA 5 AHB5 protocol. The processor also
implements interfaces for CoreSight and other debug components using the APB4 protocol and ATBv1.1 part of the
AMBA 4 ATB protocol.
For more information, see the:
•Arm AMBA 5 AHB Protocol Specification
•AMBA APB Protocol Version 2.0 Specification
•Arm AMBA 4 ATB Protocol Specification ATBv1.0 and ATBv1.1
The processor also provides a Q-Channel interface. For more information, see the AMBA Low Power Interface
Specification .
3.7.3.3. Debug
The debug features of the processor implement the Arm Debug Interface Architecture. For more information, see the
Arm Debug Interface Architecture Specification, ADIv5.0 to ADIv5.2 .
3.7.3.4. Embedded Trace Macrocell
The trace features of the processor implement the Arm Embedded Trace Macrocell (ETM) v4.2 architecture.
For more information, see the Arm CoreSight ETM-M33 Technical Reference Manual .
3.7.3.5. Floating-point unit
The Cortex-M33 processor with FPU supports single-precision arithmetic as defined by the FPv5 architecture that is part
of the Armv8-M architecture. The FPU provides floating-point computation functionality compliant with ANSI/IEEE
Standard 754-2008, IEEE Standard for Binary Floating-Point Arithmetic.
The FPU supports single-precision add, subtract, multiply, divide, multiply and accumulate, and square root operations.
It also provides conversions between fixed-point and floating-point data formats, and floating-point constant
instructions.
The FPU provides an extension register file containing 32 single-precision registers.
The registers can be viewed as:
RP2350 Datasheet
3.7. Cortex-M33 processor 129
•Thirty-two 32-bit single-word registers, S0-S31
•Sixteen 64-bit double-word registers, D0-D15
•A combination of registers from these views
3.7.3.5.1. FPU modes
The FPU provides full-compliance, flush-to-zero, and Default NaN modes of operation. In full-compliance mode, the FPU
processes all operations according to the IEEE 754 standard in hardware.
Modes of operation are controlled using the Floating-Point Status and Control Register, FPSCR.
Setting the FPSCR.FZ  bit enables Flush-to-Zero (FZ) mode. In FZ mode, the FPU treats all subnormal input operands of
arithmetic operations as zeros. Exceptions that result from a zero operand are signalled appropriately. VABS, VNEG, and
VMOV are not considered arithmetic operations and are not affected by FZ mode. When an operation yields a tiny result
(as described in the IEEE 754 standard, where the destination precision is smaller in magnitude than the minimum
normal value before rounding) FZ mode replaces the result with a zero.
The FPSCR.IDC  bit indicates when an input flush occurs.
The FPSCR.UFC  bit indicates when a result flush occurs.
Setting the FPSCR.DN  bit enables Default NaN (DN) mode. In NaN mode, the result of any arithmetic data processing
operation that involves an input NaN, or that generates a NaN result, returns the default NaN. All arithmetic operations
except for VABS, VNEG, and VMOV ignore the fraction bits of an input NaN.
Setting neither the FPSCR.DN  bit nor the FPSCR.FZ  bit enables full-compliance mode. In full-compliance mode, FPv5
functionality is compliant with the IEEE 754 standard in hardware.
For more information about the FPU and FPSCR, see the Armv8-M Architecture Reference Manual .
3.7.3.5.2. FPU exceptions
The FPU sets the cumulative exception status flag in the FPSCR register as required for each instruction, in accordance
with the FPv5 architecture. The FPU does not support exception traps.
The processor has six output pins. By default, they are disconnected. Each reflect the status of one of the cumulative
exception flags:
FPIXC
Masked floating-point inexact exception.
FPUFC
Masked floating-point underflow exception.
FPOFC
Masked floating-point overflow exception.
FPDZC
Masked floating-point divide by zero exception.
FPIDC
Masked floating-point input denormal exception.
FPIOC
Invalid operation.
When a floating-point context is active, the stack frame extends to accommodate the floating-point registers. To reduce
the additional interrupt latency associated with writing the larger stack frame on exception entry, the processor
supports lazy stacking. This means that the processor reserves space on the stack for the FP state, but does not save
that state information to the stack unless the processor executes an FPU instruction inside the exception handler.
RP2350 Datasheet
3.7. Cortex-M33 processor 130
The lazy save of the FP state is interruptible by a higher priority exception. The FP state saving operation starts over
after that exception returns.
3.7.3.5.3. Low power FPU operation
If the FPU is in a separate power domain, the way the FPU domain powers down depends on whether the FPU domain
includes state retention logic.
To power down the FPU:
•If FPU domain includes state retention logic, disable the FPU by clearing the CPACR.CP10 and CPACR.CP11 bitfields.
•If FPU domain does not include state retention logic, disable the FPU by clearing the CPACR.CP10 and CPACR.CP11
bitfields and set both the CPPWR.SU10  and CPPWR.SU11  bitfields to 1.
WARNING
Setting the CPPWR.SU10  and CPPWR.SU11  bitfields indicates that FPU state can be lost.
3.7.4. Programmer’s model
The Cortex-M33 programmer’s model is an implementation of the Armv8-M Main Extension architecture.
For a complete description of the programmers model, refer to the Armv8-M Architecture Reference Manual , which also
contains the Armv8-M Thumb instructions. In addition, other options of the programmers model are described in the
System Control, MPU, NVIC, FPU, Debug, DWT, ITM, and TPIU feature topics.
3.7.4.1. Modes of operation and execution
The Cortex-M33 processor supports Secure and Non-secure security states, Thread and Handler operating modes, and
can run in either Thumb or Debug operating states. In addition, the processor can limit or exclude access to some
resources by executing code in privileged or unprivileged mode.
See the Armv8-M Architecture Reference Manual  for more information about the modes of operation and execution.
3.7.4.1.1. Security states
With the Armv8-M Security Extension, the programmer’s model includes two orthogonal security states: Secure  state
and Non-secure  state. The processor always resets into Secure state. Each security state includes a set of independent
operating modes and supports both privileged and unprivileged user access. Registers in the System Control Space are
banked across Secure and Non-secure state, with a Non-secure register view available to Secure state at an aliased
address.
3.7.4.1.2. Operating modes
For each security state, the processor can operate in Thread  or Handler  mode. The following conditions cause the
processor to enter Thread or Handler mode:
•The processor enters Thread mode on reset, or as a result of an exception return to Thread mode. Privileged and
Unprivileged code can run in Thread mode.
•The processor enters Handler mode as a result of an exception. In Handler mode, all code is privileged.
The processor can change security state on taking an exception, for example when a Secure exception is taken from
Non-secure state, the Thread mode enters the Secure state Handler mode. The processor can also call Secure functions
RP2350 Datasheet
3.7. Cortex-M33 processor 131
from Non-secure state and Non-secure functions from Secure state. The Security Extension includes requirements for
these calls to prevent Secure data from being accessed in Non-secure state.
3.7.4.1.3. Operating states
The processor can operate in Thumb or Debug state:
•Thumb state is the state of normal execution running 16-bit and 32-bit halfword- aligned Thumb instructions.
•Debug state is the state when the processor is in Halting debug.
3.7.4.1.4. Privileged access and unprivileged user access
Code can execute as privileged or unprivileged. Unprivileged execution limits resource access appropriate to the current
security state. Privileged execution has access to all resources available to the security state. Handler mode is always
privileged. Thread mode can be privileged or unprivileged.
3.7.4.2. Instruction set summary
The processor implements the following instruction from Armv8-M:
•All base instructions
•All instructions in the Main Extension
•All instructions in the Security Extension
•All instructions in the DSP Extension
•All single-precision instructions and double precision load/store instructions in the Floating-point Extension
For more information about Armv8-M instructions, see the Armv8-M Architecture Reference Manual .
3.7.4.3. Memory model
The processor contains a bus matrix that arbitrates instruction fetches and memory accesses from the processor core
between the external memory system and the internal System Control Space (SCS) and debug components.
Priority is usually given to the processor to keep debug accesses as non-intrusive as possible.
The system memory map is Armv8-M Main Extension compliant, and is common both to the debugger and processor
accesses.
The default memory map provides user and privileged access to all regions except for the Private Peripheral Bus (PPB).
The PPB space only allows privileged access.
The following table shows the default memory map. This is the memory map used when the included MPUs are
disabled. The attributes and permissions of all regions, except that targeting the NVIC and debug components, can be
modified using an implemented MPU.
Table 114. Default
memory mapAddress Range (inclusive) Region Interface
0x00000000  - 0x1FFFFFFF Code Instruction and data accesses.
0x20000000  - 0x3FFFFFFF SRAM Instruction and data accesses.
0x40000000  - 0x5FFFFFFF Peripheral Instruction and data accesses. Any attempt to execute instructions
from the peripheral and external device region results in a
MemManage fault.
RP2350 Datasheet
3.7. Cortex-M33 processor 132
Address Range (inclusive) Region Interface
0x60000000  - 0x9FFFFFFF External RAM Instruction and data accesses. Any attempt to execute instructions
from the peripheral and external device region results in a
MemManage fault.
0xA0000000  - 0xDFFFFFFF External device Instruction and data accesses. Any attempt to execute instructions
from the peripheral and external device region results in a
MemManage fault.
0xE0000000  - 0xE00FFFFF PPB Reserved for system control and debug. Cannot be used for
exception vector tables. Data accesses are either performed
internally or on EPPB. Accesses in the range 0xE0000000  - 0xE0043FFF 
are handled within the processor. Accesses in the range 0xE0044000 
- 0xE00FFFFF  appear as APB transactions on the EPPB interface of
the processor. Any attempt to execute instructions from the region
results in a MemManage fault.
0xE0100000  - 0xFFFFFFFF Vendor_SYS Partly reserved for future processor feature expansion. Any
attempt to execute instructions from the region results in a
MemManage fault.
The internal Secure Attribution Unit (SAU) determines the security level associated with an address. Some internal
peripherals have memory-mapped registers in the PPB region which are banked between Secure and Non-secure state.
When the processor is in Secure state, software can access both the Secure and Non-secure versions of these
registers. The Non-secure versions are accessed using an aliased address.
For more information about the memory model, see the Armv8-M Architecture Reference Manual .
3.7.4.3.1. Private Peripheral Bus (PPB)
The Private Peripheral Bus (PPB) memory region provides access to internal and external processor resources.
The internal PPB provides access to:
•The System Control Space (SCS), including the Memory Protection Unit (MPU), Secure Attribution Unit (SAU), and
the Nested Vectored Interrupt Controller (NVIC).
•The Data Watchpoint and Trace (DWT) unit.
•The Breakpoint Unit (BPU).
•The Embedded Trace Macrocell (ETM).
•CoreSight Micro Trace Buffer (MTB).
•Cross Trigger Interface (CTI).
•The ROM table.
The external PPB (EPPB) provides access to implementation-specific external areas of the PPB memory map.
3.7.4.3.2. Unaligned accesses
The Cortex-M33 processor supports unaligned accesses. They are converted into two or more aligned AHB transactions
on the C-AHB or S-AHB master ports on the processor.
Unaligned support is only available for load/store singles (LDR, LDRH, STR, STRH, TBH) to addresses in Normal
memory. Load/store double and load/store multiple instructions already support word aligned accesses, but do not
permit other unaligned accesses, and generate a fault if this is attempted. Unaligned accesses in Device memory are
not permitted and fault. Unaligned accesses that cross memory map boundaries are architecturally UNPREDICTABLE .
RP2350 Datasheet
3.7. Cortex-M33 processor 133
NOTE
If CCR.UNALIGN_TRP  for the current Security state is set, any unaligned accesses generate a fault.
3.7.4.4. Exclusive monitor
The Cortex-M33 processor implements a local exclusive monitor. The local monitor within the processor has been
constructed so that it does not hold any physical address, but instead treats any store-exclusive access as matching the
address of the previous load-exclusive. This means that the implemented exclusives reservation granule is the entire
memory address range. For more information about semaphores and the local exclusive monitor, see the Armv8-M
Architecture Reference Manual .
3.7.4.5. Processor core registers summary
The following table shows the processor core register set summary. Each of these registers is 32 bits wide. When the
Armv8-M Security Extension is included, some of the registers are banked. The Secure view of these registers is
available when the Cortex-M33 processor is in Secure state and the Non-secure view when Cortex-M33 processor is in
Non-secure state.
Table 115. Processor
core register set
summaryName Description
R0-R12 R0-R12 are general-purpose registers for data operations.
MSP (R13) The Stack Pointer (SP) is register R13. In Thread mode, the
CONTROL register indicates the stack pointer to use, Main
Stack Pointer (MSP) or Process Stack Pointer (PSP).
There are two MSP registers in the Cortex-M33 processor:
MSP_NS for the Non-secure state, and MSP_S for the Secure
state.
PSP (R13) The Stack Pointer (SP) is register R13. In Thread mode, the
CONTROL register indicates the stack pointer to use, Main
Stack Pointer (MSP) or Process Stack Pointer (PSP).
There are two PSP registers in the Cortex-M33 processor:
PSP_NS for the Non-secure state, and PSP_S for the Secure
state.
MSPLIM The stack limit registers limit the extent to which the MSP
and PSP registers can descend respectively. There are
two MSPLIM registers in the Cortex-M33 processor:
MSPLIM_NS  for the Non-secure state, and MSPLIM_S  for the
Secure state.
PSPLIM The stack limit registers limit the extent to which the MSP
and PSP registers can descend respectively. There are
two PSPLIM registers in the Cortex-M33 processor:
PSPLIM_NS  for the Non-secure state, and PSPLIM_S  for the
Secure state.
LR (R14) The Link Register (LR) is register R14. It stores the return
information for subroutines, function calls, and
exceptions.
PC (R15) The Program Counter (PC) is register R15. It contains the
current program address.
RP2350 Datasheet
3.7. Cortex-M33 processor 134
Name Description
PSR The Program Status Register (PSR) combines the
Application Program Status Register ( APSR), Interrupt
Program Status Register ( IPSR), and Execution Program
Status Register ( EPSR). These registers provide different
views of the PSR.
PRIMASK The PRIMASK register prevents activation of exceptions with
configurable priority. When the Armv8-M Security
Extension is included, there are two PRIMASK registers in the
Cortex-M33 processor: PRIMASK_NS  for the Non-secure state
and PRIMASK_S  for the Secure state.
BASEPRI The BASEPRI register defines the minimum priority for
exception processing. There are two BASEPRI registers in
the Cortex-M33 processor: BASEPRI_NS  for the Non-secure
state, and BASEPRI_S  for the Secure state.
FAULTMASK The FAULTMASK  register prevents activation of all exceptions
except for NON-MASKABLE INTERRUPT  (NMI) and
Secure HardFault. There are two FAULTMASK  registers in the
Cortex-M33 processor: FAULTMASK_NS  for the Non-secure
state, and FAULTMASK_S  for the Secure state.
CONTROL The CONTROL register controls the stack used, and optionally
the privilege level, when the processor is in Thread mode.
There are two CONTROL registers in the Cortex-M33
processor: CONTROL_NS  for the Non-secure state and
CONTROL_S  for the Secure state.
3.7.4.6. Exceptions
Exceptions are handled and prioritized by the processor and the NVIC. In addition to architecturally defined behaviour,
the processor implements advanced exception and interrupt handling that reduces interrupt latency and includes
implementation defined behaviour.
The processor core and the Nested Vectored Interrupt Controller (NVIC) together prioritize and handle all exceptions.
When handling exceptions:
•All exceptions are handled in Handler mode.
•Processor state is automatically stored to the stack on an exception, and automatically restored from the stack at
the end of the Interrupt Service Routine (ISR).
•The vector is fetched in parallel to the state saving, enabling efficient interrupt entry.
The processor supports tail-chaining that enables back-to-back interrupts without the overhead of state saving and
restoration.
Software can choose only to enable a subset of the configured number of interrupts, and can choose how many bits of
the configured priorities to use.
Exceptions can be specified as either Secure or Non-secure. When an exception occurs the processor switches to the
associated security state. The priority of Secure and Non-secure exceptions can be programmed independently. You
can deprioritise Non-secure configurable exceptions using the AIRCR.PRIS bit field to enable Secure interrupts to take
priority.
When taking and returning from an exception, the register state is always stored using the stack pointer associated with
the background security state. When taking a Non-secure exception from Secure state, all the register state is stacked
and then registers are cleared to prevent Secure data being available to the Non-secure handler. The vector base
RP2350 Datasheet
3.7. Cortex-M33 processor 135
address is banked between Secure and Non-secure state. VTOR_S contains the Secure vector base address, and VTOR_NS
contains the Non-secure vector base address. These registers can be programmed by software, and also initialized at
reset by the system.
NOTE
Vector table entries are compatible with interworking between Arm and Thumb instructions. This causes bit[0] of the
vector value to load into the Execution Program Status Register (EPSR) T-bit on exception entry. All populated
vectors in the vector table entries must have bit[0] set. Creating a table entry with bit[0] clear generates an INVSTATE 
fault on the first instruction of the handler corresponding to this vector.
3.7.4.7. Security attribution and memory protection
Security attribution and memory protection in the processor is provided by the Security Attribution Unit (SAU) and the
Memory Protection Units (MPUs).
The SAU is a programmable unit that determines the security of an address. RP2350 includes 8 memory regions.
For instructions and data, the SAU returns the security attribute that is associated with the address.
For instructions, the attribute determines the allowable Security state of the processor when the instruction is executed.
It can also identify whether code at a Secure address can be called from Non-secure state.
For data, the attribute determines whether a memory address can be accessed from Non-secure state, and also whether
the external memory request is marked as Secure or Non-secure.
If a data access is made from Non-secure state to an address marked as Secure, then a SecureFault exception is taken
by the processor. If a data access is made from Secure state to an address marked as Non-secure, then the associated
memory access is marked as Non-secure.
The security level returned by the SAU is a combination of the region type defined in the internal SAU, if configured, and
the type that is returned on the associated Implementation Defined Attribution Unit (IDAU). If an address maps to
regions defined by both internal and external attribution units, the region of the highest security level is selected.
The register fields SAU_CTRL .EN and SAU_CTRL .ALLNS control the enable state of the SAU and the default security level when
the SAU is disabled. Both SAU_CTRL .EN and SAU_CTRL .ALLNS reset to zero disabling the SAU and setting all memory, apart
from some specific regions in the PPB space to Secure level. If the SAU is not enabled, and SAU_CTRL .ALLNS is zero, then
the IDAU cannot set any regions of memory to a security level lower than Secure, for example Secure NSC or NS. If the
SAU is enabled, then SAU_CTRL .ALLNS does not affect the Security level of memory.
RP2350 supports the Armv8-M Protected Memory System Architecture (PMSA). The MPU provides full support for:
•protection regions
•access permissions
•exporting memory attributes to the system
MPU mismatches and permission violations invoke the MemManage handler. For more information, see the Armv8-M
Architecture Reference Manual .
You can use the MPU to:
•enforce privilege rules
•separate processes
•manage memory attributes
The MPU supports 16 memory regions: 8 secure and 8 non-secure. The MPU is banked between Secure and Non-secure
states. The number of regions in the Secure and Non-secure MPU can be configured independently and each can be
programmed to protect memory for the associated Security state.
RP2350 Datasheet
3.7. Cortex-M33 processor 136
3.7.4.8. External coprocessors
The external coprocessor interface:
•Supports low-latency data transfer from the processor to and from the accelerator components.
•Has a sustained bandwidth up to twice of the processor memory interface.
The following instruction types are supported:
•Register transfer from the Cortex-M33 processor to the coprocessor MCR, MCRR, MCR2, MCRR2.
•Register transfer from the coprocessor to the Cortex-M33 processor MRC, MRRC, MRC2, MRRC2.
•Data processing instructions CDP, CDP2.
NOTE
The regular and extension forms of the coprocessor instructions for example, MCR and MCRR2, have the same
functionality but different encodings. The MRC and MRC2 instructions support the transfer of APSR.NZVC  flags when the
processor register field is set to PC, for example Rt == 0xF .
3.7.4.8.1. Restrictions
The following restrictions apply when to coprocessor instructions:
•The LDC(2) or STC(2) instructions are not supported. If these are included in software with the <coproc>  field set to a
value between 0-7 and the coprocessor is present and enabled in the appropriate fields in the CPACR/NSACR registers,
the Cortex-M33 processor always attempts to take an Undefined instruction  (UNDEFINSTR) UsageFault exception.
•The processor register fields for data transfer instructions must not include the stack pointer (Rt == 0xD) , this
encoding is UNPREDICTABLE  in the Armv8-M architecture and results in an Undefined instruction  (UNDEFINSTR)
UsageFault exception in the CPACR /NSACR  registers.
•If any coprocessor instruction is executed when the corresponding coprocessor is disabled in the CPACR/NSACR
register, the Cortex-M33 processor always attempts to take a No coprocessor  (NOCP) UsageFault exception.
3.7.4.8.2. Data transfer rates
The following table shows the ideal data transfer rates for the coprocessor interface. This means that the coprocessor
responds immediately to an instruction. The ideal data transfer rates are sustainable if the corresponding coprocessor
instructions are executed consecutively.
The following instructions have the following data transfer rates:
MCR, MCR2 (Processor to coprocessor)
32 bits per cycle
MRC, MRC2 (Coprocessor to processor)
32 bits per cycle
MCRR, MCRR2 (Processor to coprocessor)
64 bits per cycle
MRRC, MRRC2 (Coprocessor to processor)
64 bits per cycle
3.7.4.9. Execution timing
This section describes the execution time of various Cortex-M33 instructions. The results are based on measurements
RP2350 Datasheet
3.7. Cortex-M33 processor 137
of a limited and non-exceptional set of examples of the more common instructions and hence may not correctly cover
some more unusual situations.
These measurements were taken with the following conditions:
•only one core is running
•there are no cache misses (in particular, no XIP cache misses)
•there there is no active DMA
Any of the above conditions can affect the timing of instruction fetch as well as of load and store operations. See the
description of the bus fabric  elsewhere in this datasheet for information on possible contention for access to memory.
3.7.4.9.1. Result delays
Some instructions generate results with a two-cycle latency. Using such a result as a source operand for a subsequent
instruction incurs a one-cycle result-use penalty . Most of the input values of any instruction count as source operands,
including:
•any source register in a data processing (ALU) instruction
•any registers used in address generation by an LDR or LDM (including R13 in the case of POP)
•any registers used in address generation (but not those to be stored) by a STR or STM (including R13 in the case of
PUSH).
The following example shows a load followed by a data-processing instruction, an instruction sequence which incurs
this penalty:
LDR R0,[R1]
ADD R1,R0,R2
The following instructions generate results with a two-cycle latency:
•the destination register arising from some non-simple shifts in certain data-processing instructions (specified in
more detail below)
•the destination register or registers of a multiply instruction
•the destination register of an LDR
•the last register in the register list of an LDM or POP unless that register is R15
Using results of the above instructions as a source operand for another instruction incurs a one-cycle penalty between
the operations.
3.7.4.9.2. Simple arithmetic and logical instructions
Most data processing instructions execute in a single cycle. Some complex  operations (including those listed above
and SEL) incur a result-use penalty.
Complex operations meet at least one of the following criteria:
•a shifted operand where the shift is not LSL#0, LSL#1, LSL#2 or LSL#3
•an immediate operand which entails a shift (i.e., not of the form 0x000000XY , 0xXYXYXYXY , 0x00XY00XY  or 0xXY00XY00 )
When a complex instruction has the -S suffix to set flags, the one-cycle penalty is always incurred, even if the next
instruction does not depend on those flag values.
The following operations do not  incur a penalty:
RP2350 Datasheet
3.7. Cortex-M33 processor 138
AND R0,R1,R2,LSL#4
MOV R3,R4
However, the following operations do incur a penalty:
AND R0,R1,R2,LSL#4
MOV R3,R0
ANDS R0,R1,R2,LSL#4
MOV R3,R4
ADD and SUB are available in variants with a 12-bit plain immediate operand. These do not  incur a penalty.
MOV and MOVS with an immediate operand, including MOV with a 16-bit plain immediate operand, do not  incur a result-use
penalty.
Despite their similarity to logical operations with a shifted operand, UBFX, SBFX and BFI do not  incur a result-use penalty.
Simple shift instructions ( LSL, LSR, ASR, and ROR, with the shift amount specified either as an immediate constant or in a
register) take one cycle with no result-use penalty.
3.7.4.9.3. Multiply instructions
Multiply and multiply-accumulate instructions execute in a single cycle, but all have a result delay of one cycle.
However, the special case of using the result of a multiply instruction as the accumulate input to a following multiply-
accumulate instruction does not  incur a one-cycle penalty. As a result, repeated multiply-accumulate operations can run
at one per cycle, assuming all of the following conditions hold:
•the operations accumulate into the same register or register pair
•the multiplier and multiplicand operands come from other registers
Sequences such as the following can execute one instruction per cycle:
MLA R0,R1,R2,R3
MLA R3,R1,R2,R0
MLA R0,R1,R2,R3
MLA R3,R1,R2,R0
...
UMLAL R0,R1,R4,R5
UMLAL R2,R3,R6,R7
UMLAL R0,R1,R4,R5
UMLAL R2,R3,R6,R7
...
The multiplier requires its multiply operands on cycle n, requires its accumulate operand (if any) on cycle n+1, and
makes its result available on cycle n+2.
As a further example, the following sequence completes in 4 cycles:
RP2350 Datasheet
3.7. Cortex-M33 processor 139
ADD R2,R0,R1,LSL#23
MLA R3,R4,R5,R2
MOV R6,R3
The ADD would normally incur a one-cycle result-use penalty, but in this case its result is not needed until the second
cycle of the multiply-accumulate operation, eliminating the penalty.
3.7.4.9.4. Divide instructions
Let n be the difference between the bit positions of the most significant ones in the absolute value of the dividend and
the absolute value of the divisor. If n is negative (in which case the result will be zero), division takes 2 cycles.
Otherwise, division takes 4+ n/4 cycles, rounded down.
Using the result of division as input for the next instruction incurs a a one-cycle result-use penalty.
3.7.4.9.5. Register loads (LDR and LDM)
Loads execute in one cycle per register, plus a possible one-cycle result delay. Loads can slow down if the addressed
memory is not able to accept the read request immediately, for example because of contention with instruction
prefetch.
From the point of view of result delays, any register used in address generation counts as a source operand. For
examples, see Table 116 .
Table 116. Load
instruction source
operand examplesInstruction Source Operand Not a Source Operand
LDR R0,[R5,R6] R5, R6 R0
LDMIA R7,{R0-R3} R7 R0, R1, R2, R3
There is one cycle of result delay associated with the destination register of an LDR and with the last register in the
register list of an LDM or POP. For example, R7 has one cycle of result delay both in LDR R7,[R5,R6]  and in LDMIA R0,{R1-R7} .
The latter case incurs no result delay associated with R1 to R6.
Loading R15 does not cause any result delay; however, extra cycles will be taken as described in Section 3.7.4.9.7 .
3.7.4.9.6. Register stores (STR and STM)
Stores, including those which depend on the contents of three different registers such as STR R0,[R1,R2,LSL#2] , execute
in one cycle. Like loads, stores can slow down if the addressed memory is not able to accept the request immediately.
The registers involved in address generation, but not the register or registers being stored, count as source operands
from the point of view of result delays. For examples, see Table 117 .
Table 117. Register
stores source operand
examplesInstruction Source Operand Not a Source Operand
STR R5,[R6,R7] R6, R7 R5
STMFD R5!,{R0-R3} R5 R0, R1, R2, R3
3.7.4.9.7. Branches
This section covers any instruction that can change R15, including the following:
•MOV R15,Rx
RP2350 Datasheet
3.7. Cortex-M33 processor 140
•BNE
•BL
•BX
•LDR R15,… 
•POP {…,R15}
When a branch arises from a load ( LDR R15,… , LDMxx Rx,{… ,R15}, or POP {…,R15}), the basic time for the instruction is that
taken by the load instruction itself, as described in Section 3.7.4.9.5 .
For other instructions that can change R15 (MOV R15,Rx , B<cond>, BL, BX), the basic time for the instruction is zero.
The total time required for a branch that does  occur is the basic time + 2 + L + U- ( K & F ) cycles, and the time required for
a branch that does not  occur is the basic time + 1 - F cycles, where L, U, F, K are each 0 or 1 as described below:
L
1 when the branch arises from a load ( LDR R15,[R6] , LDMIA R13,{R0-R3,R15} , and so on); 0 otherwise.
U
1 when the all of following conditions are true:
•the target address of the branch is not word-aligned
•the instruction at that address is 32 bits long
•the instruction executed immediately prior to the branch is not POP or PUSH
If any of the above conditions are not true, U is 0.
F
indicates when the branch can be dual issued (or "folded") with the previous instruction, PrevInst  (the instruction
executed immediately prior to the branch). F is 1 when all of the following conditions are true:
•the branch instruction is B, B<cond>, or BX R14 (but not BX to any other register or MOV R15,R14 )
•PrevInst  is 16 bits long
•PrevInst  was executed sequentially (i.e., not itself branched to), or PrevInst  is word-aligned
•PrevInst  itself was not itself folded with a previous instruction
If any of the above conditions are not true, F is 0.
K
1 when it is known that the branch will execute prior to executing PrevInst; 0 otherwise. In other words, K is 1 unless
the branch is conditional and PrevInst sets the flags.
For example, the following delay loop takes 299 cycles:
10000002: MOVS R5,#100
10000004: SUBS R5,R5,#1
10000006: BNE 0x10000004
Those cycles come from the following timings:
•1 cycle for MOVS R5,#100
•1 cycle for each SUBS R5,R5,#1
•2 cycles each for the first 99 BNE instructions ( L=U=0, F=1, K=0)
•0 cycles for the last, non-taken, BNE (L=U=0, F=1, K=0, using the formula 1- F)
At a different alignment, the same delay loop takes 300 cycles:
RP2350 Datasheet
3.7. Cortex-M33 processor 141
10000000: MOVS R5,#100
10000002: SUBS R5,R5,#1
10000004: BNE 0x10000002
Those cycles come from the following timings:
•1 cycle for MOVS R5,#100 ;
•1 cycle for each SUBS R5,R5,#1 ;
•2 cycles for the first BNE (L=U=0, F=1, K=0);
•2 cycles each for the next 98 BNE instructions ( L=U=0, F=K=0);
•1 cycle for the last, non-taken, BNE (L=U=0, F=K=0, using the formula 1- F).
This longer delay loop also takes 300 cycles:
10000000: MOVS R5,#100
10000002: SUBS R5,R5,#1
10000004: MOV R1,R2
10000006: BNE 0x10000002
Those cycles come from the following timings:
•1 cycle for MOVS R5,#100 ;
•1 cycle for each SUBS R5,R5,#1 ;
•1 cycle for each MOV R1,R2 ;
•1 cycle each for the first 99 BNE instructions ( L=U=0, F=K=1);
•0 cycles for the last, non-taken, BNE (L=U=0, F=K=1; using the formula 1- F).
This example illustrates that, if you can contrive to place an instruction between the loop-end test and the branch, it can
potentially have zero net cost  in execution time.
Another optimisation is to try to ensure that a branch target is either word-aligned or is a 16-bit instruction. Any
instruction following a BL can be considered a branch target from this point of view as it is branched to by the return
instruction from the subroutine.
If space and cache permit, unrolling loops and inlining subroutines avoids the branch cost altogether.
A sequence of branches not taken will alternately take 0 cycles and 1 cycle. That is the same as a sequence of NOP
instructions, which can also be folded. However, this is not the same as sequence of instructions in an IT block that fail
their condition.
3.7.4.9.8. IT (if-then) blocks
Instructions within an IT block whose condition fails execute in one cycle.
Most instructions within an IT block whose condition succeeds take the number of cycles they would have taken in their
normal, unconditional state.
3.7.4.9.9. Dual issue
When a 16-bit instruction follows a NOP instruction (opcode 0xBF00, not 0x46C0), the instructions are folded , executing the
NOP in zero cycles. In some situations, this can help align a branch target to a word-aligned address without an
RP2350 Datasheet
3.7. Cortex-M33 processor 142
execution-time penalty.
When a 16-bit opcode follows an IT instruction, the IT instruction executes in zero cycles.
The Cortex-M33 core folds a NOP with the previous instruction ( PrevInst ) if all of the following conditions are true:
•PrevInst  is 16 bits long
•PrevInst  was executed sequentially (not itself branched to) or PrevInst  is word-aligned
•PrevInst  was not itself folded with a previous instruction
Branches not taken are in this sense similar to NOP instructions: they can be folded according to the same rule. For
further detail on when taken and not taken branches are folded, see Section 3.7.4.9.7 .
When two multi-cycle instructions are folded, at most one cycle can overlap between the instructions.
3.7.4.9.10. Floating-point coprocessor operations
This section describes operations involving the single-precision floating-point coprocessor (FPU). For timings relating to
the GPIO coprocessor, the double-precision coprocessor, and the redundancy coprocessor, see Section 3.7.4.9.11  and
the detailed descriptions of those coprocessors elsewhere in this document.
Issuing a floating-point instruction occupies the integer core for one cycle. After that, the integer core can proceed with
other non-FPU operations without interruption.
Attempting to issue another FPU instruction stalls execution until the FPU is ready to accept the FPU instruction.
The following list details the timings of various FPU instructions:
•VADD.F32 , VSUB.F32  and VMUL.F32  can execute in one cycle, but have an additional cycle of result delay. As a result, the
following example sequence executes at two cycles per instruction:
VADD.F32 s0,s0,s2
VADD.F32 s0,s0,s3
VADD.F32 s0,s0,s4
VADD.F32 s0,s0,s5
...
The following interleaved example, however, executes at one cycle per instruction:
VADD.F32 s0,s0,s2
VADD.F32 s1,s1,s3
VADD.F32 s0,s0,s4
VADD.F32 s1,s1,s5
...
Furthermore, you can interleave VADD.F32 , VSUB.F32  and VMUL.F32  instructions arbitrarily to execute in one cycle, as
long as no instruction depends on the result of its predecessor.
•VMLA.F32  and VFMA.F32  occupy the FPU for 3 cycles, plus one cycle of result delay.
However, consecutive  VMLA.F32  or VFMA.F32  instructions accumulating into the same register can run at one
instruction every three cycles.
•When the work can be interleaved, separate VMUL.F32  and VADD.F32  instructions are faster than a single VMLA.F32 
instruction.
•VDIV.F32  and VSQRT.F32  occupy the FPU for 14 cycles, plus one cycle of result delay.
•VMOV.F32 Sx,Ry  (move one word from integer register to coprocessor) takes one cycle.
RP2350 Datasheet
3.7. Cortex-M33 processor 143
•VMOV.F32 Rx,Sy  (move one word from coprocessor to integer register) takes one cycle plus one cycle of result delay.
•VMOV.F32 Sx,Sy  (move one word between coprocessor registers) takes one cycle.
•VMOV.F64 Dx,Ry,Rz  (move two words from integer registers to coprocessor) occupies the FPU for two cycles and the
integer core for one cycle.
•VMOV.F64 Rx,Ry,Dz  (move two words from coprocessor to integer registers) occupies both the FPU and the integer
core for two cycles.
3.7.4.9.11. Other coprocessor operations
A coprocessor can stall an operation if it is not ready. For more information, see the documentation for the specific
coprocessor.
The following list details the timings of various coprocessor instructions:
•Assuming that no stalls occur, a CDP instruction takes one cycle.
•An MCR instruction (move one word from integer register to coprocessor) takes one cycle.
•An MRC instruction (move one word from coprocessor to integer register) takes one cycle, plus one cycle of result
delay.
•An MCRR instruction (move two words from integer registers to coprocessor) takes one cycle.
•An MRRC instruction (move two words from coprocessor to integer registers) takes one cycle, plus one cycle of
result delay.
3.7.4.9.12. Instruction fetch
Each Cortex-M33 core has separate instruction and data buses ("Harvard architecture"). Each core has a bandwidth to
memory of 32 bits per cycle. Since each instruction is at most 32 bits long, for sequential code the instruction
prefetcher has enough bandwidth to ensure that the processor core always has instructions.
In RP2350, contention can occur when the instruction and data buses attempt to access data stored in memory
connected to the same downstream port of the AHB5 crossbar. For example, code running from the main SRAM might
attempt to load a literal stored nearby. That load might conflict with an instruction prefetch to the same SRAM. To
reduce the chance of this conflict, the main SRAM is striped into banks across groups of four words: words at
addresses that are different modulo 16 are stored in different banks.
Since the prefetcher typically runs about two words (8 bytes) ahead of execution, that means that an instruction that
reads 8 (modulo 16) bytes ahead of itself is liable to result in a conflict. For example, the following instruction, which
reads 40 bytes ahead (because here PC means the address of the next instruction), can sometimes incur a penalty of
one cycle:
LDR R8,[PC,#32] @ 32-bit instruction
3.7.4.10. Debug
Cortex-M33 debug functionality includes processor halt, single-step, processor core register access, Vector Catch,
unlimited software breakpoints, and full system memory access.
The processor also includes support for hardware breakpoints and watchpoints configured during implementation:
•A breakpoint unit supporting eight instruction comparators
•A watchpoint unit supporting four data watchpoint comparators
The Cortex-M33 processor supports system level debug authentication to control access from a debugger to resources
RP2350 Datasheet
3.7. Cortex-M33 processor 144
and memory. Authentication via the Armv8-M Security Extension can be used to allow a debugger full access to Non-
secure code and data without exposing any Secure information.
The processor implementation can be partitioned to place the debug components in a separate power domain from the
processor core and NVIC.
All debug registers are accessible by the D-AHB interface.
For more information, see the Armv8-M Architecture Reference Manual .
3.7.4.11. Data Watchpoint and Trace unit (DWT)
The DWT is a full configuration, containing four comparators ( DWT_COMP0  to DWT_COMP3 ). These comparators support the
following features:
•Hardware watchpoint support
•Hardware trace packet support
•CMPMATCH support for ETM/MTB/CTI triggers
•Cycle counter matching support ( DWT_COMP0  only)
•Instruction address matching support
•Data address matching support
•Data value matching support ( DWT_COMP1  only in a reduced DWT, DWT_COMP3  only in a Full DWT)
•Linked/limit matching support ( DWT_COMP1  and DWT_COMP3  only)
The DWT contains counters for:
•Cycles ( DWT_CYCCNT .CYCCNT)
•Folded Instructions (FOLDCNT)
•Additional cycles required to execute all load/store instructions (LSUCNT)
•Processor sleep cycles (SLEEPCNT)
•Additional cycles required to execute multi-cycle instructions and instruction fetch stalls (CPICNT)
•Cycles spent in exception processing (EXCCNT)
Before using DWT, set the DEMCR.TRCENA bit to 1.
The DWT provides periodic requests for protocol synchronization to the ITM and the TPIU.
3.7.4.12. Cross Trigger Interface (CTI)
The CTI enables the debug logic, MTB, and ETM to interact with each other and with other CoreSight components. This
is called cross triggering. For example, you can configure the CTI to generate an interrupt when the ETM trigger event
occurs or to start tracing when a DWT comparator match is detected.
The following figure shows the debug system components and the available trigger inputs and trigger outputs:
Figure 15  shows the components of the debug system.
RP2350 Datasheet
3.7. Cortex-M33 processor 145
Figure 15. Debug
system components
The following table shows how the CTI trigger inputs are connected to the Cortex-M33 processor:
Table 118. Trigger
signals to the CTISignal Description Connection Acknowledge, handshake
CTITRIGIN[7] ETM to CTI Pulsed
CTITRIGIN[6] ETM to CTI Pulsed
CTITRIGIN[5] ETM Event Output 1 ETM to CTI Pulsed
CTITRIGIN[4] ETM Event Output 0 or Comparator Output
3ETM/Processor to CTI Pulsed
CTITRIGIN[3] DWT Comparator Output 2 Processor to CTI Pulsed
CTITRIGIN[2] DWT Comparator Output 1 Processor to CTI Pulsed
CTITRIGIN[1] DWT Comparator Output 0 Processor to CTI Pulsed
CTITRIGIN[0] Processor Halted Processor to CTI Pulsed
The following table shows how the CTI trigger outputs are connected to the processor and ETM:
Table 119. Trigger
signals from the CTISignal Description Connection Acknowledge, handshake
CTITRIGOUT[
7]ETM Event Input 3 CTI to ETM Pulsed
CTITRIGOUT[
6]ETM Event Input 2 CTI to ETM Pulsed
CTITRIGOUT[
5]ETM Event Input 1 or MTB Trace stop CTI to ETM or MTB Pulsed
CTITRIGOUT[
4]ETM Event Input 1 or MTB Trace start CTI to ETM or MTB Pulsed
CTITRIGOUT[
3]Interrupt request 1 CTI to system Acknowledged by writing to
the CTIINTACK  register in ISR
CTITRIGOUT[
2]Interrupt request 0 CTI to system Acknowledged by writing to
the CTIINTACK  register in ISR
CTITRIGOUT[
1]Processor Restart CTI to Processor Processor Restarted
RP2350 Datasheet
3.7. Cortex-M33 processor 146
Signal Description Connection Acknowledge, handshake
CTITRIGOUT[
0]Processor debug request CTI to Processor Acknowledged by the
debugger writing to the
CTIINTACK  register
After the processor is halted using CTI Trigger Output 0, the Processor Debug Request signal remains asserted. The
debugger must write to CTIINTACK  to clear the halting request before restarting the processor.
After asserting an interrupt using the CTI Trigger Output 1 or 2, the Interrupt Service Routine (ISR) must clear the
interrupt request by writing to the CTI Interrupt Acknowledge, CTIINTACK .
Interrupt requests from the CTI to the system are only asserted when invasive debug is enabled in the processor.
3.7.4.12.1. CTI programmers model
The following table shows the CTI programmable registers, with address offset, type, and reset value for each register.
See the Arm CoreSightTM SoC-400 Technical Reference Manual  for register descriptions.
Table 120. Cortex-M33
CTI register summaryAddress offset Name Type Reset value Description
0xE0042000 CTICONTROL RW 0x00000000 CTI Control Register
0xE0042010 CTIINTACK WO UNKNOWN CTI Interrupt Acknowledge
Register
0xE0042014 CTIAPPSET RW 0x00000000 CTI Application Trigger Set
Register
0xE0042018 CTIAPPCLEAR RW 0x00000000 CTI Application Trigger Clear
Register
0xE004201C CTIAPPPULSE WO UNKNOWN CTI Application Pulse Register
0xE0042020-0xE004203C CTIINEN[7:0] RW 0x00000000 CTI Trigger to Channel Enable
Registers
0xE00420A0-0xE00420BC CTIOUTEN[7:0] RW 0x00000000 CTI Channel to Trigger Enable
Registers
0xE0042130 CTITRIGINSTATUS RO 0x00000000 CTI Trigger In Status Register
0xE0042134 CTITRIGOUTSTATUS RO 0x00000000 CTI Trigger Out Status Register
0xE0042138 CTICHINSTATUS RO 0x00000000 CTI Channel In Status Register
0xE0042140 CTIGATE RW 0x0000000F Enable CTI Channel Gate Register
0xE0042144 ASICCTL RW 0x00000000 External Multiplexer Control
Register
0xE0042EE4 ITCHOUT WO UNKNOWN Integration Test Channel Output
Register
0xE0042EE8 ITTRIGOUT WO UNKNOWN Integration Test Trigger Output
Register
0xE0042EF4 ITCHIN RO 0x00000000 Integration Test Channel Input
Register
0xE0042F00 ITCTRL RW 0x00000000 Integration Mode Control Register
0xE0042FC8 DEVID RO 0x00040800 Device Configuration Register
0xE0042FBC DEVARCH RO 0x47701A14 Device Architecture Register
RP2350 Datasheet
3.7. Cortex-M33 processor 147
Address offset Name Type Reset value Description
0xE0042FCC DEVTYPE RO 0x00000014 Device Type Identifier Register
0xE0042FD0 PIDR4 RO 0x00000004 Peripheral ID4 Register
0xE0042FD4 PIDR5 RO 0x00000000 Peripheral ID5 Register
0xE0042FD8 PIDR6 RO 0x00000000 Peripheral ID6 Register
0xE0042FDC PIDR7 RO 0x00000000 Peripheral ID7 Register
0xE0042FE0 PIDR0 RO 0x00000021 Peripheral ID0 Register
0xE0042FE4 PIDR1 RO 0x000000BD Peripheral ID1 Register
0xE0042FE8 PIDR2 RO 0x0000000B Peripheral ID2 Register
0xE0042FEC PIDR3 RO 0x00000001 Peripheral ID3 Register
0xE0042FF0 CIDR0 RO 0x0000000D Component ID0 Register
0xE0042FF4 CIDR1 RO 0x00000090 Component ID1 Register
0xE0042FF8 CIDR2 RO 0x00000005 Component ID2 Register
0xE0042FFC CIDR3 RO 0x000000B1 Component ID3 Register
3.7.5. List of registers
The Arm Cortex-M33 registers start at a base address of 0xe0000000 , defined as PPB_BASE  in the SDK.
Table 121. List of M33
registersOffset Name Info
0x00000 ITM_STIM0 ITM Stimulus Port Register 0
0x00004 ITM_STIM1 ITM Stimulus Port Register 1
0x00008 ITM_STIM2 ITM Stimulus Port Register 2
0x0000c ITM_STIM3 ITM Stimulus Port Register 3
0x00010 ITM_STIM4 ITM Stimulus Port Register 4
0x00014 ITM_STIM5 ITM Stimulus Port Register 5
0x00018 ITM_STIM6 ITM Stimulus Port Register 6
0x0001c ITM_STIM7 ITM Stimulus Port Register 7
0x00020 ITM_STIM8 ITM Stimulus Port Register 8
0x00024 ITM_STIM9 ITM Stimulus Port Register 9
0x00028 ITM_STIM10 ITM Stimulus Port Register 10
0x0002c ITM_STIM11 ITM Stimulus Port Register 11
0x00030 ITM_STIM12 ITM Stimulus Port Register 12
0x00034 ITM_STIM13 ITM Stimulus Port Register 13
0x00038 ITM_STIM14 ITM Stimulus Port Register 14
0x0003c ITM_STIM15 ITM Stimulus Port Register 15
0x00040 ITM_STIM16 ITM Stimulus Port Register 16
0x00044 ITM_STIM17 ITM Stimulus Port Register 17
RP2350 Datasheet
3.7. Cortex-M33 processor 148
Offset Name Info
0x00048 ITM_STIM18 ITM Stimulus Port Register 18
0x0004c ITM_STIM19 ITM Stimulus Port Register 19
0x00050 ITM_STIM20 ITM Stimulus Port Register 20
0x00054 ITM_STIM21 ITM Stimulus Port Register 21
0x00058 ITM_STIM22 ITM Stimulus Port Register 22
0x0005c ITM_STIM23 ITM Stimulus Port Register 23
0x00060 ITM_STIM24 ITM Stimulus Port Register 24
0x00064 ITM_STIM25 ITM Stimulus Port Register 25
0x00068 ITM_STIM26 ITM Stimulus Port Register 26
0x0006c ITM_STIM27 ITM Stimulus Port Register 27
0x00070 ITM_STIM28 ITM Stimulus Port Register 28
0x00074 ITM_STIM29 ITM Stimulus Port Register 29
0x00078 ITM_STIM30 ITM Stimulus Port Register 30
0x0007c ITM_STIM31 ITM Stimulus Port Register 31
0x00e00 ITM_TER0 Provide an individual enable bit for each ITM_STIM register
0x00e40 ITM_TPR Controls which stimulus ports can be accessed by unprivileged
code
0x00e80 ITM_TCR Configures and controls transfers through the ITM interface
0x00ef0 INT_ATREADY Integration Mode: Read ATB Ready
0x00ef8 INT_ATVALID Integration Mode: Write ATB Valid
0x00f00 ITM_ITCTRL Integration Mode Control Register
0x00fbc ITM_DEVARCH Provides CoreSight discovery information for the ITM
0x00fcc ITM_DEVTYPE Provides CoreSight discovery information for the ITM
0x00fd0 ITM_PIDR4 Provides CoreSight discovery information for the ITM
0x00fd4 ITM_PIDR5 Provides CoreSight discovery information for the ITM
0x00fd8 ITM_PIDR6 Provides CoreSight discovery information for the ITM
0x00fdc ITM_PIDR7 Provides CoreSight discovery information for the ITM
0x00fe0 ITM_PIDR0 Provides CoreSight discovery information for the ITM
0x00fe4 ITM_PIDR1 Provides CoreSight discovery information for the ITM
0x00fe8 ITM_PIDR2 Provides CoreSight discovery information for the ITM
0x00fec ITM_PIDR3 Provides CoreSight discovery information for the ITM
0x00ff0 ITM_CIDR0 Provides CoreSight discovery information for the ITM
0x00ff4 ITM_CIDR1 Provides CoreSight discovery information for the ITM
0x00ff8 ITM_CIDR2 Provides CoreSight discovery information for the ITM
0x00ffc ITM_CIDR3 Provides CoreSight discovery information for the ITM
RP2350 Datasheet
3.7. Cortex-M33 processor 149
Offset Name Info
0x01000 DWT_CTRL Provides configuration and status information for the DWT unit,
and used to control features of the unit
0x01004 DWT_CYCCNT Shows or sets the value of the processor cycle counter, CYCCNT
0x0100c DWT_EXCCNT Counts the total cycles spent in exception processing
0x01014 DWT_LSUCNT Increments on the additional cycles required to execute all load
or store instructions
0x01018 DWT_FOLDCNT Increments on the additional cycles required to execute all load
or store instructions
0x01020 DWT_COMP0 Provides a reference value for use by watchpoint comparator 0
0x01028 DWT_FUNCTION0 Controls the operation of watchpoint comparator 0
0x01030 DWT_COMP1 Provides a reference value for use by watchpoint comparator 1
0x01038 DWT_FUNCTION1 Controls the operation of watchpoint comparator 1
0x01040 DWT_COMP2 Provides a reference value for use by watchpoint comparator 2
0x01048 DWT_FUNCTION2 Controls the operation of watchpoint comparator 2
0x01050 DWT_COMP3 Provides a reference value for use by watchpoint comparator 3
0x01058 DWT_FUNCTION3 Controls the operation of watchpoint comparator 3
0x01fbc DWT_DEVARCH Provides CoreSight discovery information for the DWT
0x01fcc DWT_DEVTYPE Provides CoreSight discovery information for the DWT
0x01fd0 DWT_PIDR4 Provides CoreSight discovery information for the DWT
0x01fd4 DWT_PIDR5 Provides CoreSight discovery information for the DWT
0x01fd8 DWT_PIDR6 Provides CoreSight discovery information for the DWT
0x01fdc DWT_PIDR7 Provides CoreSight discovery information for the DWT
0x01fe0 DWT_PIDR0 Provides CoreSight discovery information for the DWT
0x01fe4 DWT_PIDR1 Provides CoreSight discovery information for the DWT
0x01fe8 DWT_PIDR2 Provides CoreSight discovery information for the DWT
0x01fec DWT_PIDR3 Provides CoreSight discovery information for the DWT
0x01ff0 DWT_CIDR0 Provides CoreSight discovery information for the DWT
0x01ff4 DWT_CIDR1 Provides CoreSight discovery information for the DWT
0x01ff8 DWT_CIDR2 Provides CoreSight discovery information for the DWT
0x01ffc DWT_CIDR3 Provides CoreSight discovery information for the DWT
0x02000 FP_CTRL Provides FPB implementation information, and the global enable
for the FPB unit
0x02004 FP_REMAP Indicates whether the implementation supports Flash Patch
remap and, if it does, holds the target address for remap
0x02008 FP_COMP0 Holds an address for comparison. The effect of the match
depends on the configuration of the FPB and whether the
comparator is an instruction address comparator or a literal
address comparator
RP2350 Datasheet
3.7. Cortex-M33 processor 150
Offset Name Info
0x0200c FP_COMP1 Holds an address for comparison. The effect of the match
depends on the configuration of the FPB and whether the
comparator is an instruction address comparator or a literal
address comparator
0x02010 FP_COMP2 Holds an address for comparison. The effect of the match
depends on the configuration of the FPB and whether the
comparator is an instruction address comparator or a literal
address comparator
0x02014 FP_COMP3 Holds an address for comparison. The effect of the match
depends on the configuration of the FPB and whether the
comparator is an instruction address comparator or a literal
address comparator
0x02018 FP_COMP4 Holds an address for comparison. The effect of the match
depends on the configuration of the FPB and whether the
comparator is an instruction address comparator or a literal
address comparator
0x0201c FP_COMP5 Holds an address for comparison. The effect of the match
depends on the configuration of the FPB and whether the
comparator is an instruction address comparator or a literal
address comparator
0x02020 FP_COMP6 Holds an address for comparison. The effect of the match
depends on the configuration of the FPB and whether the
comparator is an instruction address comparator or a literal
address comparator
0x02024 FP_COMP7 Holds an address for comparison. The effect of the match
depends on the configuration of the FPB and whether the
comparator is an instruction address comparator or a literal
address comparator
0x02fbc FP_DEVARCH Provides CoreSight discovery information for the FPB
0x02fcc FP_DEVTYPE Provides CoreSight discovery information for the FPB
0x02fd0 FP_PIDR4 Provides CoreSight discovery information for the FP
0x02fd4 FP_PIDR5 Provides CoreSight discovery information for the FP
0x02fd8 FP_PIDR6 Provides CoreSight discovery information for the FP
0x02fdc FP_PIDR7 Provides CoreSight discovery information for the FP
0x02fe0 FP_PIDR0 Provides CoreSight discovery information for the FP
0x02fe4 FP_PIDR1 Provides CoreSight discovery information for the FP
0x02fe8 FP_PIDR2 Provides CoreSight discovery information for the FP
0x02fec FP_PIDR3 Provides CoreSight discovery information for the FP
0x02ff0 FP_CIDR0 Provides CoreSight discovery information for the FP
0x02ff4 FP_CIDR1 Provides CoreSight discovery information for the FP
0x02ff8 FP_CIDR2 Provides CoreSight discovery information for the FP
0x02ffc FP_CIDR3 Provides CoreSight discovery information for the FP
0x0e004 ICTR Provides information about the interrupt controller
RP2350 Datasheet
3.7. Cortex-M33 processor 151
Offset Name Info
0x0e008 ACTLR Provides IMPLEMENTATION DEFINED configuration and control
options
0x0e010 SYST_CSR SysTick Control and Status Register
0x0e014 SYST_RVR SysTick Reload Value Register
0x0e018 SYST_CVR SysTick Current Value Register
0x0e01c SYST_CALIB SysTick Calibration Value Register
0x0e100 NVIC_ISER0 Enables or reads the enabled state of each group of 32 interrupts
0x0e104 NVIC_ISER1 Enables or reads the enabled state of each group of 32 interrupts
0x0e180 NVIC_ICER0 Clears or reads the enabled state of each group of 32 interrupts
0x0e184 NVIC_ICER1 Clears or reads the enabled state of each group of 32 interrupts
0x0e200 NVIC_ISPR0 Enables or reads the pending state of each group of 32 interrupts
0x0e204 NVIC_ISPR1 Enables or reads the pending state of each group of 32 interrupts
0x0e280 NVIC_ICPR0 Clears or reads the pending state of each group of 32 interrupts
0x0e284 NVIC_ICPR1 Clears or reads the pending state of each group of 32 interrupts
0x0e300 NVIC_IABR0 For each group of 32 interrupts, shows the active state of each
interrupt
0x0e304 NVIC_IABR1 For each group of 32 interrupts, shows the active state of each
interrupt
0x0e380 NVIC_ITNS0 For each group of 32 interrupts, determines whether each
interrupt targets Non-secure or Secure state
0x0e384 NVIC_ITNS1 For each group of 32 interrupts, determines whether each
interrupt targets Non-secure or Secure state
0x0e400 NVIC_IPR0 Sets or reads interrupt priorities
0x0e404 NVIC_IPR1 Sets or reads interrupt priorities
0x0e408 NVIC_IPR2 Sets or reads interrupt priorities
0x0e40c NVIC_IPR3 Sets or reads interrupt priorities
0x0e410 NVIC_IPR4 Sets or reads interrupt priorities
0x0e414 NVIC_IPR5 Sets or reads interrupt priorities
0x0e418 NVIC_IPR6 Sets or reads interrupt priorities
0x0e41c NVIC_IPR7 Sets or reads interrupt priorities
0x0e420 NVIC_IPR8 Sets or reads interrupt priorities
0x0e424 NVIC_IPR9 Sets or reads interrupt priorities
0x0e428 NVIC_IPR10 Sets or reads interrupt priorities
0x0e42c NVIC_IPR11 Sets or reads interrupt priorities
0x0e430 NVIC_IPR12 Sets or reads interrupt priorities
0x0e434 NVIC_IPR13 Sets or reads interrupt priorities
0x0e438 NVIC_IPR14 Sets or reads interrupt priorities
RP2350 Datasheet
3.7. Cortex-M33 processor 152
Offset Name Info
0x0e43c NVIC_IPR15 Sets or reads interrupt priorities
0x0ed00 CPUID Provides identification information for the PE, including an
implementer code for the device and a device ID number
0x0ed04 ICSR Controls and provides status information for NMI, PendSV,
SysTick and interrupts
0x0ed08 VTOR Vector Table Offset Register
0x0ed0c AIRCR Application Interrupt and Reset Control Register
0x0ed10 SCR System Control Register
0x0ed14 CCR Sets or returns configuration and control data
0x0ed18 SHPR1 Sets or returns priority for system handlers 4 - 7
0x0ed1c SHPR2 Sets or returns priority for system handlers 8 - 11
0x0ed20 SHPR3 Sets or returns priority for system handlers 12 - 15
0x0ed24 SHCSR Provides access to the active and pending status of system
exceptions
0x0ed28 CFSR Contains the three Configurable Fault Status Registers.
31:16 UFSR: Provides information on UsageFault exceptions
15:8 BFSR: Provides information on BusFault exceptions
7:0 MMFSR: Provides information on MemManage exceptions
0x0ed2c HFSR Shows the cause of any HardFaults
0x0ed30 DFSR Shows which debug event occurred
0x0ed34 MMFAR Shows the address of the memory location that caused an MPU
fault
0x0ed38 BFAR Shows the address associated with a precise data access
BusFault
0x0ed40 ID_PFR0 Gives top-level information about the instruction set supported
by the PE
0x0ed44 ID_PFR1 Gives information about the programmers' model and Extensions
support
0x0ed48 ID_DFR0 Provides top level information about the debug system
0x0ed4c ID_AFR0 Provides information about the IMPLEMENTATION DEFINED
features of the PE
0x0ed50 ID_MMFR0 Provides information about the implemented memory model and
memory management support
0x0ed54 ID_MMFR1 Provides information about the implemented memory model and
memory management support
0x0ed58 ID_MMFR2 Provides information about the implemented memory model and
memory management support
0x0ed5c ID_MMFR3 Provides information about the implemented memory model and
memory management support
RP2350 Datasheet
3.7. Cortex-M33 processor 153
Offset Name Info
0x0ed60 ID_ISAR0 Provides information about the instruction set implemented by
the PE
0x0ed64 ID_ISAR1 Provides information about the instruction set implemented by
the PE
0x0ed68 ID_ISAR2 Provides information about the instruction set implemented by
the PE
0x0ed6c ID_ISAR3 Provides information about the instruction set implemented by
the PE
0x0ed70 ID_ISAR4 Provides information about the instruction set implemented by
the PE
0x0ed74 ID_ISAR5 Provides information about the instruction set implemented by
the PE
0x0ed7c CTR Provides information about the architecture of the caches. CTR
is RES0 if CLIDR is zero.
0x0ed88 CPACR Specifies the access privileges for coprocessors and the FP
Extension
0x0ed8c NSACR Defines the Non-secure access permissions for both the FP
Extension and coprocessors CP0 to CP7
0x0ed90 MPU_TYPE The MPU Type Register indicates how many regions the MPU
`FTSSS supports
0x0ed94 MPU_CTRL Enables the MPU and, when the MPU is enabled, controls
whether the default memory map is enabled as a background
region for privileged accesses, and whether the MPU is enabled
for HardFaults, NMIs, and exception handlers when FAULTMASK
is set to 1
0x0ed98 MPU_RNR Selects the region currently accessed by MPU_RBAR and
MPU_RLAR
0x0ed9c MPU_RBAR Provides indirect read and write access to the base address of
the currently selected MPU region `FTSSS
0x0eda0 MPU_RLAR Provides indirect read and write access to the limit address of
the currently selected MPU region `FTSSS
0x0eda4 MPU_RBAR_A1 Provides indirect read and write access to the base address of
the MPU region selected by MPU_RNR[7:2]:(1[1:0]) `FTSSS
0x0eda8 MPU_RLAR_A1 Provides indirect read and write access to the limit address of
the currently selected MPU region selected by
MPU_RNR[7:2]:(1[1:0]) `FTSSS
0x0edac MPU_RBAR_A2 Provides indirect read and write access to the base address of
the MPU region selected by MPU_RNR[7:2]:(2[1:0]) `FTSSS
0x0edb0 MPU_RLAR_A2 Provides indirect read and write access to the limit address of
the currently selected MPU region selected by
MPU_RNR[7:2]:(2[1:0]) `FTSSS
0x0edb4 MPU_RBAR_A3 Provides indirect read and write access to the base address of
the MPU region selected by MPU_RNR[7:2]:(3[1:0]) `FTSSS
RP2350 Datasheet
3.7. Cortex-M33 processor 154
Offset Name Info
0x0edb8 MPU_RLAR_A3 Provides indirect read and write access to the limit address of
the currently selected MPU region selected by
MPU_RNR[7:2]:(3[1:0]) `FTSSS
0x0edc0 MPU_MAIR0 Along with MPU_MAIR1, provides the memory attribute
encodings corresponding to the AttrIndex values
0x0edc4 MPU_MAIR1 Along with MPU_MAIR0, provides the memory attribute
encodings corresponding to the AttrIndex values
0x0edd0 SAU_CTRL Allows enabling of the Security Attribution Unit
0x0edd4 SAU_TYPE Indicates the number of regions implemented by the Security
Attribution Unit
0x0edd8 SAU_RNR Selects the region currently accessed by SAU_RBAR and
SAU_RLAR
0x0eddc SAU_RBAR Provides indirect read and write access to the base address of
the currently selected SAU region
0x0ede0 SAU_RLAR Provides indirect read and write access to the limit address of
the currently selected SAU region
0x0ede4 SFSR Provides information about any security related faults
0x0ede8 SFAR Shows the address of the memory location that caused a
Security violation
0x0edf0 DHCSR Controls halting debug
0x0edf4 DCRSR With the DCRDR, provides debug access to the general-purpose
registers, special-purpose registers, and the FP extension
registers. A write to the DCRSR specifies the register to transfer,
whether the transfer is a read or write, and starts the transfer
0x0edf8 DCRDR With the DCRSR, provides debug access to the general-purpose
registers, special-purpose registers, and the FP Extension
registers. If the Main Extension is implemented, it can also be
used for message passing between an external debugger and a
debug agent running on the PE
0x0edfc DEMCR Manages vector catch behavior and DebugMonitor handling
when debugging
0x0ee08 DSCSR Provides control and status information for Secure debug
0x0ef00 STIR Provides a mechanism for software to generate an interrupt
0x0ef34 FPCCR Holds control data for the Floating-point extension
0x0ef38 FPCAR Holds the location of the unpopulated floating-point register
space allocated on an exception stack frame
0x0ef3c FPDSCR Holds the default values for the floating-point status control data
that the PE assigns to the FPSCR when it creates a new floating-
point context
0x0ef40 MVFR0 Describes the features provided by the Floating-point Extension
0x0ef44 MVFR1 Describes the features provided by the Floating-point Extension
0x0ef48 MVFR2 Describes the features provided by the Floating-point Extension
0x0efbc DDEVARCH Provides CoreSight discovery information for the SCS
RP2350 Datasheet
3.7. Cortex-M33 processor 155
Offset Name Info
0x0efcc DDEVTYPE Provides CoreSight discovery information for the SCS
0x0efd0 DPIDR4 Provides CoreSight discovery information for the SCS
0x0efd4 DPIDR5 Provides CoreSight discovery information for the SCS
0x0efd8 DPIDR6 Provides CoreSight discovery information for the SCS
0x0efdc DPIDR7 Provides CoreSight discovery information for the SCS
0x0efe0 DPIDR0 Provides CoreSight discovery information for the SCS
0x0efe4 DPIDR1 Provides CoreSight discovery information for the SCS
0x0efe8 DPIDR2 Provides CoreSight discovery information for the SCS
0x0efec DPIDR3 Provides CoreSight discovery information for the SCS
0x0eff0 DCIDR0 Provides CoreSight discovery information for the SCS
0x0eff4 DCIDR1 Provides CoreSight discovery information for the SCS
0x0eff8 DCIDR2 Provides CoreSight discovery information for the SCS
0x0effc DCIDR3 Provides CoreSight discovery information for the SCS
0x41004 TRCPRGCTLR Programming Control Register
0x4100c TRCSTATR The TRCSTATR indicates the ETM-Teal status
0x41010 TRCCONFIGR The TRCCONFIGR sets the basic tracing options for the trace
unit
0x41020 TRCEVENTCTL0R The TRCEVENTCTL0R controls the tracing of events in the trace
stream. The events also drive the ETM-Teal external outputs.
0x41024 TRCEVENTCTL1R The TRCEVENTCTL1R controls how the events selected by
TRCEVENTCTL0R behave
0x4102c TRCSTALLCTLR The TRCSTALLCTLR enables ETM-Teal to stall the processor if
the ETM-Teal FIFO goes over the programmed level to minimize
risk of overflow
0x41030 TRCTSCTLR The TRCTSCTLR controls the insertion of global timestamps into
the trace stream. A timestamp is always inserted into the
instruction trace stream
0x41034 TRCSYNCPR The TRCSYNCPR specifies the period of trace synchronization of
the trace streams. TRCSYNCPR defines a number of bytes of
trace between requests for trace synchronization. This value is
always a power of two
0x41038 TRCCCCTLR The TRCCCCTLR sets the threshold value for instruction trace
cycle counting. The threshold represents the minimum interval
between cycle count trace packets
0x41080 TRCVICTLR The TRCVICTLR controls instruction trace filtering
0x41140 TRCCNTRLDVR0 The TRCCNTRLDVR defines the reload value for the reduced
function counter
0x41180 TRCIDR8 TRCIDR8
0x41184 TRCIDR9 TRCIDR9
0x41188 TRCIDR10 TRCIDR10
RP2350 Datasheet
3.7. Cortex-M33 processor 156
Offset Name Info
0x4118c TRCIDR11 TRCIDR11
0x41190 TRCIDR12 TRCIDR12
0x41194 TRCIDR13 TRCIDR13
0x411c0 TRCIMSPEC The TRCIMSPEC shows the presence of any IMPLEMENTATION
SPECIFIC features, and enables any features that are provided
0x411e0 TRCIDR0 TRCIDR0
0x411e4 TRCIDR1 TRCIDR1
0x411e8 TRCIDR2 TRCIDR2
0x411ec TRCIDR3 TRCIDR3
0x411f0 TRCIDR4 TRCIDR4
0x411f4 TRCIDR5 TRCIDR5
0x411f8 TRCIDR6 TRCIDR6
0x411fc TRCIDR7 TRCIDR7
0x41208 TRCRSCTLR2 The TRCRSCTLR controls the trace resources
0x4120c TRCRSCTLR3 The TRCRSCTLR controls the trace resources
0x412a0 TRCSSCSR Controls the corresponding single-shot comparator resource
0x412c0 TRCSSPCICR Selects the PE comparator inputs for Single-shot control
0x41310 TRCPDCR Requests the system to provide power to the trace unit
0x41314 TRCPDSR Returns the following information about the trace unit: - OS Lock
status. - Core power domain status. - Power interruption status
0x41ee4 TRCITATBIDR Trace Intergration ATB Identification Register
0x41ef4 TRCITIATBINR Trace Integration Instruction ATB In Register
0x41efc TRCITIATBOUTR Trace Integration Instruction ATB Out Register
0x41fa0 TRCCLAIMSET Claim Tag Set Register
0x41fa4 TRCCLAIMCLR Claim Tag Clear Register
0x41fb8 TRCAUTHSTATUS Returns the level of tracing that the trace unit can support
0x41fbc TRCDEVARCH TRCDEVARCH
0x41fc8 TRCDEVID TRCDEVID
0x41fcc TRCDEVTYPE TRCDEVTYPE
0x41fd0 TRCPIDR4 TRCPIDR4
0x41fd4 TRCPIDR5 TRCPIDR5
0x41fd8 TRCPIDR6 TRCPIDR6
0x41fdc TRCPIDR7 TRCPIDR7
0x41fe0 TRCPIDR0 TRCPIDR0
0x41fe4 TRCPIDR1 TRCPIDR1
0x41fe8 TRCPIDR2 TRCPIDR2
RP2350 Datasheet
3.7. Cortex-M33 processor 157
Offset Name Info
0x41fec TRCPIDR3 TRCPIDR3
0x41ff0 TRCCIDR0 TRCCIDR0
0x41ff4 TRCCIDR1 TRCCIDR1
0x41ff8 TRCCIDR2 TRCCIDR2
0x41ffc TRCCIDR3 TRCCIDR3
0x42000 CTICONTROL CTI Control Register
0x42010 CTIINTACK CTI Interrupt Acknowledge Register
0x42014 CTIAPPSET CTI Application Trigger Set Register
0x42018 CTIAPPCLEAR CTI Application Trigger Clear Register
0x4201c CTIAPPPULSE CTI Application Pulse Register
0x42020 CTIINEN0 CTI Trigger to Channel Enable Registers
0x42024 CTIINEN1 CTI Trigger to Channel Enable Registers
0x42028 CTIINEN2 CTI Trigger to Channel Enable Registers
0x4202c CTIINEN3 CTI Trigger to Channel Enable Registers
0x42030 CTIINEN4 CTI Trigger to Channel Enable Registers
0x42034 CTIINEN5 CTI Trigger to Channel Enable Registers
0x42038 CTIINEN6 CTI Trigger to Channel Enable Registers
0x4203c CTIINEN7 CTI Trigger to Channel Enable Registers
0x420a0 CTIOUTEN0 CTI Trigger to Channel Enable Registers
0x420a4 CTIOUTEN1 CTI Trigger to Channel Enable Registers
0x420a8 CTIOUTEN2 CTI Trigger to Channel Enable Registers
0x420ac CTIOUTEN3 CTI Trigger to Channel Enable Registers
0x420b0 CTIOUTEN4 CTI Trigger to Channel Enable Registers
0x420b4 CTIOUTEN5 CTI Trigger to Channel Enable Registers
0x420b8 CTIOUTEN6 CTI Trigger to Channel Enable Registers
0x420bc CTIOUTEN7 CTI Trigger to Channel Enable Registers
0x42130 CTITRIGINSTATUS CTI Trigger to Channel Enable Registers
0x42134 CTITRIGOUTSTATUS CTI Trigger In Status Register
0x42138 CTICHINSTATUS CTI Channel In Status Register
0x42140 CTIGATE Enable CTI Channel Gate register
0x42144 ASICCTL External Multiplexer Control register
0x42ee4 ITCHOUT Integration Test Channel Output register
0x42ee8 ITTRIGOUT Integration Test Trigger Output register
0x42ef4 ITCHIN Integration Test Channel Input register
0x42f00 ITCTRL Integration Mode Control register
0x42fbc DEVARCH Device Architecture register
RP2350 Datasheet
3.7. Cortex-M33 processor 158
Offset Name Info
0x42fc8 DEVID Device Configuration register
0x42fcc DEVTYPE Device Type Identifier register
0x42fd0 PIDR4 CoreSight Periperal ID4
0x42fd4 PIDR5 CoreSight Periperal ID5
0x42fd8 PIDR6 CoreSight Periperal ID6
0x42fdc PIDR7 CoreSight Periperal ID7
0x42fe0 PIDR0 CoreSight Periperal ID0
0x42fe4 PIDR1 CoreSight Periperal ID1
0x42fe8 PIDR2 CoreSight Periperal ID2
0x42fec PIDR3 CoreSight Periperal ID3
0x42ff0 CIDR0 CoreSight Component ID0
0x42ff4 CIDR1 CoreSight Component ID1
0x42ff8 CIDR2 CoreSight Component ID2
0x42ffc CIDR3 CoreSight Component ID3
M33 : ITM_STIM0, ITM_STIM1, …, ITM_STIM30, ITM_STIM31 Registers
Offsets : 0x00000, 0x00004, …, 0x00078, 0x0007c
Description
Provides the interface for generating Instrumentation packets
Table 122.
ITM_STIM0,
ITM_STIM1, …,
ITM_STIM30,
ITM_STIM31 RegistersBits Description Type Reset
31:0 STIMULUS : Data to write to the Stimulus Port FIFO, for forwarding as an
Instrumentation packet. The size of write access determines the type of
Instrumentation packet generated.RW 0x00000000
M33 : ITM_TER0 Register
Offset : 0x00e00
Description
Provide an individual enable bit for each ITM_STIM register
Table 123. ITM_TER0
RegisterBits Description Type Reset
31:0 STIMENA : For STIMENA[m] in ITM_TER*n, controls whether ITM_STIM(32*n +
m) is enabledRW 0x00000000
M33 : ITM_TPR Register
Offset : 0x00e40
Description
Controls which stimulus ports can be accessed by unprivileged code
Table 124. ITM_TPR
RegisterBits Description Type Reset
31:4 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 159
Bits Description Type Reset
3:0 PRIVMASK : Bit mask to enable tracing on ITM stimulus ports RW 0x0
M33 : ITM_TCR Register
Offset : 0x00e80
Description
Configures and controls transfers through the ITM interface
Table 125. ITM_TCR
RegisterBits Description Type Reset
31:24 Reserved. - -
23 BUSY : Indicates whether the ITM is currently processing events RO 0x0
22:16 TRACEBUSID : Identifier for multi-source trace stream formatting. If multi-
source trace is in use, the debugger must write a unique non-zero trace ID
value to this fieldRW 0x00
15:12 Reserved. - -
11:10 GTSFREQ : Defines how often the ITM generates a global timestamp, based on
the global timestamp clock frequency, or disables generation of global
timestampsRW 0x0
9:8 TSPRESCALE : Local timestamp prescaler, used with the trace packet
reference clockRW 0x0
7:6 Reserved. - -
5 STALLENA : Stall the PE to guarantee delivery of Data Trace packets. RW 0x0
4 SWOENA : Enables asynchronous clocking of the timestamp counter RW 0x0
3 TXENA : Enables forwarding of hardware event packet from the DWT unit to
the ITM for output to the TPIURW 0x0
2 SYNCENA : Enables Synchronization packet transmission for a synchronous
TPIURW 0x0
1 TSENA : Enables Local timestamp generation RW 0x0
0 ITMENA : Enables the ITM RW 0x0
M33 : INT_ATREADY Register
Offset : 0x00ef0
Description
Integration Mode: Read ATB Ready
Table 126.
INT_ATREADY
RegisterBits Description Type Reset
31:2 Reserved. - -
1 AFVALID : A read of this bit returns the value of AFVALID RO 0x0
0 ATREADY : A read of this bit returns the value of ATREADY RO 0x0
M33 : INT_ATVALID Register
Offset : 0x00ef8
RP2350 Datasheet
3.7. Cortex-M33 processor 160
Description
Integration Mode: Write ATB Valid
Table 127.
INT_ATVALID RegisterBits Description Type Reset
31:2 Reserved. - -
1 AFREADY : A write to this bit gives the value of AFREADY RW 0x0
0 ATREADY : A write to this bit gives the value of ATVALID RW 0x0
M33 : ITM_ITCTRL Register
Offset : 0x00f00
Description
Integration Mode Control Register
Table 128.
ITM_ITCTRL RegisterBits Description Type Reset
31:1 Reserved. - -
0 IME: Integration mode enable bit - The possible values are: 0 - The trace unit is
not in integration mode. 1 - The trace unit is in integration mode. This mode
enables: A debug agent to perform topology detection. SoC test software to
perform integration testing.RW 0x0
M33 : ITM_DEVARCH Register
Offset : 0x00fbc
Description
Provides CoreSight discovery information for the ITM
Table 129.
ITM_DEVARCH
RegisterBits Description Type Reset
31:21 ARCHITECT : Defines the architect of the component. Bits [31:28] are the
JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the
JEP106 ID code.RO 0x23b
20 PRESENT : Defines that the DEVARCH register is present RO 0x1
19:16 REVISION : Defines the architecture revision of the component RO 0x0
15:12 ARCHVER : Defines the architecture version of the component RO 0x1
11:0 ARCHPART : Defines the architecture of the component RO 0xa01
M33 : ITM_DEVTYPE Register
Offset : 0x00fcc
Description
Provides CoreSight discovery information for the ITM
Table 130.
ITM_DEVTYPE
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SUB : Component sub-type RO 0x4
3:0 MAJOR : Component major type RO 0x3
M33 : ITM_PIDR4 Register
RP2350 Datasheet
3.7. Cortex-M33 processor 161
Offset : 0x00fd0
Description
Provides CoreSight discovery information for the ITM
Table 131. ITM_PIDR4
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SIZE : See CoreSight Architecture Specification RO 0x0
3:0 DES_2 : See CoreSight Architecture Specification RO 0x4
M33 : ITM_PIDR5 Register
Offset : 0x00fd4
Description
Provides CoreSight discovery information for the ITM
Table 132. ITM_PIDR5
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : ITM_PIDR6 Register
Offset : 0x00fd8
Description
Provides CoreSight discovery information for the ITM
Table 133. ITM_PIDR6
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : ITM_PIDR7 Register
Offset : 0x00fdc
Description
Provides CoreSight discovery information for the ITM
Table 134. ITM_PIDR7
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : ITM_PIDR0 Register
Offset : 0x00fe0
Description
Provides CoreSight discovery information for the ITM
RP2350 Datasheet
3.7. Cortex-M33 processor 162
Table 135. ITM_PIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PART_0 : See CoreSight Architecture Specification RO 0x21
M33 : ITM_PIDR1 Register
Offset : 0x00fe4
Description
Provides CoreSight discovery information for the ITM
Table 136. ITM_PIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 DES_0 : See CoreSight Architecture Specification RO 0xb
3:0 PART_1 : See CoreSight Architecture Specification RO 0xd
M33 : ITM_PIDR2 Register
Offset : 0x00fe8
Description
Provides CoreSight discovery information for the ITM
Table 137. ITM_PIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVISION : See CoreSight Architecture Specification RO 0x0
3 JEDEC : See CoreSight Architecture Specification RO 0x1
2:0 DES_1 : See CoreSight Architecture Specification RO 0x3
M33 : ITM_PIDR3 Register
Offset : 0x00fec
Description
Provides CoreSight discovery information for the ITM
Table 138. ITM_PIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVAND : See CoreSight Architecture Specification RO 0x0
3:0 CMOD : See CoreSight Architecture Specification RO 0x0
M33 : ITM_CIDR0 Register
Offset : 0x00ff0
Description
Provides CoreSight discovery information for the ITM
RP2350 Datasheet
3.7. Cortex-M33 processor 163
Table 139. ITM_CIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_0 : See CoreSight Architecture Specification RO 0x0d
M33 : ITM_CIDR1 Register
Offset : 0x00ff4
Description
Provides CoreSight discovery information for the ITM
Table 140. ITM_CIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 CLASS : See CoreSight Architecture Specification RO 0x9
3:0 PRMBL_1 : See CoreSight Architecture Specification RO 0x0
M33 : ITM_CIDR2 Register
Offset : 0x00ff8
Description
Provides CoreSight discovery information for the ITM
Table 141. ITM_CIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_2 : See CoreSight Architecture Specification RO 0x05
M33 : ITM_CIDR3 Register
Offset : 0x00ffc
Description
Provides CoreSight discovery information for the ITM
Table 142. ITM_CIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_3 : See CoreSight Architecture Specification RO 0xb1
M33 : DWT_CTRL Register
Offset : 0x01000
Description
Provides configuration and status information for the DWT unit, and used to control features of the unit
Table 143. DWT_CTRL
RegisterBits Description Type Reset
31:28 NUMCOMP : Number of DWT comparators implemented RO 0x7
27 NOTRCPKT : Indicates whether the implementation does not support trace RO 0x0
26 NOEXTTRIG : Reserved, RAZ RO 0x0
25 NOCYCCNT : Indicates whether the implementation does not include a cycle
counterRO 0x1
RP2350 Datasheet
3.7. Cortex-M33 processor 164
Bits Description Type Reset
24 NOPRFCNT : Indicates whether the implementation does not include the
profiling countersRO 0x1
23 CYCDISS : Controls whether the cycle counter is disabled in Secure state RW 0x0
22 CYCEVTENA : Enables Event Counter packet generation on POSTCNT
underflowRW 0x1
21 FOLDEVTENA : Enables DWT_FOLDCNT counter RW 0x1
20 LSUEVTENA : Enables DWT_LSUCNT counter RW 0x1
19 SLEEPEVTENA : Enable DWT_SLEEPCNT counter RW 0x0
18 EXCEVTENA : Enables DWT_EXCCNT counter RW 0x1
17 CPIEVTENA : Enables DWT_CPICNT counter RW 0x0
16 EXTTRCENA : Enables generation of Exception Trace packets RW 0x0
15:13 Reserved. - -
12 PCSAMPLENA : Enables use of POSTCNT counter as a timer for Periodic PC
Sample packet generationRW 0x1
11:10 SYNCTAP : Selects the position of the synchronization packet counter tap on
the CYCCNT counter. This determines the Synchronization packet rateRW 0x2
9 CYCTAP : Selects the position of the POSTCNT tap on the CYCCNT counter RW 0x0
8:5 POSTINIT : Initial value for the POSTCNT counter RW 0x1
4:1 POSTPRESET : Reload value for the POSTCNT counter RW 0x2
0 CYCCNTENA : Enables CYCCNT RW 0x0
M33 : DWT_CYCCNT Register
Offset : 0x01004
Description
Shows or sets the value of the processor cycle counter, CYCCNT
Table 144.
DWT_CYCCNT
RegisterBits Description Type Reset
31:0 CYCCNT : Increments one on each processor clock cycle when
DWT_CTRL.CYCCNTENA == 1 and DEMCR.TRCENA == 1. On overflow,
CYCCNT wraps to zeroRW 0x00000000
M33 : DWT_EXCCNT Register
Offset : 0x0100c
Description
Counts the total cycles spent in exception processing
Table 145.
DWT_EXCCNT
RegisterBits Description Type Reset
31:8 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 165
Bits Description Type Reset
7:0 EXCCNT : Counts one on each cycle when all of the following are true: -
DWT_CTRL.EXCEVTENA == 1 and DEMCR.TRCENA == 1. - No instruction is
executed, see DWT_CPICNT. - An exception-entry or exception-exit related
operation is in progress. - Either SecureNoninvasiveDebugAllowed() == TRUE,
or NS-Req for the operation is set to Non-secure and
NoninvasiveDebugAllowed() == TRUE.RW 0x00
M33 : DWT_LSUCNT Register
Offset : 0x01014
Description
Increments on the additional cycles required to execute all load or store instructions
Table 146.
DWT_LSUCNT RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 LSUCNT : Counts one on each cycle when all of the following are true: -
DWT_CTRL.LSUEVTENA == 1 and DEMCR.TRCENA == 1. - No instruction is
executed, see DWT_CPICNT. - No exception-entry or exception-exit operation
is in progress, see DWT_EXCCNT. - A load-store operation is in progress. -
Either SecureNoninvasiveDebugAllowed() == TRUE, or NS-Req for the
operation is set to Non-secure and NoninvasiveDebugAllowed() == TRUE.RW 0x00
M33 : DWT_FOLDCNT Register
Offset : 0x01018
Description
Increments on the additional cycles required to execute all load or store instructions
Table 147.
DWT_FOLDCNT
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 FOLDCNT : Counts on each cycle when all of the following are true: -
DWT_CTRL.FOLDEVTENA == 1 and DEMCR.TRCENA == 1. - At least two
instructions are executed, see DWT_CPICNT. - Either
SecureNoninvasiveDebugAllowed() == TRUE, or the PE is in Non-secure state
and NoninvasiveDebugAllowed() == TRUE. The counter is incremented by the
number of instructions executed, minus oneRW 0x00
M33 : DWT_COMP0 Register
Offset : 0x01020
Table 148.
DWT_COMP0 RegisterBits Description Type Reset
31:0 Provides a reference value for use by watchpoint comparator 0 RW 0x00000000
M33 : DWT_FUNCTION0 Register
Offset : 0x01028
Description
Controls the operation of watchpoint comparator 0
RP2350 Datasheet
3.7. Cortex-M33 processor 166
Table 149.
DWT_FUNCTION0
RegisterBits Description Type Reset
31:27 ID: Identifies the capabilities for MATCH for comparator *n RO 0x0b
26:25 Reserved. - -
24 MATCHED : Set to 1 when the comparator matches RO 0x0
23:12 Reserved. - -
11:10 DATAVSIZE : Defines the size of the object being watched for by Data Value
and Data Address comparatorsRW 0x0
9:6 Reserved. - -
5:4 ACTION : Defines the action on a match. This field is ignored and the
comparator generates no actions if it is disabled by MATCHRW 0x0
3:0 MATCH : Controls the type of match generated by this comparator RW 0x0
M33 : DWT_COMP1 Register
Offset : 0x01030
Table 150.
DWT_COMP1 RegisterBits Description Type Reset
31:0 Provides a reference value for use by watchpoint comparator 1 RW 0x00000000
M33 : DWT_FUNCTION1 Register
Offset : 0x01038
Description
Controls the operation of watchpoint comparator 1
Table 151.
DWT_FUNCTION1
RegisterBits Description Type Reset
31:27 ID: Identifies the capabilities for MATCH for comparator *n RO 0x11
26:25 Reserved. - -
24 MATCHED : Set to 1 when the comparator matches RO 0x1
23:12 Reserved. - -
11:10 DATAVSIZE : Defines the size of the object being watched for by Data Value
and Data Address comparatorsRW 0x2
9:6 Reserved. - -
5:4 ACTION : Defines the action on a match. This field is ignored and the
comparator generates no actions if it is disabled by MATCHRW 0x2
3:0 MATCH : Controls the type of match generated by this comparator RW 0x8
M33 : DWT_COMP2 Register
Offset : 0x01040
RP2350 Datasheet
3.7. Cortex-M33 processor 167
Table 152.
DWT_COMP2 RegisterBits Description Type Reset
31:0 Provides a reference value for use by watchpoint comparator 2 RW 0x00000000
M33 : DWT_FUNCTION2 Register
Offset : 0x01048
Description
Controls the operation of watchpoint comparator 2
Table 153.
DWT_FUNCTION2
RegisterBits Description Type Reset
31:27 ID: Identifies the capabilities for MATCH for comparator *n RO 0x0a
26:25 Reserved. - -
24 MATCHED : Set to 1 when the comparator matches RO 0x0
23:12 Reserved. - -
11:10 DATAVSIZE : Defines the size of the object being watched for by Data Value
and Data Address comparatorsRW 0x0
9:6 Reserved. - -
5:4 ACTION : Defines the action on a match. This field is ignored and the
comparator generates no actions if it is disabled by MATCHRW 0x0
3:0 MATCH : Controls the type of match generated by this comparator RW 0x0
M33 : DWT_COMP3 Register
Offset : 0x01050
Table 154.
DWT_COMP3 RegisterBits Description Type Reset
31:0 Provides a reference value for use by watchpoint comparator 3 RW 0x00000000
M33 : DWT_FUNCTION3 Register
Offset : 0x01058
Description
Controls the operation of watchpoint comparator 3
Table 155.
DWT_FUNCTION3
RegisterBits Description Type Reset
31:27 ID: Identifies the capabilities for MATCH for comparator *n RO 0x04
26:25 Reserved. - -
24 MATCHED : Set to 1 when the comparator matches RO 0x0
23:12 Reserved. - -
11:10 DATAVSIZE : Defines the size of the object being watched for by Data Value
and Data Address comparatorsRW 0x2
9:6 Reserved. - -
5:4 ACTION : Defines the action on a match. This field is ignored and the
comparator generates no actions if it is disabled by MATCHRW 0x0
3:0 MATCH : Controls the type of match generated by this comparator RW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 168
M33 : DWT_DEVARCH Register
Offset : 0x01fbc
Description
Provides CoreSight discovery information for the DWT
Table 156.
DWT_DEVARCH
RegisterBits Description Type Reset
31:21 ARCHITECT : Defines the architect of the component. Bits [31:28] are the
JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the
JEP106 ID code.RO 0x23b
20 PRESENT : Defines that the DEVARCH register is present RO 0x1
19:16 REVISION : Defines the architecture revision of the component RO 0x0
15:12 ARCHVER : Defines the architecture version of the component RO 0x1
11:0 ARCHPART : Defines the architecture of the component RO 0xa02
M33 : DWT_DEVTYPE Register
Offset : 0x01fcc
Description
Provides CoreSight discovery information for the DWT
Table 157.
DWT_DEVTYPE
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SUB : Component sub-type RO 0x0
3:0 MAJOR : Component major type RO 0x0
M33 : DWT_PIDR4 Register
Offset : 0x01fd0
Description
Provides CoreSight discovery information for the DWT
Table 158.
DWT_PIDR4 RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SIZE : See CoreSight Architecture Specification RO 0x0
3:0 DES_2 : See CoreSight Architecture Specification RO 0x4
M33 : DWT_PIDR5 Register
Offset : 0x01fd4
Description
Provides CoreSight discovery information for the DWT
RP2350 Datasheet
3.7. Cortex-M33 processor 169
Table 159.
DWT_PIDR5 RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : DWT_PIDR6 Register
Offset : 0x01fd8
Description
Provides CoreSight discovery information for the DWT
Table 160.
DWT_PIDR6 RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : DWT_PIDR7 Register
Offset : 0x01fdc
Description
Provides CoreSight discovery information for the DWT
Table 161.
DWT_PIDR7 RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : DWT_PIDR0 Register
Offset : 0x01fe0
Description
Provides CoreSight discovery information for the DWT
Table 162.
DWT_PIDR0 RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PART_0 : See CoreSight Architecture Specification RO 0x21
M33 : DWT_PIDR1 Register
Offset : 0x01fe4
Description
Provides CoreSight discovery information for the DWT
Table 163.
DWT_PIDR1 RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 DES_0 : See CoreSight Architecture Specification RO 0xb
3:0 PART_1 : See CoreSight Architecture Specification RO 0xd
M33 : DWT_PIDR2 Register
Offset : 0x01fe8
Description
Provides CoreSight discovery information for the DWT
RP2350 Datasheet
3.7. Cortex-M33 processor 170
Table 164.
DWT_PIDR2 RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVISION : See CoreSight Architecture Specification RO 0x0
3 JEDEC : See CoreSight Architecture Specification RO 0x1
2:0 DES_1 : See CoreSight Architecture Specification RO 0x3
M33 : DWT_PIDR3 Register
Offset : 0x01fec
Description
Provides CoreSight discovery information for the DWT
Table 165.
DWT_PIDR3 RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVAND : See CoreSight Architecture Specification RO 0x0
3:0 CMOD : See CoreSight Architecture Specification RO 0x0
M33 : DWT_CIDR0 Register
Offset : 0x01ff0
Description
Provides CoreSight discovery information for the DWT
Table 166.
DWT_CIDR0 RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_0 : See CoreSight Architecture Specification RO 0x0d
M33 : DWT_CIDR1 Register
Offset : 0x01ff4
Description
Provides CoreSight discovery information for the DWT
Table 167.
DWT_CIDR1 RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 CLASS : See CoreSight Architecture Specification RO 0x9
3:0 PRMBL_1 : See CoreSight Architecture Specification RO 0x0
M33 : DWT_CIDR2 Register
Offset : 0x01ff8
Description
Provides CoreSight discovery information for the DWT
RP2350 Datasheet
3.7. Cortex-M33 processor 171
Table 168.
DWT_CIDR2 RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_2 : See CoreSight Architecture Specification RO 0x05
M33 : DWT_CIDR3 Register
Offset : 0x01ffc
Description
Provides CoreSight discovery information for the DWT
Table 169.
DWT_CIDR3 RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_3 : See CoreSight Architecture Specification RO 0xb1
M33 : FP_CTRL Register
Offset : 0x02000
Description
Provides FPB implementation information, and the global enable for the FPB unit
Table 170. FP_CTRL
RegisterBits Description Type Reset
31:28 REV: Flash Patch and Breakpoint Unit architecture revision RO 0x6
27:15 Reserved. - -
14:12 NUM_CODE_14_12_ : Indicates the number of implemented instruction
address comparators. Zero indicates no Instruction Address comparators are
implemented. The Instruction Address comparators are numbered from 0 to
NUM_CODE - 1RO 0x5
11:8 NUM_LIT : Indicates the number of implemented literal address comparators.
The Literal Address comparators are numbered from NUM_CODE to
NUM_CODE + NUM_LIT - 1RO 0x5
7:4 NUM_CODE_7_4_ : Indicates the number of implemented instruction address
comparators. Zero indicates no Instruction Address comparators are
implemented. The Instruction Address comparators are numbered from 0 to
NUM_CODE - 1RO 0x8
3:2 Reserved. - -
1 KEY: Writes to the FP_CTRL are ignored unless KEY is concurrently written to
oneRW 0x0
0 ENABLE : Enables the FPB RW 0x0
M33 : FP_REMAP Register
Offset : 0x02004
Description
Indicates whether the implementation supports Flash Patch remap and, if it does, holds the target address for
remap
Table 171. FP_REMAP
RegisterBits Description Type Reset
31:30 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 172
Bits Description Type Reset
29 RMPSPT : Indicates whether the FPB unit supports the Flash Patch remap
functionRO 0x0
28:5 REMAP : Holds the bits[28:5] of the Flash Patch remap address RO 0x000000
4:0 Reserved. - -
M33 : FP_COMP0, FP_COMP1, …, FP_COMP6, FP_COMP7 Registers
Offsets : 0x02008, 0x0200c, …, 0x02020, 0x02024
Description
Holds an address for comparison. The effect of the match depends on the configuration of the FPB and whether
the comparator is an instruction address comparator or a literal address comparator
Table 172. FP_COMP0,
FP_COMP1, …,
FP_COMP6,
FP_COMP7 RegistersBits Description Type Reset
31:1 Reserved. - -
0 BE: Selects between flashpatch and breakpoint functionality RW 0x0
M33 : FP_DEVARCH Register
Offset : 0x02fbc
Description
Provides CoreSight discovery information for the FPB
Table 173.
FP_DEVARCH RegisterBits Description Type Reset
31:21 ARCHITECT : Defines the architect of the component. Bits [31:28] are the
JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the
JEP106 ID code.RO 0x23b
20 PRESENT : Defines that the DEVARCH register is present RO 0x1
19:16 REVISION : Defines the architecture revision of the component RO 0x0
15:12 ARCHVER : Defines the architecture version of the component RO 0x1
11:0 ARCHPART : Defines the architecture of the component RO 0xa03
M33 : FP_DEVTYPE Register
Offset : 0x02fcc
Description
Provides CoreSight discovery information for the FPB
Table 174.
FP_DEVTYPE RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SUB : Component sub-type RO 0x0
3:0 MAJOR : Component major type RO 0x0
M33 : FP_PIDR4 Register
Offset : 0x02fd0
RP2350 Datasheet
3.7. Cortex-M33 processor 173
Description
Provides CoreSight discovery information for the FP
Table 175. FP_PIDR4
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SIZE : See CoreSight Architecture Specification RO 0x0
3:0 DES_2 : See CoreSight Architecture Specification RO 0x4
M33 : FP_PIDR5 Register
Offset : 0x02fd4
Description
Provides CoreSight discovery information for the FP
Table 176. FP_PIDR5
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : FP_PIDR6 Register
Offset : 0x02fd8
Description
Provides CoreSight discovery information for the FP
Table 177. FP_PIDR6
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : FP_PIDR7 Register
Offset : 0x02fdc
Description
Provides CoreSight discovery information for the FP
Table 178. FP_PIDR7
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : FP_PIDR0 Register
Offset : 0x02fe0
Description
Provides CoreSight discovery information for the FP
RP2350 Datasheet
3.7. Cortex-M33 processor 174
Table 179. FP_PIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PART_0 : See CoreSight Architecture Specification RO 0x21
M33 : FP_PIDR1 Register
Offset : 0x02fe4
Description
Provides CoreSight discovery information for the FP
Table 180. FP_PIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 DES_0 : See CoreSight Architecture Specification RO 0xb
3:0 PART_1 : See CoreSight Architecture Specification RO 0xd
M33 : FP_PIDR2 Register
Offset : 0x02fe8
Description
Provides CoreSight discovery information for the FP
Table 181. FP_PIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVISION : See CoreSight Architecture Specification RO 0x0
3 JEDEC : See CoreSight Architecture Specification RO 0x1
2:0 DES_1 : See CoreSight Architecture Specification RO 0x3
M33 : FP_PIDR3 Register
Offset : 0x02fec
Description
Provides CoreSight discovery information for the FP
Table 182. FP_PIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVAND : See CoreSight Architecture Specification RO 0x0
3:0 CMOD : See CoreSight Architecture Specification RO 0x0
M33 : FP_CIDR0 Register
Offset : 0x02ff0
Description
Provides CoreSight discovery information for the FP
RP2350 Datasheet
3.7. Cortex-M33 processor 175
Table 183. FP_CIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_0 : See CoreSight Architecture Specification RO 0x0d
M33 : FP_CIDR1 Register
Offset : 0x02ff4
Description
Provides CoreSight discovery information for the FP
Table 184. FP_CIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 CLASS : See CoreSight Architecture Specification RO 0x9
3:0 PRMBL_1 : See CoreSight Architecture Specification RO 0x0
M33 : FP_CIDR2 Register
Offset : 0x02ff8
Description
Provides CoreSight discovery information for the FP
Table 185. FP_CIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_2 : See CoreSight Architecture Specification RO 0x05
M33 : FP_CIDR3 Register
Offset : 0x02ffc
Description
Provides CoreSight discovery information for the FP
Table 186. FP_CIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_3 : See CoreSight Architecture Specification RO 0xb1
M33 : ICTR Register
Offset : 0x0e004
Description
Provides information about the interrupt controller
RP2350 Datasheet
3.7. Cortex-M33 processor 176
Table 187. ICTR
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 INTLINESNUM : Indicates the number of the highest implemented register in
each of the NVIC control register sets, or in the case of NVIC_IPR*n,
4×INTLINESNUMRO 0x1
M33 : ACTLR Register
Offset : 0x0e008
Description
Provides IMPLEMENTATION DEFINED configuration and control options
Table 188. ACTLR
RegisterBits Description Type Reset
31:30 Reserved. - -
29 EXTEXCLALL : External Exclusives Allowed with no MPU RW 0x0
28:13 Reserved. - -
12 DISITMATBFLUSH : Disable ATB Flush RW 0x0
11 Reserved. - -
10 FPEXCODIS : Disable FPU exception outputs RW 0x0
9 DISOOFP : Disable out-of-order FP instruction completion RW 0x0
8:3 Reserved. - -
2 DISFOLD : Disable dual-issue. RW 0x0
1 Reserved. - -
0 DISMCYCINT : Disable dual-issue. RW 0x0
M33 : SYST_CSR Register
Offset : 0x0e010
Description
Use the SysTick Control and Status Register to enable the SysTick features.
Table 189. SYST_CSR
RegisterBits Description Type Reset
31:17 Reserved. - -
16 COUNTFLAG : Returns 1 if timer counted to 0 since last time this was read.
Clears on read by application or debugger.RO 0x0
15:3 Reserved. - -
2 CLKSOURCE : SysTick clock source. Always reads as one if SYST_CALIB
reports NOREF.
Selects the SysTick timer clock source:
0 = External reference clock.
1 = Processor clock.RW 0x0
1 TICKINT : Enables SysTick exception request:
0 = Counting down to zero does not assert the SysTick exception request.
1 = Counting down to zero to asserts the SysTick exception request.RW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 177
Bits Description Type Reset
0 ENABLE : Enable SysTick counter:
0 = Counter disabled.
1 = Counter enabled.RW 0x0
M33 : SYST_RVR Register
Offset : 0x0e014
Description
Use the SysTick Reload Value Register to specify the start value to load into the current value register when the
counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect
because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this
register is UNKNOWN.
To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example,
if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99.
Table 190. SYST_RVR
RegisterBits Description Type Reset
31:24 Reserved. - -
23:0 RELOAD : Value to load into the SysTick Current Value Register when the
counter reaches 0.RW 0x000000
M33 : SYST_CVR Register
Offset : 0x0e018
Description
Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is
UNKNOWN.
Table 191. SYST_CVR
RegisterBits Description Type Reset
31:24 Reserved. - -
23:0 CURRENT : Reads return the current value of the SysTick counter. This register
is write-clear. Writing to it with any value clears the register to 0. Clearing this
register also clears the COUNTFLAG bit of the SysTick Control and Status
Register.RW 0x000000
M33 : SYST_CALIB Register
Offset : 0x0e01c
Description
Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and
multiply.
Table 192.
SYST_CALIB RegisterBits Description Type Reset
31 NOREF : If reads as 1, the Reference clock is not provided - the CLKSOURCE bit
of the SysTick Control and Status register will be forced to 1 and cannot be
cleared to 0.RO 0x0
30 SKEW : If reads as 1, the calibration value for 10ms is inexact (due to clock
frequency).RO 0x0
29:24 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 178
Bits Description Type Reset
23:0 TENMS : An optional Reload value to be used for 10ms (100Hz) timing, subject
to system clock skew errors. If the value reads as 0, the calibration value is not
known.RO 0x000000
M33 : NVIC_ISER0, NVIC_ISER1 Registers
Offsets : 0x0e100, 0x0e104
Description
Enables or reads the enabled state of each group of 32 interrupts
Table 193.
NVIC_ISER0,
NVIC_ISER1 RegistersBits Description Type Reset
31:0 SETENA : For SETENA[m] in NVIC_ISER*n, indicates whether interrupt 32*n + m
is enabledRW 0x00000000
M33 : NVIC_ICER0, NVIC_ICER1 Registers
Offsets : 0x0e180, 0x0e184
Description
Clears or reads the enabled state of each group of 32 interrupts
Table 194.
NVIC_ICER0,
NVIC_ICER1 RegistersBits Description Type Reset
31:0 CLRENA : For CLRENA[m] in NVIC_ICER*n, indicates whether interrupt 32*n +
m is enabledRW 0x00000000
M33 : NVIC_ISPR0, NVIC_ISPR1 Registers
Offsets : 0x0e200, 0x0e204
Description
Enables or reads the pending state of each group of 32 interrupts
Table 195.
NVIC_ISPR0,
NVIC_ISPR1 RegistersBits Description Type Reset
31:0 SETPEND : For SETPEND[m] in NVIC_ISPR*n, indicates whether interrupt 32*n
+ m is pendingRW 0x00000000
M33 : NVIC_ICPR0, NVIC_ICPR1 Registers
Offsets : 0x0e280, 0x0e284
Description
Clears or reads the pending state of each group of 32 interrupts
Table 196.
NVIC_ICPR0,
NVIC_ICPR1 RegistersBits Description Type Reset
31:0 CLRPEND : For CLRPEND[m] in NVIC_ICPR*n, indicates whether interrupt 32*n
+ m is pendingRW 0x00000000
M33 : NVIC_IABR0, NVIC_IABR1 Registers
Offsets : 0x0e300, 0x0e304
Description
For each group of 32 interrupts, shows the active state of each interrupt
RP2350 Datasheet
3.7. Cortex-M33 processor 179
Table 197.
NVIC_IABR0,
NVIC_IABR1 RegistersBits Description Type Reset
31:0 ACTIVE : For ACTIVE[m] in NVIC_IABR*n, indicates the active state for interrupt
32*n+mRW 0x00000000
M33 : NVIC_ITNS0, NVIC_ITNS1 Registers
Offsets : 0x0e380, 0x0e384
Description
For each group of 32 interrupts, determines whether each interrupt targets Non-secure or Secure state
Table 198.
NVIC_ITNS0,
NVIC_ITNS1 RegistersBits Description Type Reset
31:0 ITNS : For ITNS[m] in NVIC_ITNS*n, `IAAMO the target Security state for
interrupt 32*n+mRW 0x00000000
M33 : NVIC_IPR0, NVIC_IPR1, …, NVIC_IPR14, NVIC_IPR15 Registers
Offsets : 0x0e400, 0x0e404, …, 0x0e438, 0x0e43c
Description
Sets or reads interrupt priorities
Table 199. NVIC_IPR0,
NVIC_IPR1, …,
NVIC_IPR14,
NVIC_IPR15 RegistersBits Description Type Reset
31:28 PRI_N3 : For register NVIC_IPRn, the priority of interrupt number 4*n+3, or
RES0 if the PE does not implement this interruptRW 0x0
27:24 Reserved. - -
23:20 PRI_N2 : For register NVIC_IPRn, the priority of interrupt number 4*n+2, or
RES0 if the PE does not implement this interruptRW 0x0
19:16 Reserved. - -
15:12 PRI_N1 : For register NVIC_IPRn, the priority of interrupt number 4*n+1, or
RES0 if the PE does not implement this interruptRW 0x0
11:8 Reserved. - -
7:4 PRI_N0 : For register NVIC_IPRn, the priority of interrupt number 4*n+0, or
RES0 if the PE does not implement this interruptRW 0x0
3:0 Reserved. - -
M33 : CPUID Register
Offset : 0x0ed00
Description
Provides identification information for the PE, including an implementer code for the device and a device ID number
Table 200. CPUID
RegisterBits Description Type Reset
31:24 IMPLEMENTER : This field must hold an implementer code that has been
assigned by ARMRO 0x41
23:20 VARIANT : IMPLEMENTATION DEFINED variant number. Typically, this field is
used to distinguish between different product variants, or major revisions of a
productRO 0x1
19:16 ARCHITECTURE : Defines the Architecture implemented by the PE RO 0xf
RP2350 Datasheet
3.7. Cortex-M33 processor 180
Bits Description Type Reset
15:4 PARTNO : IMPLEMENTATION DEFINED primary part number for the device RO 0xd21
3:0 REVISION : IMPLEMENTATION DEFINED revision number for the device RO 0x0
M33 : ICSR Register
Offset : 0x0ed04
Description
Controls and provides status information for NMI, PendSV, SysTick and interrupts
Table 201. ICSR
RegisterBits Description Type Reset
31 PENDNMISET : Indicates whether the NMI exception is pending RO 0x0
30 PENDNMICLR : Allows the NMI exception pend state to be cleared RW 0x0
29 Reserved. - -
28 PENDSVSET : Indicates whether the PendSV `FTSSS exception is pending RO 0x0
27 PENDSVCLR : Allows the PendSV exception pend state to be cleared `FTSSS RW 0x0
26 PENDSTSET : Indicates whether the SysTick `FTSSS exception is pending RO 0x0
25 PENDSTCLR : Allows the SysTick exception pend state to be cleared `FTSSS RW 0x0
24 STTNS : Controls whether in a single SysTick implementation, the SysTick is
Secure or Non-secureRW 0x0
23 ISRPREEMPT : Indicates whether a pending exception will be serviced on exit
from debug halt stateRO 0x0
22 ISRPENDING : Indicates whether an external interrupt, generated by the NVIC,
is pendingRO 0x0
21 Reserved. - -
20:12 VECTPENDING : The exception number of the highest priority pending and
enabled interruptRO 0x000
11 RETTOBASE : In Handler mode, indicates whether there is more than one
active exceptionRO 0x0
10:9 Reserved. - -
8:0 VECTACTIVE : The exception number of the current executing exception RO 0x000
M33 : VTOR Register
Offset : 0x0ed08
Description
The VTOR indicates the offset of the vector table base address from memory address 0x00000000.
RP2350 Datasheet
3.7. Cortex-M33 processor 181
Table 202. VTOR
RegisterBits Description Type Reset
31:7 TBLOFF : Vector table base offset field. It contains bits[31:7] of the offset of
the table base from the bottom of the memory map.RW 0x0000000
6:0 Reserved. - -
M33 : AIRCR Register
Offset : 0x0ed0c
Description
Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state
information from debug halt mode, request a system reset.
Table 203. AIRCR
RegisterBits Description Type Reset
31:16 VECTKEY : Register key:
Reads as Unknown
On writes, write 0x05FA to VECTKEY, otherwise the write is ignored.RW 0x0000
15 ENDIANESS : Data endianness implemented:
0 = Little-endian.RO 0x0
14 PRIS : Prioritize Secure exceptions. The value of this bit defines whether
Secure exception priority boosting is enabled.
0 Priority ranges of Secure and Non-secure exceptions are identical.
1 Non-secure exceptions are de-prioritized.RW 0x0
13 BFHFNMINS : BusFault, HardFault, and NMI Non-secure enable.
0 BusFault, HardFault, and NMI are Secure.
1 BusFault and NMI are Non-secure and exceptions can target Non-secure
HardFault.RW 0x0
12:11 Reserved. - -
10:8 PRIGROUP : Interrupt priority grouping field. This field determines the split of
group priority from subpriority.
See https://developer.arm.com/documentation/100235/0004/the-cortex-
m33-peripherals/system-control-block/application-interrupt-and-reset-control-
register?lang=enRW 0x0
7:4 Reserved. - -
3 SYSRESETREQS : System reset request, Secure state only.
0 SYSRESETREQ functionality is available to both Security states.
1 SYSRESETREQ functionality is only available to Secure state.RW 0x0
2 SYSRESETREQ : Writing 1 to this bit causes the SYSRESETREQ signal to the
outer system to be asserted to request a reset. The intention is to force a large
system reset of all major components except for debug. The C_HALT bit in the
DHCSR is cleared as a result of the system reset requested. The debugger
does not lose contact with the device.RW 0x0
1 VECTCLRACTIVE : Clears all active state information for fixed and
configurable exceptions. This bit: is self-clearing, can only be set by the DAP
when the core is halted. When set: clears all active exception status of the
processor, forces a return to Thread mode, forces an IPSR of 0. A debugger
must re-initialize the stack.RW 0x0
0 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 182
M33 : SCR Register
Offset : 0x0ed10
Description
System Control Register. Use the System Control Register for power-management functions: signal to the system
when the processor can enter a low power state, control how the processor enters and exits low power states.
Table 204. SCR
RegisterBits Description Type Reset
31:5 Reserved. - -
4 SEVONPEND : Send Event on Pending bit:
0 = Only enabled interrupts or events can wakeup the processor, disabled
interrupts are excluded.
1 = Enabled events and all interrupts, including disabled interrupts, can
wakeup the processor.
When an event or interrupt becomes pending, the event signal wakes up the
processor from WFE. If the
processor is not waiting for an event, the event is registered and affects the
next WFE.
The processor also wakes up on execution of an SEV instruction or an external
event.RW 0x0
3 SLEEPDEEPS : 0 SLEEPDEEP is available to both security states
1 SLEEPDEEP is only available to Secure stateRW 0x0
2 SLEEPDEEP : Controls whether the processor uses sleep or deep sleep as its
low power mode:
0 = Sleep.
1 = Deep sleep.RW 0x0
1 SLEEPONEXIT : Indicates sleep-on-exit when returning from Handler mode to
Thread mode:
0 = Do not sleep when returning to Thread mode.
1 = Enter sleep, or deep sleep, on return from an ISR to Thread mode.
Setting this bit to 1 enables an interrupt driven application to avoid returning to
an empty main application.RW 0x0
0 Reserved. - -
M33 : CCR Register
Offset : 0x0ed14
Description
Sets or returns configuration and control data
Table 205. CCR
RegisterBits Description Type Reset
31:19 Reserved. - -
18 BP: Enables program flow prediction `FTSSS RO 0x0
17 IC: This is a global enable bit for instruction caches in the selected Security
stateRO 0x0
16 DC: Enables data caching of all data accesses to Normal memory `FTSSS RO 0x0
15:11 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 183
Bits Description Type Reset
10 STKOFHFNMIGN : Controls the effect of a stack limit violation while executing
at a requested priority less than 0RW 0x0
9 RES1 : Reserved, RES1 RO 0x1
8 BFHFNMIGN : Determines the effect of precise BusFaults on handlers running
at a requested priority less than 0RW 0x0
7:5 Reserved. - -
4 DIV_0_TRP : Controls the generation of a DIVBYZERO UsageFault when
attempting to perform integer division by zeroRW 0x0
3 UNALIGN_TRP : Controls the trapping of unaligned word or halfword accesses RW 0x0
2 Reserved. - -
1 USERSETMPEND : Determines whether unprivileged accesses are permitted to
pend interrupts via the STIRRW 0x0
0 RES1_1 : Reserved, RES1 RO 0x1
M33 : SHPR1 Register
Offset : 0x0ed18
Description
Sets or returns priority for system handlers 4 - 7
Table 206. SHPR1
RegisterBits Description Type Reset
31:29 PRI_7_3 : Priority of system handler 7, SecureFault RW 0x0
28:24 Reserved. - -
23:21 PRI_6_3 : Priority of system handler 6, SecureFault RW 0x0
20:16 Reserved. - -
15:13 PRI_5_3 : Priority of system handler 5, SecureFault RW 0x0
12:8 Reserved. - -
7:5 PRI_4_3 : Priority of system handler 4, SecureFault RW 0x0
4:0 Reserved. - -
M33 : SHPR2 Register
Offset : 0x0ed1c
Description
Sets or returns priority for system handlers 8 - 11
Table 207. SHPR2
RegisterBits Description Type Reset
31:29 PRI_11_3 : Priority of system handler 11, SecureFault RW 0x0
28:24 Reserved. - -
23:16 PRI_10 : Reserved, RES0 RO 0x00
15:8 PRI_9 : Reserved, RES0 RO 0x00
RP2350 Datasheet
3.7. Cortex-M33 processor 184
Bits Description Type Reset
7:0 PRI_8 : Reserved, RES0 RO 0x00
M33 : SHPR3 Register
Offset : 0x0ed20
Description
Sets or returns priority for system handlers 12 - 15
Table 208. SHPR3
RegisterBits Description Type Reset
31:29 PRI_15_3 : Priority of system handler 15, SecureFault RW 0x0
28:24 Reserved. - -
23:21 PRI_14_3 : Priority of system handler 14, SecureFault RW 0x0
20:16 Reserved. - -
15:8 PRI_13 : Reserved, RES0 RO 0x00
7:5 PRI_12_3 : Priority of system handler 12, SecureFault RW 0x0
4:0 Reserved. - -
M33 : SHCSR Register
Offset : 0x0ed24
Description
Provides access to the active and pending status of system exceptions
Table 209. SHCSR
RegisterBits Description Type Reset
31:22 Reserved. - -
21 HARDFAULTPENDED : `IAAMO the pending state of the HardFault exception
`CTTSSSRW 0x0
20 SECUREFAULTPENDED : `IAAMO the pending state of the SecureFault
exceptionRW 0x0
19 SECUREFAULTENA : `DW the SecureFault exception is enabled RW 0x0
18 USGFAULTENA : `DW the UsageFault exception is enabled `FTSSS RW 0x0
17 BUSFAULTENA : `DW the BusFault exception is enabled RW 0x0
16 MEMFAULTENA : `DW the MemManage exception is enabled `FTSSS RW 0x0
15 SVCALLPENDED : `IAAMO the pending state of the SVCall exception `FTSSS RW 0x0
14 BUSFAULTPENDED : `IAAMO the pending state of the BusFault exception RW 0x0
13 MEMFAULTPENDED : `IAAMO the pending state of the MemManage exception
`FTSSSRW 0x0
12 USGFAULTPENDED : The UsageFault exception is banked between Security
states, `IAAMO the pending state of the UsageFault exception `FTSSSRW 0x0
11 SYSTICKACT : `IAAMO the active state of the SysTick exception `FTSSS RW 0x0
10 PENDSVACT : `IAAMO the active state of the PendSV exception `FTSSS RW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 185
Bits Description Type Reset
9 Reserved. - -
8 MONITORACT : `IAAMO the active state of the DebugMonitor exception RW 0x0
7 SVCALLACT : `IAAMO the active state of the SVCall exception `FTSSS RW 0x0
6 Reserved. - -
5 NMIACT : `IAAMO the active state of the NMI exception RW 0x0
4 SECUREFAULTACT : `IAAMO the active state of the SecureFault exception RW 0x0
3 USGFAULTACT : `IAAMO the active state of the UsageFault exception `FTSSS RW 0x0
2 HARDFAULTACT : Indicates and allows limited modification of the active state
of the HardFault exception `FTSSSRW 0x0
1 BUSFAULTACT : `IAAMO the active state of the BusFault exception RW 0x0
0 MEMFAULTACT : `IAAMO the active state of the MemManage exception
`FTSSSRW 0x0
M33 : CFSR Register
Offset : 0x0ed28
Description
Contains the three Configurable Fault Status Registers.
31:16 UFSR: Provides information on UsageFault exceptions
15:8 BFSR: Provides information on BusFault exceptions
7:0 MMFSR: Provides information on MemManage exceptions
Table 210. CFSR
RegisterBits Description Type Reset
31:26 Reserved. - -
25 UFSR_DIVBYZERO : Sticky flag indicating whether an integer division by zero
error has occurredRW 0x0
24 UFSR_UNALIGNED : Sticky flag indicating whether an unaligned access error
has occurredRW 0x0
23:21 Reserved. - -
20 UFSR_STKOF : Sticky flag indicating whether a stack overflow error has
occurredRW 0x0
19 UFSR_NOCP : Sticky flag indicating whether a coprocessor disabled or not
present error has occurredRW 0x0
18 UFSR_INVPC : Sticky flag indicating whether an integrity check error has
occurredRW 0x0
17 UFSR_INVSTATE : Sticky flag indicating whether an EPSR.T or EPSR.IT validity
error has occurredRW 0x0
16 UFSR_UNDEFINSTR : Sticky flag indicating whether an undefined instruction
error has occurredRW 0x0
15 BFSR_BFARVALID : Indicates validity of the contents of the BFAR register RW 0x0
14 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 186
Bits Description Type Reset
13 BFSR_LSPERR : Records whether a BusFault occurred during FP lazy state
preservationRW 0x0
12 BFSR_STKERR : Records whether a derived BusFault occurred during
exception entry stackingRW 0x0
11 BFSR_UNSTKERR : Records whether a derived BusFault occurred during
exception return unstackingRW 0x0
10 BFSR_IMPRECISERR : Records whether an imprecise data access error has
occurredRW 0x0
9 BFSR_PRECISERR : Records whether a precise data access error has occurred RW 0x0
8 BFSR_IBUSERR : Records whether a BusFault on an instruction prefetch has
occurredRW 0x0
7:0 MMFSR : Provides information on MemManage exceptions RW 0x00
M33 : HFSR Register
Offset : 0x0ed2c
Description
Shows the cause of any HardFaults
Table 211. HFSR
RegisterBits Description Type Reset
31 DEBUGEVT : Indicates when a Debug event has occurred RW 0x0
30 FORCED : Indicates that a fault with configurable priority has been escalated to
a HardFault exception, because it could not be made active, because of
priority, or because it was disabledRW 0x0
29:2 Reserved. - -
1 VECTTBL : Indicates when a fault has occurred because of a vector table read
error on exception processingRW 0x0
0 Reserved. - -
M33 : DFSR Register
Offset : 0x0ed30
Description
Shows which debug event occurred
Table 212. DFSR
RegisterBits Description Type Reset
31:5 Reserved. - -
4 EXTERNAL : Sticky flag indicating whether an External debug request debug
event has occurredRW 0x0
3 VCATCH : Sticky flag indicating whether a Vector catch debug event has
occurredRW 0x0
2 DWTTRAP : Sticky flag indicating whether a Watchpoint debug event has
occurredRW 0x0
1 BKPT : Sticky flag indicating whether a Breakpoint debug event has occurred RW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 187
Bits Description Type Reset
0 HALTED : Sticky flag indicating that a Halt request debug event or Step debug
event has occurredRW 0x0
M33 : MMFAR Register
Offset : 0x0ed34
Description
Shows the address of the memory location that caused an MPU fault
Table 213. MMFAR
RegisterBits Description Type Reset
31:0 ADDRESS : This register is updated with the address of a location that
produced a MemManage fault. The MMFSR shows the cause of the fault, and
whether this field is valid. This field is valid only when MMFSR.MMARVALID is
set, otherwise it is UNKNOWNRW 0x00000000
M33 : BFAR Register
Offset : 0x0ed38
Description
Shows the address associated with a precise data access BusFault
Table 214. BFAR
RegisterBits Description Type Reset
31:0 ADDRESS : This register is updated with the address of a location that
produced a BusFault. The BFSR shows the reason for the fault. This field is
valid only when BFSR.BFARVALID is set, otherwise it is UNKNOWNRW 0x00000000
M33 : ID_PFR0 Register
Offset : 0x0ed40
Description
Gives top-level information about the instruction set supported by the PE
Table 215. ID_PFR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 STATE1 : T32 instruction set support RO 0x3
3:0 STATE0 : A32 instruction set support RO 0x0
M33 : ID_PFR1 Register
Offset : 0x0ed44
Description
Gives information about the programmers' model and Extensions support
Table 216. ID_PFR1
RegisterBits Description Type Reset
31:12 Reserved. - -
11:8 MPROGMOD : Identifies support for the M-Profile programmers' model support RO 0x5
7:4 SECURITY : Identifies whether the Security Extension is implemented RO 0x2
3:0 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 188
M33 : ID_DFR0 Register
Offset : 0x0ed48
Description
Provides top level information about the debug system
Table 217. ID_DFR0
RegisterBits Description Type Reset
31:24 Reserved. - -
23:20 MPROFDBG : Indicates the supported M-profile debug architecture RO 0x2
19:0 Reserved. - -
M33 : ID_AFR0 Register
Offset : 0x0ed4c
Description
Provides information about the IMPLEMENTATION DEFINED features of the PE
Table 218. ID_AFR0
RegisterBits Description Type Reset
31:16 Reserved. - -
15:12 IMPDEF3 : IMPLEMENTATION DEFINED meaning RO 0x0
11:8 IMPDEF2 : IMPLEMENTATION DEFINED meaning RO 0x0
7:4 IMPDEF1 : IMPLEMENTATION DEFINED meaning RO 0x0
3:0 IMPDEF0 : IMPLEMENTATION DEFINED meaning RO 0x0
M33 : ID_MMFR0 Register
Offset : 0x0ed50
Description
Provides information about the implemented memory model and memory management support
Table 219. ID_MMFR0
RegisterBits Description Type Reset
31:24 Reserved. - -
23:20 AUXREG : Indicates support for Auxiliary Control Registers RO 0x1
19:16 TCM : Indicates support for tightly coupled memories (TCMs) RO 0x0
15:12 SHARELVL : Indicates the number of shareability levels implemented RO 0x1
11:8 OUTERSHR : Indicates the outermost shareability domain implemented RO 0xf
7:4 PMSA : Indicates support for the protected memory system architecture
(PMSA)RO 0x4
3:0 Reserved. - -
M33 : ID_MMFR1 Register
Offset : 0x0ed54
RP2350 Datasheet
3.7. Cortex-M33 processor 189
Description
Provides information about the implemented memory model and memory management support
Table 220. ID_MMFR1
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : ID_MMFR2 Register
Offset : 0x0ed58
Description
Provides information about the implemented memory model and memory management support
Table 221. ID_MMFR2
RegisterBits Description Type Reset
31:28 Reserved. - -
27:24 WFISTALL : Indicates the support for Wait For Interrupt (WFI) stalling RO 0x1
23:0 Reserved. - -
M33 : ID_MMFR3 Register
Offset : 0x0ed5c
Description
Provides information about the implemented memory model and memory management support
Table 222. ID_MMFR3
RegisterBits Description Type Reset
31:12 Reserved. - -
11:8 BPMAINT : Indicates the supported branch predictor maintenance RO 0x0
7:4 CMAINTSW : Indicates the supported cache maintenance operations by
set/wayRO 0x0
3:0 CMAINTVA : Indicates the supported cache maintenance operations by
addressRO 0x0
M33 : ID_ISAR0 Register
Offset : 0x0ed60
Description
Provides information about the instruction set implemented by the PE
Table 223. ID_ISAR0
RegisterBits Description Type Reset
31:28 Reserved. - -
27:24 DIVIDE : Indicates the supported Divide instructions RO 0x8
23:20 DEBUG : Indicates the implemented Debug instructions RO 0x0
19:16 COPROC : Indicates the supported Coprocessor instructions RO 0x9
15:12 CMPBRANCH : Indicates the supported combined Compare and Branch
instructionsRO 0x2
11:8 BITFIELD : Indicates the supported bit field instructions RO 0x3
RP2350 Datasheet
3.7. Cortex-M33 processor 190
Bits Description Type Reset
7:4 BITCOUNT : Indicates the supported bit count instructions RO 0x0
3:0 Reserved. - -
M33 : ID_ISAR1 Register
Offset : 0x0ed64
Description
Provides information about the instruction set implemented by the PE
Table 224. ID_ISAR1
RegisterBits Description Type Reset
31:28 Reserved. - -
27:24 INTERWORK : Indicates the implemented Interworking instructions RO 0x5
23:20 IMMEDIATE : Indicates the implemented for data-processing instructions with
long immediatesRO 0x7
19:16 IFTHEN : Indicates the implemented If-Then instructions RO 0x2
15:12 EXTEND : Indicates the implemented Extend instructions RO 0x5
11:0 Reserved. - -
M33 : ID_ISAR2 Register
Offset : 0x0ed68
Description
Provides information about the instruction set implemented by the PE
Table 225. ID_ISAR2
RegisterBits Description Type Reset
31:28 REVERSAL : Indicates the implemented Reversal instructions RO 0x3
27:24 Reserved. - -
23:20 MULTU : Indicates the implemented advanced unsigned Multiply instructions RO 0x1
19:16 MULTS : Indicates the implemented advanced signed Multiply instructions RO 0x7
15:12 MULT : Indicates the implemented additional Multiply instructions RO 0x3
11:8 MULTIACCESSINT : Indicates the support for interruptible multi-access
instructionsRO 0x4
7:4 MEMHINT : Indicates the implemented Memory Hint instructions RO 0x2
3:0 LOADSTORE : Indicates the implemented additional load/store instructions RO 0x6
M33 : ID_ISAR3 Register
Offset : 0x0ed6c
Description
Provides information about the instruction set implemented by the PE
Table 226. ID_ISAR3
RegisterBits Description Type Reset
31:28 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 191
Bits Description Type Reset
27:24 TRUENOP : Indicates the implemented true NOP instructions RO 0x7
23:20 T32COPY : Indicates the support for T32 non flag-setting MOV instructions RO 0x8
19:16 TABBRANCH : Indicates the implemented Table Branch instructions RO 0x9
15:12 SYNCHPRIM : Used in conjunction with ID_ISAR4.SynchPrim_frac to indicate
the implemented Synchronization Primitive instructionsRO 0x5
11:8 SVC : Indicates the implemented SVC instructions RO 0x7
7:4 SIMD : Indicates the implemented SIMD instructions RO 0x2
3:0 SATURATE : Indicates the implemented saturating instructions RO 0x9
M33 : ID_ISAR4 Register
Offset : 0x0ed70
Description
Provides information about the instruction set implemented by the PE
Table 227. ID_ISAR4
RegisterBits Description Type Reset
31:28 Reserved. - -
27:24 PSR_M : Indicates the implemented M profile instructions to modify the PSRs RO 0x1
23:20 SYNCPRIM_FRAC : Used in conjunction with ID_ISAR3.SynchPrim to indicate
the implemented Synchronization Primitive instructionsRO 0x3
19:16 BARRIER : Indicates the implemented Barrier instructions RO 0x1
15:12 Reserved. - -
11:8 WRITEBACK : Indicates the support for writeback addressing modes RO 0x1
7:4 WITHSHIFTS : Indicates the support for writeback addressing modes RO 0x3
3:0 UNPRIV : Indicates the implemented unprivileged instructions RO 0x2
M33 : ID_ISAR5 Register
Offset : 0x0ed74
Description
Provides information about the instruction set implemented by the PE
Table 228. ID_ISAR5
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : CTR Register
Offset : 0x0ed7c
Description
Provides information about the architecture of the caches. CTR is RES0 if CLIDR is zero.
Table 229. CTR
RegisterBits Description Type Reset
31 RES1 : Reserved, RES1 RO 0x1
RP2350 Datasheet
3.7. Cortex-M33 processor 192
Bits Description Type Reset
30:28 Reserved. - -
27:24 CWG : Log2 of the number of words of the maximum size of memory that can
be overwritten as a result of the eviction of a cache entry that has had a
memory location in it modifiedRO 0x0
23:20 ERG : Log2 of the number of words of the maximum size of the reservation
granule that has been implemented for the Load-Exclusive and Store-Exclusive
instructionsRO 0x0
19:16 DMINLINE : Log2 of the number of words in the smallest cache line of all the
data caches and unified caches that are controlled by the PERO 0x0
15:14 RES1_1 : Reserved, RES1 RO 0x3
13:4 Reserved. - -
3:0 IMINLINE : Log2 of the number of words in the smallest cache line of all the
instruction caches that are controlled by the PERO 0x0
M33 : CPACR Register
Offset : 0x0ed88
Description
Specifies the access privileges for coprocessors and the FP Extension
Table 230. CPACR
RegisterBits Description Type Reset
31:24 Reserved. - -
23:22 CP11 : The value in this field is ignored. If the implementation does not include
the FP Extension, this field is RAZ/WI. If the value of this bit is not
programmed to the same value as the CP10 field, then the value is UNKNOWNRW 0x0
21:20 CP10 : Defines the access rights for the floating-point functionality RW 0x0
19:16 Reserved. - -
15:14 CP7 : Controls access privileges for coprocessor 7 RW 0x0
13:12 CP6 : Controls access privileges for coprocessor 6 RW 0x0
11:10 CP5 : Controls access privileges for coprocessor 5 RW 0x0
9:8 CP4 : Controls access privileges for coprocessor 4 RW 0x0
7:6 CP3 : Controls access privileges for coprocessor 3 RW 0x0
5:4 CP2 : Controls access privileges for coprocessor 2 RW 0x0
3:2 CP1 : Controls access privileges for coprocessor 1 RW 0x0
1:0 CP0 : Controls access privileges for coprocessor 0 RW 0x0
M33 : NSACR Register
Offset : 0x0ed8c
Description
Defines the Non-secure access permissions for both the FP Extension and coprocessors CP0 to CP7
RP2350 Datasheet
3.7. Cortex-M33 processor 193
Table 231. NSACR
RegisterBits Description Type Reset
31:12 Reserved. - -
11 CP11 : Enables Non-secure access to the Floating-point Extension RW 0x0
10 CP10 : Enables Non-secure access to the Floating-point Extension RW 0x0
9:8 Reserved. - -
7 CP7 : Enables Non-secure access to coprocessor CP7 RW 0x0
6 CP6 : Enables Non-secure access to coprocessor CP6 RW 0x0
5 CP5 : Enables Non-secure access to coprocessor CP5 RW 0x0
4 CP4 : Enables Non-secure access to coprocessor CP4 RW 0x0
3 CP3 : Enables Non-secure access to coprocessor CP3 RW 0x0
2 CP2 : Enables Non-secure access to coprocessor CP2 RW 0x0
1 CP1 : Enables Non-secure access to coprocessor CP1 RW 0x0
0 CP0 : Enables Non-secure access to coprocessor CP0 RW 0x0
M33 : MPU_TYPE Register
Offset : 0x0ed90
Description
The MPU Type Register indicates how many regions the MPU `FTSSS supports
Table 232. MPU_TYPE
RegisterBits Description Type Reset
31:16 Reserved. - -
15:8 DREGION : Number of regions supported by the MPU RO 0x08
7:1 Reserved. - -
0 SEPARATE : Indicates support for separate instructions and data address
regionsRO 0x0
M33 : MPU_CTRL Register
Offset : 0x0ed94
Description
Enables the MPU and, when the MPU is enabled, controls whether the default memory map is enabled as a
background region for privileged accesses, and whether the MPU is enabled for HardFaults, NMIs, and exception
handlers when FAULTMASK is set to 1
Table 233. MPU_CTRL
RegisterBits Description Type Reset
31:3 Reserved. - -
2 PRIVDEFENA : Controls whether the default memory map is enabled for
privileged softwareRW 0x0
1 HFNMIENA : Controls whether handlers executing with priority less than 0
access memory with the MPU enabled or disabled. This applies to HardFaults,
NMIs, and exception handlers when FAULTMASK is set to 1RW 0x0
0 ENABLE : Enables the MPU RW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 194
M33 : MPU_RNR Register
Offset : 0x0ed98
Description
Selects the region currently accessed by MPU_RBAR and MPU_RLAR
Table 234. MPU_RNR
RegisterBits Description Type Reset
31:3 Reserved. - -
2:0 REGION : Indicates the memory region accessed by MPU_RBAR and
MPU_RLARRW 0x0
M33 : MPU_RBAR Register
Offset : 0x0ed9c
Description
Provides indirect read and write access to the base address of the currently selected MPU region `FTSSS
Table 235. MPU_RBAR
RegisterBits Description Type Reset
31:5 BASE : Contains bits [31:5] of the lower inclusive limit of the selected MPU
memory region. This value is zero extended to provide the base address to be
checked againstRW 0x0000000
4:3 SH: Defines the Shareability domain of this region for Normal memory RW 0x0
2:1 AP: Defines the access permissions for this region RW 0x0
0 XN: Defines whether code can be executed from this region RW 0x0
M33 : MPU_RLAR Register
Offset : 0x0eda0
Description
Provides indirect read and write access to the limit address of the currently selected MPU region `FTSSS
Table 236. MPU_RLAR
RegisterBits Description Type Reset
31:5 LIMIT : Contains bits [31:5] of the upper inclusive limit of the selected MPU
memory region. This value is postfixed with 0x1F to provide the limit address
to be checked againstRW 0x0000000
4 Reserved. - -
3:1 ATTRINDX : Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1
fieldsRW 0x0
0 EN: Region enable RW 0x0
M33 : MPU_RBAR_A1 Register
Offset : 0x0eda4
Description
Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(1[1:0])
`FTSSS
RP2350 Datasheet
3.7. Cortex-M33 processor 195
Table 237.
MPU_RBAR_A1
RegisterBits Description Type Reset
31:5 BASE : Contains bits [31:5] of the lower inclusive limit of the selected MPU
memory region. This value is zero extended to provide the base address to be
checked againstRW 0x0000000
4:3 SH: Defines the Shareability domain of this region for Normal memory RW 0x0
2:1 AP: Defines the access permissions for this region RW 0x0
0 XN: Defines whether code can be executed from this region RW 0x0
M33 : MPU_RLAR_A1 Register
Offset : 0x0eda8
Description
Provides indirect read and write access to the limit address of the currently selected MPU region selected by
MPU_RNR[7:2]:(1[1:0]) `FTSSS
Table 238.
MPU_RLAR_A1
RegisterBits Description Type Reset
31:5 LIMIT : Contains bits [31:5] of the upper inclusive limit of the selected MPU
memory region. This value is postfixed with 0x1F to provide the limit address
to be checked againstRW 0x0000000
4 Reserved. - -
3:1 ATTRINDX : Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1
fieldsRW 0x0
0 EN: Region enable RW 0x0
M33 : MPU_RBAR_A2 Register
Offset : 0x0edac
Description
Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(2[1:0])
`FTSSS
Table 239.
MPU_RBAR_A2
RegisterBits Description Type Reset
31:5 BASE : Contains bits [31:5] of the lower inclusive limit of the selected MPU
memory region. This value is zero extended to provide the base address to be
checked againstRW 0x0000000
4:3 SH: Defines the Shareability domain of this region for Normal memory RW 0x0
2:1 AP: Defines the access permissions for this region RW 0x0
0 XN: Defines whether code can be executed from this region RW 0x0
M33 : MPU_RLAR_A2 Register
Offset : 0x0edb0
Description
Provides indirect read and write access to the limit address of the currently selected MPU region selected by
MPU_RNR[7:2]:(2[1:0]) `FTSSS
RP2350 Datasheet
3.7. Cortex-M33 processor 196
Table 240.
MPU_RLAR_A2
RegisterBits Description Type Reset
31:5 LIMIT : Contains bits [31:5] of the upper inclusive limit of the selected MPU
memory region. This value is postfixed with 0x1F to provide the limit address
to be checked againstRW 0x0000000
4 Reserved. - -
3:1 ATTRINDX : Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1
fieldsRW 0x0
0 EN: Region enable RW 0x0
M33 : MPU_RBAR_A3 Register
Offset : 0x0edb4
Description
Provides indirect read and write access to the base address of the MPU region selected by MPU_RNR[7:2]:(3[1:0])
`FTSSS
Table 241.
MPU_RBAR_A3
RegisterBits Description Type Reset
31:5 BASE : Contains bits [31:5] of the lower inclusive limit of the selected MPU
memory region. This value is zero extended to provide the base address to be
checked againstRW 0x0000000
4:3 SH: Defines the Shareability domain of this region for Normal memory RW 0x0
2:1 AP: Defines the access permissions for this region RW 0x0
0 XN: Defines whether code can be executed from this region RW 0x0
M33 : MPU_RLAR_A3 Register
Offset : 0x0edb8
Description
Provides indirect read and write access to the limit address of the currently selected MPU region selected by
MPU_RNR[7:2]:(3[1:0]) `FTSSS
Table 242.
MPU_RLAR_A3
RegisterBits Description Type Reset
31:5 LIMIT : Contains bits [31:5] of the upper inclusive limit of the selected MPU
memory region. This value is postfixed with 0x1F to provide the limit address
to be checked againstRW 0x0000000
4 Reserved. - -
3:1 ATTRINDX : Associates a set of attributes in the MPU_MAIR0 and MPU_MAIR1
fieldsRW 0x0
0 EN: Region enable RW 0x0
M33 : MPU_MAIR0 Register
Offset : 0x0edc0
Description
Along with MPU_MAIR1, provides the memory attribute encodings corresponding to the AttrIndex values
Table 243.
MPU_MAIR0 RegisterBits Description Type Reset
31:24 ATTR3 : Memory attribute encoding for MPU regions with an AttrIndex of 3 RW 0x00
RP2350 Datasheet
3.7. Cortex-M33 processor 197
Bits Description Type Reset
23:16 ATTR2 : Memory attribute encoding for MPU regions with an AttrIndex of 2 RW 0x00
15:8 ATTR1 : Memory attribute encoding for MPU regions with an AttrIndex of 1 RW 0x00
7:0 ATTR0 : Memory attribute encoding for MPU regions with an AttrIndex of 0 RW 0x00
M33 : MPU_MAIR1 Register
Offset : 0x0edc4
Description
Along with MPU_MAIR0, provides the memory attribute encodings corresponding to the AttrIndex values
Table 244.
MPU_MAIR1 RegisterBits Description Type Reset
31:24 ATTR7 : Memory attribute encoding for MPU regions with an AttrIndex of 7 RW 0x00
23:16 ATTR6 : Memory attribute encoding for MPU regions with an AttrIndex of 6 RW 0x00
15:8 ATTR5 : Memory attribute encoding for MPU regions with an AttrIndex of 5 RW 0x00
7:0 ATTR4 : Memory attribute encoding for MPU regions with an AttrIndex of 4 RW 0x00
M33 : SAU_CTRL Register
Offset : 0x0edd0
Description
Allows enabling of the Security Attribution Unit
Table 245. SAU_CTRL
RegisterBits Description Type Reset
31:2 Reserved. - -
1 ALLNS : When SAU_CTRL.ENABLE is 0 this bit controls if the memory is
marked as Non-secure or SecureRW 0x0
0 ENABLE : Enables the SAU RW 0x0
M33 : SAU_TYPE Register
Offset : 0x0edd4
Description
Indicates the number of regions implemented by the Security Attribution Unit
Table 246. SAU_TYPE
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 SREGION : The number of implemented SAU regions RO 0x08
M33 : SAU_RNR Register
Offset : 0x0edd8
Description
Selects the region currently accessed by SAU_RBAR and SAU_RLAR
Table 247. SAU_RNR
RegisterBits Description Type Reset
31:8 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 198
Bits Description Type Reset
7:0 REGION : Indicates the SAU region accessed by SAU_RBAR and SAU_RLAR RW 0x00
M33 : SAU_RBAR Register
Offset : 0x0eddc
Description
Provides indirect read and write access to the base address of the currently selected SAU region
Table 248. SAU_RBAR
RegisterBits Description Type Reset
31:5 BADDR : Holds bits [31:5] of the base address for the selected SAU region RW 0x0000000
4:0 Reserved. - -
M33 : SAU_RLAR Register
Offset : 0x0ede0
Description
Provides indirect read and write access to the limit address of the currently selected SAU region
Table 249. SAU_RLAR
RegisterBits Description Type Reset
31:5 LADDR : Holds bits [31:5] of the limit address for the selected SAU region RW 0x0000000
4:2 Reserved. - -
1 NSC : Controls whether Non-secure state is permitted to execute an SG
instruction from this regionRW 0x0
0 ENABLE : SAU region enable RW 0x0
M33 : SFSR Register
Offset : 0x0ede4
Description
Provides information about any security related faults
Table 250. SFSR
RegisterBits Description Type Reset
31:8 Reserved. - -
7 LSERR : Sticky flag indicating that an error occurred during lazy state activation
or deactivationRW 0x0
6 SFARVALID : This bit is set when the SFAR register contains a valid value. As
with similar fields, such as BFSR.BFARVALID and MMFSR.MMARVALID, this
bit can be cleared by other exceptions, such as BusFaultRW 0x0
5 LSPERR : Stick flag indicating that an SAU or IDAU violation occurred during
the lazy preservation of floating-point stateRW 0x0
4 INVTRAN : Sticky flag indicating that an exception was raised due to a branch
that was not flagged as being domain crossing causing a transition from
Secure to Non-secure memoryRW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 199
Bits Description Type Reset
3 AUVIOL : Sticky flag indicating that an attempt was made to access parts of
the address space that are marked as Secure with NS-Req for the transaction
set to Non-secure. This bit is not set if the violation occurred during lazy state
preservation. See LSPERRRW 0x0
2 INVER : This can be caused by EXC_RETURN.DCRS being set to 0 when
returning from an exception in the Non-secure state, or by EXC_RETURN.ES
being set to 1 when returning from an exception in the Non-secure stateRW 0x0
1 INVIS : This bit is set if the integrity signature in an exception stack frame is
found to be invalid during the unstacking operationRW 0x0
0 INVEP : This bit is set if a function call from the Non-secure state or exception
targets a non-SG instruction in the Secure state. This bit is also set if the
target address is a SG instruction, but there is no matching SAU/IDAU region
with the NSC flag setRW 0x0
M33 : SFAR Register
Offset : 0x0ede8
Description
Shows the address of the memory location that caused a Security violation
Table 251. SFAR
RegisterBits Description Type Reset
31:0 ADDRESS : The address of an access that caused a attribution unit violation.
This field is only valid when SFSR.SFARVALID is set. This allows the actual flip
flops associated with this register to be shared with other fault address
registers. If an implementation chooses to share the storage in this way, care
must be taken to not leak Secure address information to the Non-secure state.
One way of achieving this is to share the SFAR register with the MMFAR_S
register, which is not accessible to the Non-secure stateRW 0x00000000
M33 : DHCSR Register
Offset : 0x0edf0
Description
Controls halting debug
Table 252. DHCSR
RegisterBits Description Type Reset
31:27 Reserved. - -
26 S_RESTART_ST : Indicates the PE has processed a request to clear
DHCSR.C_HALT to 0. That is, either a write to DHCSR that clears
DHCSR.C_HALT from 1 to 0, or an External Restart RequestRO 0x0
25 S_RESET_ST : Indicates whether the PE has been reset since the last read of
the DHCSRRO 0x0
24 S_RETIRE_ST : Set to 1 every time the PE retires one of more instructions RO 0x0
23:21 Reserved. - -
20 S_SDE : Indicates whether Secure invasive debug is allowed RO 0x0
19 S_LOCKUP : Indicates whether the PE is in Lockup state RO 0x0
18 S_SLEEP : Indicates whether the PE is sleeping RO 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 200
Bits Description Type Reset
17 S_HALT : Indicates whether the PE is in Debug state RO 0x0
16 S_REGRDY : Handshake flag to transfers through the DCRDR RO 0x0
15:6 Reserved. - -
5 C_SNAPSTALL : Allow imprecise entry to Debug state RW 0x0
4 Reserved. - -
3 C_MASKINTS : When debug is enabled, the debugger can write to this bit to
mask PendSV, SysTick and external configurable interruptsRW 0x0
2 C_STEP : Enable single instruction step RW 0x0
1 C_HALT : PE enter Debug state halt request RW 0x0
0 C_DEBUGEN : Enable Halting debug RW 0x0
M33 : DCRSR Register
Offset : 0x0edf4
Description
With the DCRDR, provides debug access to the general-purpose registers, special-purpose registers, and the FP
extension registers. A write to the DCRSR specifies the register to transfer, whether the transfer is a read or write,
and starts the transfer
Table 253. DCRSR
RegisterBits Description Type Reset
31:17 Reserved. - -
16 REGWNR : Specifies the access type for the transfer RW 0x0
15:7 Reserved. - -
6:0 REGSEL : Specifies the general-purpose register, special-purpose register, or
FP register to transferRW 0x00
M33 : DCRDR Register
Offset : 0x0edf8
Description
With the DCRSR, provides debug access to the general-purpose registers, special-purpose registers, and the FP
Extension registers. If the Main Extension is implemented, it can also be used for message passing between an
external debugger and a debug agent running on the PE
Table 254. DCRDR
RegisterBits Description Type Reset
31:0 DBGTMP : Provides debug access for reading and writing the general-purpose
registers, special-purpose registers, and Floating-point Extension registersRW 0x00000000
M33 : DEMCR Register
Offset : 0x0edfc
Description
Manages vector catch behavior and DebugMonitor handling when debugging
Table 255. DEMCR
RegisterBits Description Type Reset
31:25 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 201
Bits Description Type Reset
24 TRCENA : Global enable for all DWT and ITM features RW 0x0
23:21 Reserved. - -
20 SDME : Indicates whether the DebugMonitor targets the Secure or the Non-
secure state and whether debug events are allowed in Secure stateRO 0x0
19 MON_REQ : DebugMonitor semaphore bit RW 0x0
18 MON_STEP : Enable DebugMonitor stepping RW 0x0
17 MON_PEND : Sets or clears the pending state of the DebugMonitor exception RW 0x0
16 MON_EN : Enable the DebugMonitor exception RW 0x0
15:12 Reserved. - -
11 VC_SFERR : SecureFault exception halting debug vector catch enable RW 0x0
10 VC_HARDERR : HardFault exception halting debug vector catch enable RW 0x0
9 VC_INTERR : Enable halting debug vector catch for faults during exception
entry and returnRW 0x0
8 VC_BUSERR : BusFault exception halting debug vector catch enable RW 0x0
7 VC_STATERR : Enable halting debug trap on a UsageFault exception caused by
a state information error, for example an Undefined Instruction exceptionRW 0x0
6 VC_CHKERR : Enable halting debug trap on a UsageFault exception caused by
a checking error, for example an alignment check errorRW 0x0
5 VC_NOCPERR : Enable halting debug trap on a UsageFault caused by an
access to a coprocessorRW 0x0
4 VC_MMERR : Enable halting debug trap on a MemManage exception RW 0x0
3:1 Reserved. - -
0 VC_CORERESET : Enable Reset Vector Catch. This causes a warm reset to halt
a running systemRW 0x0
M33 : DSCSR Register
Offset : 0x0ee08
Description
Provides control and status information for Secure debug
Table 256. DSCSR
RegisterBits Description Type Reset
31:18 Reserved. - -
17 CDSKEY : Writes to the CDS bit are ignored unless CDSKEY is concurrently
written to zeroRW 0x0
16 CDS : This field indicates the current Security state of the processor RW 0x0
15:2 Reserved. - -
1 SBRSEL : If SBRSELEN is 1 this bit selects whether the Non-secure or the
Secure version of the memory-mapped Banked registers are accessible to the
debuggerRW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 202
Bits Description Type Reset
0 SBRSELEN : Controls whether the SBRSEL field or the current Security state of
the processor selects which version of the memory-mapped Banked registers
are accessed to the debuggerRW 0x0
M33 : STIR Register
Offset : 0x0ef00
Description
Provides a mechanism for software to generate an interrupt
Table 257. STIR
RegisterBits Description Type Reset
31:9 Reserved. - -
8:0 INTID : Indicates the interrupt to be pended. The value written is
(ExceptionNumber - 16)RW 0x000
M33 : FPCCR Register
Offset : 0x0ef34
Description
Holds control data for the Floating-point extension
Table 258. FPCCR
RegisterBits Description Type Reset
31 ASPEN : When this bit is set to 1, execution of a floating-point instruction sets
the CONTROL.FPCA bit to 1RW 0x0
30 LSPEN : Enables lazy context save of floating-point state RW 0x0
29 LSPENS : This bit controls whether the LSPEN bit is writeable from the Non-
secure stateRW 0x1
28 CLRONRET : Clear floating-point caller saved registers on exception return RW 0x0
27 CLRONRETS : This bit controls whether the CLRONRET bit is writeable from the
Non-secure stateRW 0x0
26 TS: Treat floating-point registers as Secure enable RW 0x0
25:11 Reserved. - -
10 UFRDY : Indicates whether the software executing when the PE allocated the
floating-point stack frame was able to set the UsageFault exception to
pendingRW 0x1
9 SPLIMVIOL : This bit is banked between the Security states and indicates
whether the floating-point context violates the stack pointer limit that was
active when lazy state preservation was activated. SPLIMVIOL modifies the
lazy floating-point state preservation behaviorRW 0x0
8 MONRDY : Indicates whether the software executing when the PE allocated the
floating-point stack frame was able to set the DebugMonitor exception to
pendingRW 0x0
7 SFRDY : Indicates whether the software executing when the PE allocated the
floating-point stack frame was able to set the SecureFault exception to
pending. This bit is only present in the Secure version of the register, and
behaves as RAZ/WI when accessed from the Non-secure stateRW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 203
Bits Description Type Reset
6 BFRDY : Indicates whether the software executing when the PE allocated the
floating-point stack frame was able to set the BusFault exception to pendingRW 0x1
5 MMRDY : Indicates whether the software executing when the PE allocated the
floating-point stack frame was able to set the MemManage exception to
pendingRW 0x1
4 HFRDY : Indicates whether the software executing when the PE allocated the
floating-point stack frame was able to set the HardFault exception to pendingRW 0x1
3 THREAD : Indicates the PE mode when it allocated the floating-point stack
frameRW 0x0
2 S: Security status of the floating-point context. This bit is only present in the
Secure version of the register, and behaves as RAZ/WI when accessed from
the Non-secure state. This bit is updated whenever lazy state preservation is
activated, or when a floating-point instruction is executedRW 0x0
1 USER : Indicates the privilege level of the software executing when the PE
allocated the floating-point stack frameRW 0x1
0 LSPACT : Indicates whether lazy preservation of the floating-point state is
activeRW 0x0
M33 : FPCAR Register
Offset : 0x0ef38
Description
Holds the location of the unpopulated floating-point register space allocated on an exception stack frame
Table 259. FPCAR
RegisterBits Description Type Reset
31:3 ADDRESS : The location of the unpopulated floating-point register space
allocated on an exception stack frameRW 0x00000000
2:0 Reserved. - -
M33 : FPDSCR Register
Offset : 0x0ef3c
Description
Holds the default values for the floating-point status control data that the PE assigns to the FPSCR when it creates
a new floating-point context
Table 260. FPDSCR
RegisterBits Description Type Reset
31:27 Reserved. - -
26 AHP : Default value for FPSCR.AHP RW 0x0
25 DN: Default value for FPSCR.DN RW 0x0
24 FZ: Default value for FPSCR.FZ RW 0x0
23:22 RMODE : Default value for FPSCR.RMode RW 0x0
21:0 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 204
M33 : MVFR0 Register
Offset : 0x0ef40
Description
Describes the features provided by the Floating-point Extension
Table 261. MVFR0
RegisterBits Description Type Reset
31:28 FPROUND : Indicates the rounding modes supported by the FP Extension RO 0x6
27:24 Reserved. - -
23:20 FPSQRT : Indicates the support for FP square root operations RO 0x5
19:16 FPDIVIDE : Indicates the support for FP divide operations RO 0x4
15:12 Reserved. - -
11:8 FPDP : Indicates support for FP double-precision operations RO 0x6
7:4 FPSP : Indicates support for FP single-precision operations RO 0x0
3:0 SIMDREG : Indicates size of FP register file RO 0x1
M33 : MVFR1 Register
Offset : 0x0ef44
Description
Describes the features provided by the Floating-point Extension
Table 262. MVFR1
RegisterBits Description Type Reset
31:28 FMAC : Indicates whether the FP Extension implements the fused multiply
accumulate instructionsRO 0x8
27:24 FPHP : Indicates whether the FP Extension implements half-precision FP
conversion instructionsRO 0x5
23:8 Reserved. - -
7:4 FPDNAN : Indicates whether the FP hardware implementation supports NaN
propagationRO 0x8
3:0 FPFTZ : Indicates whether subnormals are always flushed-to-zero RO 0x9
M33 : MVFR2 Register
Offset : 0x0ef48
Description
Describes the features provided by the Floating-point Extension
Table 263. MVFR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 FPMISC : Indicates support for miscellaneous FP features RO 0x6
3:0 Reserved. - -
M33 : DDEVARCH Register
Offset : 0x0efbc
RP2350 Datasheet
3.7. Cortex-M33 processor 205
Description
Provides CoreSight discovery information for the SCS
Table 264. DDEVARCH
RegisterBits Description Type Reset
31:21 ARCHITECT : Defines the architect of the component. Bits [31:28] are the
JEP106 continuation code (JEP106 bank ID, minus 1) and bits [27:21] are the
JEP106 ID code.RO 0x23b
20 PRESENT : Defines that the DEVARCH register is present RO 0x1
19:16 REVISION : Defines the architecture revision of the component RO 0x0
15:12 ARCHVER : Defines the architecture version of the component RO 0x2
11:0 ARCHPART : Defines the architecture of the component RO 0xa04
M33 : DDEVTYPE Register
Offset : 0x0efcc
Description
Provides CoreSight discovery information for the SCS
Table 265. DDEVTYPE
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SUB : Component sub-type RO 0x0
3:0 MAJOR : CoreSight major type RO 0x0
M33 : DPIDR4 Register
Offset : 0x0efd0
Description
Provides CoreSight discovery information for the SCS
Table 266. DPIDR4
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SIZE : See CoreSight Architecture Specification RO 0x0
3:0 DES_2 : See CoreSight Architecture Specification RO 0x4
M33 : DPIDR5 Register
Offset : 0x0efd4
Description
Provides CoreSight discovery information for the SCS
Table 267. DPIDR5
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : DPIDR6 Register
Offset : 0x0efd8
RP2350 Datasheet
3.7. Cortex-M33 processor 206
Description
Provides CoreSight discovery information for the SCS
Table 268. DPIDR6
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : DPIDR7 Register
Offset : 0x0efdc
Description
Provides CoreSight discovery information for the SCS
Table 269. DPIDR7
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : DPIDR0 Register
Offset : 0x0efe0
Description
Provides CoreSight discovery information for the SCS
Table 270. DPIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PART_0 : See CoreSight Architecture Specification RO 0x21
M33 : DPIDR1 Register
Offset : 0x0efe4
Description
Provides CoreSight discovery information for the SCS
Table 271. DPIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 DES_0 : See CoreSight Architecture Specification RO 0xb
3:0 PART_1 : See CoreSight Architecture Specification RO 0xd
M33 : DPIDR2 Register
Offset : 0x0efe8
Description
Provides CoreSight discovery information for the SCS
Table 272. DPIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVISION : See CoreSight Architecture Specification RO 0x0
3 JEDEC : See CoreSight Architecture Specification RO 0x1
2:0 DES_1 : See CoreSight Architecture Specification RO 0x3
RP2350 Datasheet
3.7. Cortex-M33 processor 207
M33 : DPIDR3 Register
Offset : 0x0efec
Description
Provides CoreSight discovery information for the SCS
Table 273. DPIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVAND : See CoreSight Architecture Specification RO 0x0
3:0 CMOD : See CoreSight Architecture Specification RO 0x0
M33 : DCIDR0 Register
Offset : 0x0eff0
Description
Provides CoreSight discovery information for the SCS
Table 274. DCIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_0 : See CoreSight Architecture Specification RO 0x0d
M33 : DCIDR1 Register
Offset : 0x0eff4
Description
Provides CoreSight discovery information for the SCS
Table 275. DCIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 CLASS : See CoreSight Architecture Specification RO 0x9
3:0 PRMBL_1 : See CoreSight Architecture Specification RO 0x0
M33 : DCIDR2 Register
Offset : 0x0eff8
Description
Provides CoreSight discovery information for the SCS
Table 276. DCIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_2 : See CoreSight Architecture Specification RO 0x05
M33 : DCIDR3 Register
Offset : 0x0effc
Description
Provides CoreSight discovery information for the SCS
RP2350 Datasheet
3.7. Cortex-M33 processor 208
Table 277. DCIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_3 : See CoreSight Architecture Specification RO 0xb1
M33 : TRCPRGCTLR Register
Offset : 0x41004
Description
Programming Control Register
Table 278.
TRCPRGCTLR RegisterBits Description Type Reset
31:1 Reserved. - -
0 EN: Trace Unit Enable RW 0x0
M33 : TRCSTATR Register
Offset : 0x4100c
Description
The TRCSTATR indicates the ETM-Teal status
Table 279. TRCSTATR
RegisterBits Description Type Reset
31:2 Reserved. - -
1 PMSTABLE : Indicates whether the ETM-Teal registers are stable and can be
readRO 0x0
0 IDLE : Indicates that the trace unit is inactive RO 0x0
M33 : TRCCONFIGR Register
Offset : 0x41010
Description
The TRCCONFIGR sets the basic tracing options for the trace unit
Table 280.
TRCCONFIGR RegisterBits Description Type Reset
31:13 Reserved. - -
12 RS: Resturn stack enable RW 0x0
11 TS: Global timestamp tracing RW 0x0
10:5 COND : Conditional instruction tracing RW 0x00
4 CCI: Cycle counting in instruction trace RW 0x0
3 BB: Branch broadcast mode RW 0x0
2:0 Reserved. - -
M33 : TRCEVENTCTL0R Register
Offset : 0x41020
Description
The TRCEVENTCTL0R controls the tracing of events in the trace stream. The events also drive the ETM-Teal
RP2350 Datasheet
3.7. Cortex-M33 processor 209
external outputs.
Table 281.
TRCEVENTCTL0R
RegisterBits Description Type Reset
31:16 Reserved. - -
15 TYPE1 : Selects the resource type for event 1 RW 0x0
14:11 Reserved. - -
10:8 SEL1 : Selects the resource number, based on the value of TYPE1: When
TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL1[2:0].
When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined
by SEL1[2:0]RW 0x0
7 TYPE0 : Selects the resource type for event 0 RW 0x0
6:3 Reserved. - -
2:0 SEL0 : Selects the resource number, based on the value of TYPE0: When
TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].
When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined
by SEL0[2:0]RW 0x0
M33 : TRCEVENTCTL1R Register
Offset : 0x41024
Description
The TRCEVENTCTL1R controls how the events selected by TRCEVENTCTL0R behave
Table 282.
TRCEVENTCTL1R
RegisterBits Description Type Reset
31:13 Reserved. - -
12 LPOVERRIDE : Low power state behavior override RW 0x0
11 ATB : ATB enabled RW 0x0
10:2 Reserved. - -
1 INSTEN1 : One bit per event, to enable generation of an event element in the
instruction trace stream when the selected event occursRW 0x0
0 INSTEN0 : One bit per event, to enable generation of an event element in the
instruction trace stream when the selected event occursRW 0x0
M33 : TRCSTALLCTLR Register
Offset : 0x4102c
Description
The TRCSTALLCTLR enables ETM-Teal to stall the processor if the ETM-Teal FIFO goes over the programmed level
to minimize risk of overflow
Table 283.
TRCSTALLCTLR
RegisterBits Description Type Reset
31:11 Reserved. - -
10 INSTPRIORITY : Reserved, RES0 RO 0x0
9 Reserved. - -
8 ISTALL : Stall processor based on instruction trace buffer space RW 0x0
7:4 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 210
Bits Description Type Reset
3:2 LEVEL : Threshold at which stalling becomes active. This provides four levels.
This level can be varied to optimize the level of invasion caused by stalling,
balanced against the risk of a FIFO overflowRW 0x0
1:0 Reserved. - -
M33 : TRCTSCTLR Register
Offset : 0x41030
Description
The TRCTSCTLR controls the insertion of global timestamps into the trace stream. A timestamp is always inserted
into the instruction trace stream
Table 284.
TRCTSCTLR RegisterBits Description Type Reset
31:8 Reserved. - -
7 TYPE0 : Selects the resource type for event 0 RW 0x0
6:2 Reserved. - -
1:0 SEL0 : Selects the resource number, based on the value of TYPE0: When
TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].
When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined
by SEL0[2:0]RW 0x0
M33 : TRCSYNCPR Register
Offset : 0x41034
Description
The TRCSYNCPR specifies the period of trace synchronization of the trace streams. TRCSYNCPR defines a number
of bytes of trace between requests for trace synchronization. This value is always a power of two
Table 285.
TRCSYNCPR RegisterBits Description Type Reset
31:5 Reserved. - -
4:0 PERIOD : Defines the number of bytes of trace between trace synchronization
requests as a total of the number of bytes generated by the instruction
stream. The number of bytes is 2N where N is the value of this field: - A value
of zero disables these periodic trace synchronization requests, but does not
disable other trace synchronization requests. - The minimum value that can be
programmed, other than zero, is 8, providing a minimum trace synchronization
period of 256 bytes. - The maximum value is 20, providing a maximum trace
synchronization period of 2^20 bytesRO 0x0a
M33 : TRCCCCTLR Register
Offset : 0x41038
Description
The TRCCCCTLR sets the threshold value for instruction trace cycle counting. The threshold represents the
minimum interval between cycle count trace packets
Table 286.
TRCCCCTLR RegisterBits Description Type Reset
31:12 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 211
Bits Description Type Reset
11:0 THRESHOLD : Instruction trace cycle count threshold RW 0x000
M33 : TRCVICTLR Register
Offset : 0x41080
Description
The TRCVICTLR controls instruction trace filtering
Table 287. TRCVICTLR
RegisterBits Description Type Reset
31:20 Reserved. - -
19 EXLEVEL_S3 : In Secure state, each bit controls whether instruction tracing is
enabled for the corresponding exception levelRW 0x0
18:17 Reserved. - -
16 EXLEVEL_S0 : In Secure state, each bit controls whether instruction tracing is
enabled for the corresponding exception levelRW 0x0
15:12 Reserved. - -
11 TRCERR : Selects whether a system error exception must always be traced RW 0x0
10 TRCRESET : Selects whether a reset exception must always be traced RW 0x0
9 SSSTATUS : Indicates the current status of the start/stop logic RW 0x0
8 Reserved. - -
7 TYPE0 : Selects the resource type for event 0 RW 0x0
6:2 Reserved. - -
1:0 SEL0 : Selects the resource number, based on the value of TYPE0: When
TYPE1 is 0, selects a single selected resource from 0-15 defined by SEL0[2:0].
When TYPE1 is 1, selects a Boolean combined resource pair from 0-7 defined
by SEL0[2:0]RW 0x0
M33 : TRCCNTRLDVR0 Register
Offset : 0x41140
Description
The TRCCNTRLDVR defines the reload value for the reduced function counter
Table 288.
TRCCNTRLDVR0
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 VALUE : Defines the reload value for the counter. This value is loaded into the
counter each time the reload event occursRW 0x0000
M33 : TRCIDR8 Register
Offset : 0x41180
Description
TRCIDR8
RP2350 Datasheet
3.7. Cortex-M33 processor 212
Table 289. TRCIDR8
RegisterBits Description Type Reset
31:0 MAXSPEC : reads as `ImpDef RO 0x00000000
M33 : TRCIDR9 Register
Offset : 0x41184
Description
TRCIDR9
Table 290. TRCIDR9
RegisterBits Description Type Reset
31:0 NUMP0KEY : reads as `ImpDef RO 0x00000000
M33 : TRCIDR10 Register
Offset : 0x41188
Description
TRCIDR10
Table 291. TRCIDR10
RegisterBits Description Type Reset
31:0 NUMP1KEY : reads as `ImpDef RO 0x00000000
M33 : TRCIDR11 Register
Offset : 0x4118c
Description
TRCIDR11
Table 292. TRCIDR11
RegisterBits Description Type Reset
31:0 NUMP1SPC : reads as `ImpDef RO 0x00000000
M33 : TRCIDR12 Register
Offset : 0x41190
Description
TRCIDR12
Table 293. TRCIDR12
RegisterBits Description Type Reset
31:0 NUMCONDKEY : reads as `ImpDef RO 0x00000001
M33 : TRCIDR13 Register
Offset : 0x41194
Description
TRCIDR13
RP2350 Datasheet
3.7. Cortex-M33 processor 213
Table 294. TRCIDR13
RegisterBits Description Type Reset
31:0 NUMCONDSPC : reads as `ImpDef RO 0x00000000
M33 : TRCIMSPEC Register
Offset : 0x411c0
Description
The TRCIMSPEC shows the presence of any IMPLEMENTATION SPECIFIC features, and enables any features that
are provided
Table 295.
TRCIMSPEC RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 SUPPORT : Reserved, RES0 RO 0x0
M33 : TRCIDR0 Register
Offset : 0x411e0
Description
TRCIDR0
Table 296. TRCIDR0
RegisterBits Description Type Reset
31:30 Reserved. - -
29 COMMOPT : reads as `ImpDef RO 0x1
28:24 TSSIZE : reads as `ImpDef RO 0x08
23:18 Reserved. - -
17 TRCEXDATA : reads as `ImpDef RO 0x0
16:15 QSUPP : reads as `ImpDef RO 0x0
14 QFILT : reads as `ImpDef RO 0x0
13:12 CONDTYPE : reads as `ImpDef RO 0x0
11:10 NUMEVENT : reads as `ImpDef RO 0x1
9 RETSTACK : reads as `ImpDef RO 0x1
8 Reserved. - -
7 TRCCCI : reads as `ImpDef RO 0x1
6 TRCCOND : reads as `ImpDef RO 0x1
5 TRCBB : reads as `ImpDef RO 0x1
4:3 TRCDATA : reads as `ImpDef RO 0x0
2:1 INSTP0 : reads as `ImpDef RO 0x0
0 RES1 : Reserved, RES1 RO 0x1
M33 : TRCIDR1 Register
Offset : 0x411e4
Description
TRCIDR1
RP2350 Datasheet
3.7. Cortex-M33 processor 214
Table 297. TRCIDR1
RegisterBits Description Type Reset
31:24 DESIGNER : reads as `ImpDef RO 0x41
23:16 Reserved. - -
15:12 RES1 : Reserved, RES1 RO 0xf
11:8 TRCARCHMAJ : reads as 0b0100 RO 0x4
7:4 TRCARCHMIN : reads as 0b0000 RO 0x2
3:0 REVISION : reads as `ImpDef RO 0x1
M33 : TRCIDR2 Register
Offset : 0x411e8
Description
TRCIDR2
Table 298. TRCIDR2
RegisterBits Description Type Reset
31:29 Reserved. - -
28:25 CCSIZE : reads as `ImpDef RO 0x0
24:20 DVSIZE : reads as `ImpDef RO 0x00
19:15 DASIZE : reads as `ImpDef RO 0x00
14:10 VMIDSIZE : reads as `ImpDef RO 0x00
9:5 CIDSIZE : reads as `ImpDef RO 0x00
4:0 IASIZE : reads as `ImpDef RO 0x04
M33 : TRCIDR3 Register
Offset : 0x411ec
Description
TRCIDR3
Table 299. TRCIDR3
RegisterBits Description Type Reset
31 NOOVERFLOW : reads as `ImpDef RO 0x0
30:28 NUMPROC : reads as `ImpDef RO 0x0
27 SYSSTALL : reads as `ImpDef RO 0x1
26 STALLCTL : reads as `ImpDef RO 0x1
25 SYNCPR : reads as `ImpDef RO 0x1
24 TRCERR : reads as `ImpDef RO 0x1
23:20 EXLEVEL_NS : reads as `ImpDef RO 0x0
19:16 EXLEVEL_S : reads as `ImpDef RO 0x9
15:12 Reserved. - -
11:0 CCITMIN : reads as `ImpDef RO 0x004
M33 : TRCIDR4 Register
RP2350 Datasheet
3.7. Cortex-M33 processor 215
Offset : 0x411f0
Description
TRCIDR4
Table 300. TRCIDR4
RegisterBits Description Type Reset
31:28 NUMVMIDC : reads as `ImpDef RO 0x0
27:24 NUMCIDC : reads as `ImpDef RO 0x0
23:20 NUMSSCC : reads as `ImpDef RO 0x1
19:16 NUMRSPAIR : reads as `ImpDef RO 0x1
15:12 NUMPC : reads as `ImpDef RO 0x4
11:9 Reserved. - -
8 SUPPDAC : reads as `ImpDef RO 0x0
7:4 NUMDVC : reads as `ImpDef RO 0x0
3:0 NUMACPAIRS : reads as `ImpDef RO 0x0
M33 : TRCIDR5 Register
Offset : 0x411f4
Description
TRCIDR5
Table 301. TRCIDR5
RegisterBits Description Type Reset
31 REDFUNCNTR : reads as `ImpDef RO 0x1
30:28 NUMCNTR : reads as `ImpDef RO 0x1
27:25 NUMSEQSTATE : reads as `ImpDef RO 0x0
24 Reserved. - -
23 LPOVERRIDE : reads as `ImpDef RO 0x1
22 ATBTRIG : reads as `ImpDef RO 0x1
21:16 TRACEIDSIZE : reads as 0x07 RO 0x07
15:12 Reserved. - -
11:9 NUMEXTINSEL : reads as `ImpDef RO 0x0
8:0 NUMEXTIN : reads as `ImpDef RO 0x004
M33 : TRCIDR6 Register
Offset : 0x411f8
Description
TRCIDR6
RP2350 Datasheet
3.7. Cortex-M33 processor 216
Table 302. TRCIDR6
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : TRCIDR7 Register
Offset : 0x411fc
Description
TRCIDR7
Table 303. TRCIDR7
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : TRCRSCTLR2 Register
Offset : 0x41208
Description
The TRCRSCTLR controls the trace resources
Table 304.
TRCRSCTLR2 RegisterBits Description Type Reset
31:22 Reserved. - -
21 PAIRINV : Inverts the result of a combined pair of resources. This bit is only
implemented on the lower register for a pair of resource selectorsRW 0x0
20 INV: Inverts the selected resources RW 0x0
19 Reserved. - -
18:16 GROUP : Selects a group of resource RW 0x0
15:8 Reserved. - -
7:0 SELECT : Selects one or more resources from the wanted group. One bit is
provided per resource from the groupRW 0x00
M33 : TRCRSCTLR3 Register
Offset : 0x4120c
Description
The TRCRSCTLR controls the trace resources
Table 305.
TRCRSCTLR3 RegisterBits Description Type Reset
31:22 Reserved. - -
21 PAIRINV : Inverts the result of a combined pair of resources. This bit is only
implemented on the lower register for a pair of resource selectorsRW 0x0
20 INV: Inverts the selected resources RW 0x0
19 Reserved. - -
18:16 GROUP : Selects a group of resource RW 0x0
15:8 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 217
Bits Description Type Reset
7:0 SELECT : Selects one or more resources from the wanted group. One bit is
provided per resource from the groupRW 0x00
M33 : TRCSSCSR Register
Offset : 0x412a0
Description
Controls the corresponding single-shot comparator resource
Table 306. TRCSSCSR
RegisterBits Description Type Reset
31 STATUS : Single-shot status bit. Indicates if any of the comparators, that
TRCSSCCRn.SAC or TRCSSCCRn.ARC selects, have matchedRW 0x0
30:4 Reserved. - -
3 PC: Reserved, RES1 RO 0x0
2 DV: Reserved, RES0 RO 0x0
1 DA: Reserved, RES0 RO 0x0
0 INST : Reserved, RES0 RO 0x0
M33 : TRCSSPCICR Register
Offset : 0x412c0
Description
Selects the PE comparator inputs for Single-shot control
Table 307.
TRCSSPCICR RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 PC: Selects one or more PE comparator inputs for Single-shot control.
TRCIDR4.NUMPC defines the size of the PC field. 1 bit is provided for each
implemented PE comparator input. For example, if bit[1] == 1 this selects PE
comparator input 1 for Single-shot controlRW 0x0
M33 : TRCPDCR Register
Offset : 0x41310
Description
Requests the system to provide power to the trace unit
Table 308. TRCPDCR
RegisterBits Description Type Reset
31:4 Reserved. - -
3 PU: Powerup request bit: RW 0x0
2:0 Reserved. - -
M33 : TRCPDSR Register
Offset : 0x41314
RP2350 Datasheet
3.7. Cortex-M33 processor 218
Description
Returns the following information about the trace unit: - OS Lock status. - Core power domain status. - Power
interruption status
Table 309. TRCPDSR
RegisterBits Description Type Reset
31:6 Reserved. - -
5 OSLK : OS Lock status bit: RO 0x0
4:2 Reserved. - -
1 STICKYPD : Sticky powerdown status bit. Indicates whether the trace register
state is valid:RO 0x1
0 POWER : Power status bit: RO 0x1
M33 : TRCITATBIDR Register
Offset : 0x41ee4
Description
Trace Intergration ATB Identification Register
Table 310.
TRCITATBIDR RegisterBits Description Type Reset
31:7 Reserved. - -
6:0 ID: Trace ID RW 0x00
M33 : TRCITIATBINR Register
Offset : 0x41ef4
Description
Trace Integration Instruction ATB In Register
Table 311.
TRCITIATBINR
RegisterBits Description Type Reset
31:2 Reserved. - -
1 AFVALIDM : Integration Mode instruction AFVALIDM in RW 0x0
0 ATREADYM : Integration Mode instruction ATREADYM in RW 0x0
M33 : TRCITIATBOUTR Register
Offset : 0x41efc
Description
Trace Integration Instruction ATB Out Register
Table 312.
TRCITIATBOUTR
RegisterBits Description Type Reset
31:2 Reserved. - -
1 AFREADY : Integration Mode instruction AFREADY out RW 0x0
0 ATVALID : Integration Mode instruction ATVALID out RW 0x0
M33 : TRCCLAIMSET Register
Offset : 0x41fa0
RP2350 Datasheet
3.7. Cortex-M33 processor 219
Description
Claim Tag Set Register
Table 313.
TRCCLAIMSET
RegisterBits Description Type Reset
31:4 Reserved. - -
3 SET3 : When a write to one of these bits occurs, with the value: RW 0x1
2 SET2 : When a write to one of these bits occurs, with the value: RW 0x1
1 SET1 : When a write to one of these bits occurs, with the value: RW 0x1
0 SET0 : When a write to one of these bits occurs, with the value: RW 0x1
M33 : TRCCLAIMCLR Register
Offset : 0x41fa4
Description
Claim Tag Clear Register
Table 314.
TRCCLAIMCLR
RegisterBits Description Type Reset
31:4 Reserved. - -
3 CLR3 : When a write to one of these bits occurs, with the value: RW 0x0
2 CLR2 : When a write to one of these bits occurs, with the value: RW 0x0
1 CLR1 : When a write to one of these bits occurs, with the value: RW 0x0
0 CLR0 : When a write to one of these bits occurs, with the value: RW 0x0
M33 : TRCAUTHSTATUS Register
Offset : 0x41fb8
Description
Returns the level of tracing that the trace unit can support
Table 315.
TRCAUTHSTATUS
RegisterBits Description Type Reset
31:8 Reserved. - -
7:6 SNID : Indicates whether the system enables the trace unit to support Secure
non-invasive debug:RO 0x0
5:4 SID: Indicates whether the trace unit supports Secure invasive debug: RO 0x0
3:2 NSNID : Indicates whether the system enables the trace unit to support Non-
secure non-invasive debug:RO 0x0
1:0 NSID : Indicates whether the trace unit supports Non-secure invasive debug: RO 0x0
M33 : TRCDEVARCH Register
Offset : 0x41fbc
Description
TRCDEVARCH
Table 316.
TRCDEVARCH RegisterBits Description Type Reset
31:21 ARCHITECT : reads as 0b01000111011 RO 0x23b
RP2350 Datasheet
3.7. Cortex-M33 processor 220
Bits Description Type Reset
20 PRESENT : reads as 0b1 RO 0x1
19:16 REVISION : reads as 0b0000 RO 0x2
15:0 ARCHID : reads as 0b0100101000010011 RO 0x4a13
M33 : TRCDEVID Register
Offset : 0x41fc8
Description
TRCDEVID
Table 317. TRCDEVID
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : TRCDEVTYPE Register
Offset : 0x41fcc
Description
TRCDEVTYPE
Table 318.
TRCDEVTYPE RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SUB : reads as 0b0001 RO 0x1
3:0 MAJOR : reads as 0b0011 RO 0x3
M33 : TRCPIDR4 Register
Offset : 0x41fd0
Description
TRCPIDR4
Table 319. TRCPIDR4
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SIZE : reads as `ImpDef RO 0x0
3:0 DES_2 : reads as `ImpDef RO 0x4
M33 : TRCPIDR5 Register
Offset : 0x41fd4
Description
TRCPIDR5
RP2350 Datasheet
3.7. Cortex-M33 processor 221
Table 320. TRCPIDR5
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : TRCPIDR6 Register
Offset : 0x41fd8
Description
TRCPIDR6
Table 321. TRCPIDR6
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : TRCPIDR7 Register
Offset : 0x41fdc
Description
TRCPIDR7
Table 322. TRCPIDR7
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : TRCPIDR0 Register
Offset : 0x41fe0
Description
TRCPIDR0
Table 323. TRCPIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PART_0 : reads as `ImpDef RO 0x21
M33 : TRCPIDR1 Register
Offset : 0x41fe4
Description
TRCPIDR1
Table 324. TRCPIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 DES_0 : reads as `ImpDef RO 0xb
3:0 PART_0 : reads as `ImpDef RO 0xd
M33 : TRCPIDR2 Register
Offset : 0x41fe8
Description
TRCPIDR2
RP2350 Datasheet
3.7. Cortex-M33 processor 222
Table 325. TRCPIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVISION : reads as `ImpDef RO 0x2
3 JEDEC : reads as 0b1 RO 0x1
2:0 DES_0 : reads as `ImpDef RO 0x3
M33 : TRCPIDR3 Register
Offset : 0x41fec
Description
TRCPIDR3
Table 326. TRCPIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVAND : reads as `ImpDef RO 0x0
3:0 CMOD : reads as `ImpDef RO 0x0
M33 : TRCCIDR0 Register
Offset : 0x41ff0
Description
TRCCIDR0
Table 327. TRCCIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_0 : reads as 0b00001101 RO 0x0d
M33 : TRCCIDR1 Register
Offset : 0x41ff4
Description
TRCCIDR1
Table 328. TRCCIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 CLASS : reads as 0b1001 RO 0x9
3:0 PRMBL_1 : reads as 0b0000 RO 0x0
M33 : TRCCIDR2 Register
Offset : 0x41ff8
Description
TRCCIDR2
RP2350 Datasheet
3.7. Cortex-M33 processor 223
Table 329. TRCCIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_2 : reads as 0b00000101 RO 0x05
M33 : TRCCIDR3 Register
Offset : 0x41ffc
Description
TRCCIDR3
Table 330. TRCCIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_3 : reads as 0b10110001 RO 0xb1
M33 : CTICONTROL Register
Offset : 0x42000
Description
CTI Control Register
Table 331.
CTICONTROL RegisterBits Description Type Reset
31:1 Reserved. - -
0 GLBEN : Enables or disables the CTI RW 0x0
M33 : CTIINTACK Register
Offset : 0x42010
Description
CTI Interrupt Acknowledge Register
Table 332. CTIINTACK
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 INTACK : Acknowledges the corresponding ctitrigout output. There is one bit
of the register for each ctitrigout output. When a 1 is written to a bit in this
register, the corresponding ctitrigout is acknowledged, causing it to be
cleared.RW 0x00
M33 : CTIAPPSET Register
Offset : 0x42014
Description
CTI Application Trigger Set Register
RP2350 Datasheet
3.7. Cortex-M33 processor 224
Table 333. CTIAPPSET
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 APPSET : Setting a bit HIGH generates a channel event for the selected
channel. There is one bit of the register for each channelRW 0x0
M33 : CTIAPPCLEAR Register
Offset : 0x42018
Description
CTI Application Trigger Clear Register
Table 334.
CTIAPPCLEAR
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 APPCLEAR : Sets the corresponding bits in the CTIAPPSET to 0. There is one
bit of the register for each channel.RW 0x0
M33 : CTIAPPPULSE Register
Offset : 0x4201c
Description
CTI Application Pulse Register
Table 335.
CTIAPPPULSE
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 APPULSE : Setting a bit HIGH generates a channel event pulse for the selected
channel. There is one bit of the register for each channel.RW 0x0
M33 : CTIINEN0, CTIINEN1, …, CTIINEN6, CTIINEN7 Registers
Offsets : 0x42020, 0x42024, …, 0x42038, 0x4203c
Description
CTI Trigger to Channel Enable Registers
Table 336. CTIINEN0,
CTIINEN1, …,
CTIINEN6, CTIINEN7
RegistersBits Description Type Reset
31:4 Reserved. - -
3:0 TRIGINEN : Enables a cross trigger event to the corresponding channel when a
ctitrigin input is activated. There is one bit of the field for each of the four
channelsRW 0x0
M33 : CTIOUTEN0, CTIOUTEN1, …, CTIOUTEN6, CTIOUTEN7 Registers
Offsets : 0x420a0, 0x420a4, …, 0x420b8, 0x420bc
Description
CTI Trigger to Channel Enable Registers
Table 337.
CTIOUTEN0,
CTIOUTEN1, …,
CTIOUTEN6,
CTIOUTEN7 RegistersBits Description Type Reset
31:4 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 225
Bits Description Type Reset
3:0 TRIGOUTEN : Enables a cross trigger event to ctitrigout when the
corresponding channel is activated. There is one bit of the field for each of the
four channels.RW 0x0
M33 : CTITRIGINSTATUS Register
Offset : 0x42130
Description
CTI Trigger to Channel Enable Registers
Table 338.
CTITRIGINSTATUS
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 TRIGINSTATUS : Shows the status of the ctitrigin inputs. There is one bit of the
field for each trigger input.Because the register provides a view of the raw
ctitrigin inputs, the reset value is UNKNOWN.RO 0x00
M33 : CTITRIGOUTSTATUS Register
Offset : 0x42134
Description
CTI Trigger In Status Register
Table 339.
CTITRIGOUTSTATUS
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 TRIGOUTSTATUS : Shows the status of the ctitrigout outputs. There is one bit
of the field for each trigger output.RO 0x00
M33 : CTICHINSTATUS Register
Offset : 0x42138
Description
CTI Channel In Status Register
Table 340.
CTICHINSTATUS
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 CTICHOUTSTATUS : Shows the status of the ctichout outputs. There is one bit
of the field for each channel outputRO 0x0
M33 : CTIGATE Register
Offset : 0x42140
Description
Enable CTI Channel Gate register
Table 341. CTIGATE
RegisterBits Description Type Reset
31:4 Reserved. - -
3 CTIGATEEN3 : Enable ctichout3. Set to 0 to disable channel propagation. RW 0x1
2 CTIGATEEN2 : Enable ctichout2. Set to 0 to disable channel propagation. RW 0x1
RP2350 Datasheet
3.7. Cortex-M33 processor 226
Bits Description Type Reset
1 CTIGATEEN1 : Enable ctichout1. Set to 0 to disable channel propagation. RW 0x1
0 CTIGATEEN0 : Enable ctichout0. Set to 0 to disable channel propagation. RW 0x1
M33 : ASICCTL Register
Offset : 0x42144
Description
External Multiplexer Control register
Table 342. ASICCTL
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : ITCHOUT Register
Offset : 0x42ee4
Description
Integration Test Channel Output register
Table 343. ITCHOUT
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 CTCHOUT : Sets the value of the ctichout outputs RW 0x0
M33 : ITTRIGOUT Register
Offset : 0x42ee8
Description
Integration Test Trigger Output register
Table 344. ITTRIGOUT
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 CTTRIGOUT : Sets the value of the ctitrigout outputs RW 0x00
M33 : ITCHIN Register
Offset : 0x42ef4
Description
Integration Test Channel Input register
Table 345. ITCHIN
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 CTCHIN : Reads the value of the ctichin inputs. RO 0x0
M33 : ITCTRL Register
Offset : 0x42f00
Description
Integration Mode Control register
RP2350 Datasheet
3.7. Cortex-M33 processor 227
Table 346. ITCTRL
RegisterBits Description Type Reset
31:1 Reserved. - -
0 IME: Integration Mode Enable RW 0x0
M33 : DEVARCH Register
Offset : 0x42fbc
Description
Device Architecture register
Table 347. DEVARCH
RegisterBits Description Type Reset
31:21 ARCHITECT : Indicates the component architect RO 0x23b
20 PRESENT : Indicates whether the DEVARCH register is present RO 0x1
19:16 REVISION : Indicates the architecture revision RO 0x0
15:0 ARCHID : Indicates the component RO 0x1a14
M33 : DEVID Register
Offset : 0x42fc8
Description
Device Configuration register
Table 348. DEVID
RegisterBits Description Type Reset
31:20 Reserved. - -
19:16 NUMCH : Number of ECT channels available RO 0x4
15:8 NUMTRIG : Number of ECT triggers available. RO 0x08
7:5 Reserved. - -
4:0 EXTMUXNUM : Indicates the number of multiplexers available on Trigger
Inputs and Trigger Outputs that are using asicctl. The default value of
0b00000 indicates that no multiplexing is present. This value of this bit
depends on the Verilog define EXTMUXNUM that you must change
accordingly.RO 0x00
M33 : DEVTYPE Register
Offset : 0x42fcc
Description
Device Type Identifier register
Table 349. DEVTYPE
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SUB : Sub-classification of the type of the debug component as specified in the
ARM Architecture Specification within the major classification as specified in
the MAJOR field.RO 0x1
3:0 MAJOR : Major classification of the type of the debug component as specified
in the ARM Architecture Specification for this debug and trace component.RO 0x4
RP2350 Datasheet
3.7. Cortex-M33 processor 228
M33 : PIDR4 Register
Offset : 0x42fd0
Description
CoreSight Periperal ID4
Table 350. PIDR4
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 SIZE : Always 0b0000. Indicates that the device only occupies 4KB of memory RO 0x0
3:0 DES_2 : Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the
designer of the component.RO 0x4
M33 : PIDR5 Register
Offset : 0x42fd4
Description
CoreSight Periperal ID5
Table 351. PIDR5
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : PIDR6 Register
Offset : 0x42fd8
Description
CoreSight Periperal ID6
Table 352. PIDR6
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : PIDR7 Register
Offset : 0x42fdc
Description
CoreSight Periperal ID7
Table 353. PIDR7
RegisterBits Description Type Reset
31:0 Reserved. - -
M33 : PIDR0 Register
Offset : 0x42fe0
Description
CoreSight Periperal ID0
Table 354. PIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
RP2350 Datasheet
3.7. Cortex-M33 processor 229
Bits Description Type Reset
7:0 PART_0 : Bits[7:0] of the 12-bit part number of the component. The designer of
the component assigns this part number.RO 0x21
M33 : PIDR1 Register
Offset : 0x42fe4
Description
CoreSight Periperal ID1
Table 355. PIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 DES_0 : Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the
designer of the component.RO 0xb
3:0 PART_1 : Bits[11:8] of the 12-bit part number of the component. The designer
of the component assigns this part number.RO 0xd
M33 : PIDR2 Register
Offset : 0x42fe8
Description
CoreSight Periperal ID2
Table 356. PIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVISION : This device is at r1p0 RO 0x0
3 JEDEC : Always 1. Indicates that the JEDEC-assigned designer ID is used. RO 0x1
2:0 DES_1 : Together, PIDR1.DES_0, PIDR2.DES_1, and PIDR4.DES_2 identify the
designer of the component.RO 0x3
M33 : PIDR3 Register
Offset : 0x42fec
Description
CoreSight Periperal ID3
Table 357. PIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 REVAND : Indicates minor errata fixes specific to the revision of the
component being used, for example metal fixes after implementation. In most
cases, this field is 0b0000. ARM recommends that the component designers
ensure that a metal fix can change this field if required, for example, by driving
it from registers that reset to 0b0000.RO 0x0
3:0 CMOD : Customer Modified. Indicates whether the customer has modified the
behavior of the component. In most cases, this field is 0b0000. Customers
change this value when they make authorized modifications to this
component.RO 0x0
M33 : CIDR0 Register
RP2350 Datasheet
3.7. Cortex-M33 processor 230
Offset : 0x42ff0
Description
CoreSight Component ID0
Table 358. CIDR0
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_0 : Preamble[0]. Contains bits[7:0] of the component identification
codeRO 0x0d
M33 : CIDR1 Register
Offset : 0x42ff4
Description
CoreSight Component ID1
Table 359. CIDR1
RegisterBits Description Type Reset
31:8 Reserved. - -
7:4 CLASS : Class of the component, for example, whether the component is a
ROM table or a generic CoreSight component. Contains bits[15:12] of the
component identification code.RO 0x9
3:0 PRMBL_1 : Preamble[1]. Contains bits[11:8] of the component identification
code.RO 0x0
M33 : CIDR2 Register
Offset : 0x42ff8
Description
CoreSight Component ID2
Table 360. CIDR2
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_2 : Preamble[2]. Contains bits[23:16] of the component identification
code.RO 0x05
M33 : CIDR3 Register
Offset : 0x42ffc
Description
CoreSight Component ID3
Table 361. CIDR3
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 PRMBL_3 : Preamble[3]. Contains bits[31:24] of the component identification
code.RO 0xb1
3.7.5.1. Cortex-M33 EPPB registers
The EPPB (Extended Private Peripheral Bus) contains registers implemented by Raspberry Pi and integrated into the
Cortex-M33 PPB to provide per-processor controls for certain RP2350 features. There is one copy of these registers per
RP2350 Datasheet
3.7. Cortex-M33 processor 231
core (they are core-local), and they reset on a warm reset of the core.
These registers start at a base address of 0xe0080000 , defined as EPPB_BASE  in the SDK.
Table 362. List of
M33_EPPB registersOffset Name Info
0x0 NMI_MASK0 NMI mask for IRQs 0 through 31. This register is core-local, and
is reset by a processor warm reset.
0x4 NMI_MASK1 NMI mask for IRQs 0 though 51. This register is core-local, and is
reset by a processor warm reset.
0x8 SLEEPCTRL Nonstandard sleep control register
M33_EPPB : NMI_MASK0 Register
Offset : 0x0
Table 363.
NMI_MASK0 RegisterBits Description Type Reset
31:0 NMI mask for IRQs 0 through 31. This register is core-local, and is reset by a
processor warm reset.RW 0x00000000
M33_EPPB : NMI_MASK1 Register
Offset : 0x4
Table 364.
NMI_MASK1 RegisterBits Description Type Reset
31:20 Reserved. - -
19:0 NMI mask for IRQs 0 though 51. This register is core-local, and is reset by a
processor warm reset.RW 0x00000
M33_EPPB : SLEEPCTRL Register
Offset : 0x8
Description
Nonstandard sleep control register
Table 365.
SLEEPCTRL RegisterBits Description Type Reset
31:3 Reserved. - -
2 WICENACK : Status signal from the processor’s interrupt controller. Changes
to WICENREQ are eventually reflected in WICENACK.RO 0x0
1 WICENREQ : Request that the next processor deep sleep is a WIC sleep. After
setting this bit, before sleeping, poll WICENACK to ensure the processor
interrupt controller has acknowledged the change.RW 0x1
0 LIGHT_SLEEP : By default, any processor sleep will deassert the system-level
clock request. Reenabling the clocks incurs 5 cycles of additional latency on
wakeup.
Setting LIGHT_SLEEP to 1 keeps the clock request asserted during a normal
sleep (Arm SCR.SLEEPDEEP = 0), for faster wakeup. Processor deep sleep
(Arm SCR.SLEEPDEEP = 1) is not affected, and will always deassert the
system-level clock request.RW 0x0
RP2350 Datasheet
3.7. Cortex-M33 processor 232
3.8. Hazard3 processor
Hazard3 is a low-area, high-performance RISC-V processor with a 3-stage in-order pipeline. RP2350 configures the
following standard RISC-V extensions:
•RV32I: 32-bit base instruction set
•M: Integer multiply/divide/modulo instructions
•A: Atomic memory operations
•C: Compressed 16-bit instructions (equivalently spelled Zca)
•Zba: Address generation instructions
•Zbb: Basic bit manipulation instructions
•Zbs: Single-bit manipulation instructions
•Zbkb: Basic bit manipulation for scalar cryptography
•Zcb: Basic additional compressed instructions
•Zcmp: Push/pop and double-move compressed instructions
•Zicsr: CSR access instructions
•Debug, Machine and User execution modes
•Physical Memory Protection unit (PMP) with eight regions, 32-byte granule, NAPOT
•External debug support with four instruction address triggers
Additionally, RP2350 enables the following Hazard3 custom extensions:
•Xh3power : Power management instructions and CSRs
•Xh3bextm : Bit-extract-multiple instruction (used in bootrom)
•Xh3irq: Local interrupt controller with nested, prioritised IRQ support
•Xh3pmpm: Unlocked M-mode PMP regions
Hazard3 Source Code
All hardware source files for Hazard3 are available under Apache 2.0 licensing at:
github.com/wren6991/hazard3
3.8.1. Instruction set reference
This section is a programmer’s reference guide for the instructions supported by Hazard3. It covers basic assembly
syntax, instruction behaviour, ranges for immediate values, and conditions for instruction compression. The index  lists
instructions alphabetically, including pseudo-instructions.
The pseudocode in this guide is informative only, and is no replacement for the official RISC-V specifications in Section
3.8.1.1 . However, it should prove a useful mnemonic aid once you have read the specifications.
3.8.1.1. Links to RISC-V specifications
This table links ratified versions of the base instruction set and extensions implemented by Hazard3. These are the
authoritative reference for the instructions documented in this reference guide.
RP2350 Datasheet
3.8. Hazard3 processor 233
Extension Specification
RV32I v2.1 Unprivileged ISA 20191213
M v2.0 Unprivileged ISA 20191213
A v2.1 Unprivileged ISA 20191213
C v2.0 Unprivileged ISA 20191213
Zicsr v2.0 Unprivileged ISA 20191213
Zifencei  v2.0 Unprivileged ISA 20191213
Zba v1.0.0 Bit Manipulation ISA extensions 20210628
Zbb v1.0.0 Bit Manipulation ISA extensions 20210628
Zbs v1.0.0 Bit Manipulation ISA extensions 20210628
Zbkb v1.0.1 Scalar Cryptography ISA extensions 20220218
Zcb v1.0.3-1 Code Size Reduction extensions frozen v1.0.3-1
Zcmp v1.0.3-1 Code Size Reduction extensions frozen v1.0.3-1
Machine ISA v1.12 Privileged Architecture 20211203
Debug v0.13.2 RISC-V External Debug Support 20190322
You may also refer to the RISC-V Assembly Programmer’s Manual  for information on assembly syntax.
Consult the source code  for detailed questions about implementation-defined behaviour, which is not covered by the
RISC-V specifications. RP2350 uses version 86fc4e3 , with metal ECOs for commits 2f6e983  and af08c0b .
3.8.1.2. Architecture strings
-march strings completely specify the set of available RISC-V instructions, so that a compiler can generate correct and
optimal code for your device. Use the following in descending order of preference:
1.Use rv32ima_zicsr_zifencei_zba_zbb_zbs_zbkb_zca_zcb_zcmp  for compilers which support the Zcb and Zcmp extensions,
such as GCC 14.
2.Use rv32ima_zicsr_zifencei_zba_zbb_zbs_zbkb_zca_zcb  for GCC 14 packaged with an older assembler which does not
support Zcmp.
3.Use rv32imac_zicsr_zifencei_zba_zbb_zbs_zbkb  for older compilers, such as GCC 13 and below.
3.8.1.3. RISC-V architectural state
The mutable state visible to the programmer consists of:
•The 31 × 32-bit integer general-purpose registers (GPRs), named x1 through x31
•The program counter pc, which points to the beginning of the current instruction in memory
•The control and status registers (CSRs), which configure processor behaviour and are used in trap handling
•The local monitor bit, which helps maintain correctness of atomic read-modify-write sequences
•The current privilege level, which determines which memory locations the core can access, which CSRs it can
access, and which instructions it can execute
Hazard3 supports two privilege levels: Machine and User. These are interchangeably referred to as modes , and are
commonly abbreviated as M-mode and U-mode. Debug mode behaves as an additional privilege level above M-mode.
RP2350 Datasheet
3.8. Hazard3 processor 234
The 0th general-purpose register, x0, is hardwired to zero and ignores writes.
There is no flags register; branch instructions perform GPR-to-GPR comparisons directly.
This state is duplicated per hardware thread, or hart. RP2350 implements two Hazard3 cores, each with one hart.
3.8.1.3.1. Register conventions
The following ABI names are synonymous with x0 through x31:
Register ABI Name Description
x0 zero Hardwired to zero; ignores writes
x1 ra Return address (link register)
x2 sp Stack pointer
x3 gp Global pointer
x4 tp Thread pointer
x5 - x7 t0 - t2 Temporaries
x8 s0 or fp Saved register or frame pointer
x9 s1 Saved register
x10 - x11 a0 - a1 Function arguments and return values
x12 - x17 a2 - a7 Function arguments
x18 - x27 s2 - s11 Saved registers
x28 - x31 t3 - t6 Temporaries
Registers x1 through x31 are identical, and any 32-bit opcode can use any combination of these registers. However,
compressed instructions give preferential treatment to commonly-used registers sp, ra, s0, s1, and a0 through a5 to
improve code density. All compressed instructions implemented by Hazard3 are 16-bit aliases for existing 32-bit
instructions, so you can still perform any operation on any register.
See the RISC-V PSABI Specification  for more information on the ABI register assignment as well as the RISC-V
procedure calling convention.
3.8.1.4. Compressed instructions
The RISC-V extensions which Hazard3 implements use a mixture of 32-bit and 16-bit opcodes, the latter being referred
to as compressed instructions . With the exception of Zcmp, each compressed instruction maps to a subset of an existing
32-bit instruction. For example, c.add is a 16-bit alias of the add instruction, with restrictions on register allocation.
The assembler automatically uses compressed instructions when possible. For example, add a0, a0, a1  is a
compressible form of add. This assembles to the 16-bit opcode c.add a0, a1  when compressed instructions are enabled
in the assembler.
The following extensions use 16-bit opcodes:
•C: compressed instructions  (the non-floating-point subset is equivalently spelled as Zca)
•Zcb: additional basic compressed instructions
•Zcmp: compressed push, pop and double-move
Disabling the above extensions for compilation (and assembly) aligns all instructions to 32-bit boundaries. This may
have a minor performance advantage for branch-dense code sequences (see Section 3.8.7 ), at the cost of poorer code
density.
RP2350 Datasheet
3.8. Hazard3 processor 235
When an instruction has an optional 16-bit compressed form, the limitations of the compressed form are documented
in the listing for the 32-bit form. It is useful to be aware of these restrictions when optimising for code size. If no such
limitations are mentioned, it means the instruction is always a 32-bit opcode.
Zcmp is an outlier in that its instructions each expand to a sequence  of 32-bit instructions from the RV32I base instruction
set. They therefore have no direct 32-bit counterparts.
3.8.1.5. Conventions for pseudocode
Pseudocode in this section is in Verilog 2005 syntax (IEEE 1364-2005). These Verilog operators are used throughout:
•Infix operators +, -, *, /, &, ^, |, <<, ==, !=, < and >= can be considered the same as the corresponding C operator.
•$signed()  bit-casts to a signed value; comparisons between two signed values are signed comparisons.
•>> is always a logical (zero-extending) right shift.
•>>> on a signed value is an arithmetic (sign-extending) right shift.
•{a, b} is the bit-concatenation of a and b, with a in the more-significant position of the result.
•a[n] on an array is a subscript array access. For example mem[0] is the first byte of memory.
•x[m:l] on a packed array (a bit vector) is a bit slice of x, where m is the (inclusive) MSB and l is the (inclusive) LSB.
For example rs1[7:0]  is the 8 least-significant bits of rs1.
•{n{x}}, where n is a constant and x is a packed array, replicates x n times. n copies of x are concatenated together.
For example {32{1’b1}} is a 32-bit all-ones value.
The pseudocode uses <= non-blocking assignments to assign to outputs: all such assignments are applied in a batch
after the block of pseudocode has executed. Local variables may be assigned with = blocking assignments, which
update the assignee immediately, similar to = procedural assignments in e.g. C programs. This distinction is important
in some cases where e.g. rd and rs1 may alias the same register, but it’s generally sufficient just to be aware that a <= b
and a = b are both assignments into a.
3.8.1.5.1. Variables used in pseudocode
Pseudocode in this guide uses the following conventions for variables:
•rs1, rs2, and rd are 32-bit unsigned packed arrays (bit vectors), representing the values of the two register operands
and the destination register.
•regnum_rs1 , regnum_rs2 , and regnum_rd  are the 5-bit register numbers which select a GPR for rs1, rs2, and rd
•imm is a 32-bit unsigned packed array referring to the instruction’s immediate value.
•pc is a 32-bit unsigned packed array referring to the program counter, which is exactly the address of the current
instruction.
•mem is an array of 8-bit unsigned packed arrays, each corresponding to a byte address in memory.
•csr is an array of 32-bit unsigned packed arrays, each corresponding to a CSR listed in Section 3.8.9 .
•priv is a 2-bit unsigned packed array which contains the value 0x3 when the core is in Debug or M-mode, and 0x0
when the core is in U-mode.
•i and j are pseudocode temporary variables of type integer which may be used for loop variables.
The following tasks are used throughout:
•raise_exception(n)  raises an exception with a cause of n (see Section 3.8.4.1 ).
•bus_error(addr)  returns 1 when the address addr returns a bus error, and 0 otherwise.
RP2350 Datasheet
3.8. Hazard3 processor 236
3.8.1.6. Alphabetical list of instructions
This instruction reference covers all instructions from all extensions which Hazard3 implements on RP2350. The table
below also includes common pseudo-instructions such as not and ret, which you may see in disassembly and be
surprised not to see in the ISA manual. The links for pseudo-instructions go to the entry for the underlying hardware
instruction aliased by that pseudo-instruction.
TIP
The instruction names at the left-hand margin of the instruction listings are links back to this index. Use them to
quickly return here and look up another instruction.
Alphabetical order: left-to-right, then top-to-bottom.
add addi amoadd.w amoand.w amomax.w amomaxu.w
amomin.w amominu.w amoor.w amoswap.w amoxor.w and
andi andn auipc bclr bclri beq
beqz bext bexti bge bgeu bgez
bgt bgtu bgtz binv binvi ble
bleu blez blt bltu bltz bne
bnez brev8 bset bseti clz cm.mva01s
cm.mvsa01 cm.pop cm.popret cm.popretz cm.push cpop
csrc csrci csrr csrrc csrrci csrrs
csrrsi csrrw csrrwi csrs csrsi csrw
csrwi ctz div divu ebreak ecall
fence fence.i j jal jalr jr
lb lbu lh lhu lr.w lui
lw max maxu min minu mret
mul mulh mulhsu mulhu mv neg
nop not or orc.b ori orn
pack packh rem remu ret rev8
rol ror rori sb sc.w seqz
sext.b sext.h sgtz sh1add sh2add sh3add
sh sll slli slt slti sltiu
sltu sltz snez sra srai srl
srli sub sw unzip wfi xnor
xor xori zext.b zext.h zip
The remainder of this reference guide groups instructions by extension:
•RV32I: base ISA (register-register)
•RV32I: base ISA (register-immediate)
•RV32I: base ISA (large immediate)
•RV32I: base ISA (control transfer)
•RV32I: base ISA (load/store)
RP2350 Datasheet
3.8. Hazard3 processor 237
•M: multiply and divide
•A: atomics
•C: compressed instructions
•Zba: bit manipulation for address generation
•Zbb: basic bit manipulation
•Zbs: single bit manipulation
•Zbkb: basic bit manipulation for scalar cryptography
•Zcb: additional basic compressed instructions
•Zcmp: compressed push, pop and double-move
•RV32I and Zifencei: memory ordering
•Zicsr: control and status register access
•Privileged instructions
3.8.1.7. RV32I: base ISA (register-register)
These instructions calculate a function of two register operands, rs1 and rs2. They write the 32-bit result to a destination
register, rd.
add
Add register to register.
Usage:
add rd, rs1, rs2
Operation:
rd <= rs1 + rs2;
Compressible if either:
•rd matches rs1, no operands are zero (aka c.add)
•rs2 is zero and neither rd nor rs1 is zero (aka c.mv)
and
Bitwise AND register with register.
Usage:
and rd, rs1, rs2
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 238
rd <= rs1 & rs2;
Compressible if: rd matches rs1, registers are in x8 - x15.
or
Bitwise OR register with register.
Usage:
or rd, rs1, rs2
Operation:
rd <= rs1 | rs2;
Compressible if: rd matches rs1, registers are in x8 - x15.
sll
Shift left, logical. Shift amount is modulo 32.
Usage:
sll rd, rs1, rs2
Operation:
rd <= rs1 << rs2[4:0];
slt
Set if less than (signed). Result is 0 for false, 1 for true.
Usage:
slt rd, rs1, rs2
sltz rd, rs1     // pseudo: rs2 is zero
sgtz rd, rs2     // pseudo: rs1 is zero
Operation:
rd <= $signed(rs1) < $signed(rs2);
sltu
Set if less than (unsigned). Result is 0 for false, 1 for true.
Usage:
RP2350 Datasheet
3.8. Hazard3 processor 239
sltu rd, rs1, rs
snez rd, rs2     // pseudo: rs1 is zero
Operation:
rd <= rs1 < rs2;
sra
Shift right, arithmetic. Shift amount is modulo 32.
Usage:
sra rd, rs1, rs2
Operation:
rd <= $signed(rs1) >>> rs2[4:0];
srl
Shift right, logical. Shift amount is modulo 32.
Usage:
srl rd, rs1, rs2
Operation:
rd <= rs1 >> rs2[4:0];
sub
Two’s complement subtract register from register.
Usage:
sub rd, rs1, rs2
neg rd, rs2      // pseudo: rs1 is zero
Operation:
rd <= rs1 - rs2;
Compressible if: rd matches rs1, registers are in x8 - x15.
RP2350 Datasheet
3.8. Hazard3 processor 240
xor
Bitwise XOR register with register
Usage:
xor rd, rs1, rs2
Operation:
rd <= rs1 ^ rs2;
Compressible if: rd matches rs1, registers are in x8 - x15.
3.8.1.8. RV32I: base ISA (register-immediate)
These instructions calculate a function of one register rs1 and one immediate operand imm. They write the 32-bit result
to a destination register rd.
Immediate operands are constants encoded directly in the instruction, which avoids the cost of first materialising the
constant value into a register.
addi
Add register to immediate.
Usage:
addi rd, rs1, imm
mv rd, rs1        // pseudo: imm is 0
nop               // pseudo: rd, rs1 are zero, imm is 0
Operation:
rd <= rs1 + imm
Immediate range: -0x800 through 0x7ff for 32-bit, smaller for 16-bit.
Compressible if:
•rd matches rs1, and immediate is in the range -0x20 through 0x1f (aka c.addi)
•rd is not zero, rs1 is zero, and immediate is in the range -0x20 through 0x1f (aka c.li)
•rd is in x8 - x15, rs1 is sp, and immediate is a nonzero multiple of four in the range 0x000 through 0x3fc (aka
c.addi4spn )
•rd is sp, rs1 is sp, and immediate is a nonzero multiple of 16 in the range -0x200 through 0x1f0 (aka c.addi16sp )
Note compressed c.mv canonically expands to add, not addi.
andi
Bitwise AND register with immediate.
Usage:
RP2350 Datasheet
3.8. Hazard3 processor 241
andi rd, rs1, imm
zext.b rd, rs1    // pseudo: imm is 0xff
Operation:
rd <= rs1 & imm;
Immediate range: -0x800 through 0x7ff for 32-bit, -0x20 through 0x1f for 16-bit.
Compressible if: rd matches rs1, registers are in x8 - x15, and immediate is in the range -0x20 through 0x1f.
ori
Bitwise OR register with immediate.
Usage:
ori rd, rs1, imm
Operation:
rd <= rs1 | imm;
Immediate range: -0x800 through 0x7ff
slli
Shift left, logical, immediate.
Usage:
slli rd, rs1, imm
Operation:
rd <= rs1 << imm;
Immediate range: 0 through 31.
Compressible if: rd matches rs1, registers are not zero.
slti
Set if less than immediate (signed). Result is 0 for false, 1 for true.
Usage:
slti rd, rs1, imm
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 242
rd <= $signed(rs1) < $signed(imm);
Immediate range: -0x800 through 0x7ff
sltiu
Set if less than immediate (unsigned). Result is 0 for false, 1 for true.
Usage:
sltiu rd, rs1, imm
seqz rd, rs1       // pseudo: imm is 1
Operation:
rd <= rs1 < imm;
Immediate range: -0x800 through 0x7ff
Note the negative values indicated for the immediate range are two’s complement: this instruction uses them in an
unsigned context, so -0x800 through -0x001 can be thought of as +0xfffff800  through +0xffffffff  for the comparison.
srai
Shift right, arithmetic, immediate.
Usage:
srai rd, rs1, imm
Operation:
rd <= $signed(rs1) >>> imm;
Immediate range: 0 through 31.
Compressible if: rd matches rs1, registers are in x8 through x15.
srli
Shift right, logical, immediate.
Usage:
srli rd, rs1, imm
Operation:
rd <= rs1 >> imm;
Immediate range: 0 through 31.
RP2350 Datasheet
3.8. Hazard3 processor 243
Compressible if: rd matches rs1, registers are in x8 through x15.
xori
Bitwise XOR register with immediate.
Usage:
xori rd, rs1, imm
not rd, rs1       // pseudo: imm is -1
Operation:
rd <= rs1 ^ imm;
Immediate range: -0x800 through 0x7ff
Compressible if: rd matches rs1, registers are in x8 - x15, and immediate is -1 (aka c.not)
3.8.1.9. RV32I: base ISA (large immediate)
These instructions are the first in a two-instruction sequence to materialise a 32-bit constant, or a 32-bit offset from pc.
auipc
Add upper immediate to program counter.
Usage:
auipc rd, imm
Operation:
rd <= pc + (imm << 12);
Immediate range: -0x80000  through 0x7ffff.
Note -0x80000  through -0x00001  are equivalent to 0x80000 through 0xfffff after the left shift ( on RV32 only ) and the
assembler may also accept these positive values.
lui
Load upper immediate.
Usage:
lui rd, imm
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 244
rd <= imm << 12;
Immediate range: -0x80000  through 0x7ffff if 32-bit, or -0x20 through 0x1f if 16-bit.
Compressible if: rd is neither zero nor sp, and imm is nonzero in the range -0x20 through 0x1f.
Note -0x80000  through -0x00001  are equivalent to 0x80000 through 0xfffff after the left shift ( on RV32 only ) and the
assembler may also accept these positive values.
3.8.1.10. RV32I: base ISA (control transfer)
These instructions modify the value of pc. When unmodified, pc increments by the size of the current instruction in bytes.
Conditional branches either modify or do not modify pc, based on a comparison between two registers. There is no flags
register, however you can pass boolean conditions into branches by comparing a register with the zero register.
beq
Branch if equal.
Usage:
beq rs1, rs2, label
beqz rs1, label     // pseudo: rs2 is zero
Operation:
if (rs1 == rs2)
    pc <= label;
Immediate range: even values in the range -0x1000 through 0x0ffe (±4 kB) if 32-bit, or -0x100 through 0x0fe (±256 B) if
16-bit.
Compressible if: rs2 is zero, and immediate is in the range -0x100 through 0x0fe (aka c.beqz).
bge
Branch if greater than or equal (signed).
Usage:
bge rs1, rs2, label
bgez rs1, label     // pseudo: rs2 is zero
ble rs2, rs1, label // pseudo: operands swapped by assembler
blez rs2, label     // pseudo: rs1 is zero
Operation:
if ($signed(rs1) >= $signed(rs2))
    pc <= label;
Immediate range: even values in the range -0x1000 through 0x0ffe (±4 kB)
RP2350 Datasheet
3.8. Hazard3 processor 245
bgeu
Branch if less than or equal (unsigned).
Usage:
bgeu rs1, rs2, label
bleu rs2, rs1, label // pseudo: operands swapped by assembler
Operation:
if (rs1 >= rs2)
    pc <= label;
Immediate range: even values in the range -0x1000 through 0x0ffe (±4 kB)
blt
Branch if less than (signed).
Usage:
blt rs1, rs2, label
bltz rs1, label      // pseudo: rs2 is zero
bgt rs2, rs1, label  // pseudo: operands swapped by assembler
bgtz rs2, label      // pseudo: rs1 is zero
Operation:
if ($signed(rs1) < $signed(rs2))
    pc <= label;
Immediate range: even values in the range -0x1000 through 0x0ffe (±4 kB)
bltu
Branch if less than (unsigned).
Usage:
bltu rs1, rs2, label
bgtu rs2, rs1, label // pseudo: operands swapped by assembler
Operation:
if (rs1 < rs2)
    pc <= label;
Immediate range: even values in the range -0x1000 through 0x0ffe (±4 kB)
bne
Branch if not equal.
RP2350 Datasheet
3.8. Hazard3 processor 246
Usage:
bne rs1, rs2, label
bnez rs1, label     // pseudo: rs2 is zero
Operation:
if (rs1 != rs2)
    pc <= label;
Immediate range: even values in the range -0x1000 through 0x0ffe (±4 kB) if 32-bit, or -0x100 through 0x0fe (±256 B) if
16-bit.
Compressible if: rs2 is zero, and immediate is in the range -0x100 through 0x0fe (aka c.bnez).
jal
Jump and link, pc-relative.
Usage:
jal rd, label
jal label      // pseudo: rd is ra
j label        // pseudo: rd is zero
Operation:
rd <= pc + 4;   // or +2 if opcode is 16-bit
pc <= label;
Immediate range: even values in the range -0x100000  through 0x0ffffe  (±1 MB) if 32-bit, or -0x800 through 0x7fe
(±2 kB) if 16-bit.
Compressible if: rd is zero or ra, and immediate is in the range -0x800 through 0x7fe.
jalr
Jump and link, register-offset.
Usage:
jalr rd, rs1, imm //                     (imm is implicitly 0 if omitted.)
jalr rd, imm(rs1) // alternate syntax.   (imm is implicitly 0 if omitted.)
jalr rs1, imm     // pseudo: rd is ra.   (imm is implicitly 0 if omitted.)
jalr imm(rs1)     // pseudo: rd is ra.   (imm is implicitly 0 if omitted.)
jr rs1, imm       // pseudo: rd is zero. (imm is implicitly 0 if omitted.)
jr imm(rs1)       // pseudo: rd is zero. (imm is implicitly 0 if omitted.)
ret               // pseudo for jr ra
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 247
rd <= pc + 4;      // or +2 if opcode is 16-bit
pc <= rs1 + imm;
Immediate range: -0x800 through 0x7ff.
Compressible if: rd is zero or ra, immediate is zero, and rs1 is not zero.
3.8.1.11. RV32I: base ISA (load and store)
These instructions transfer data between memory and core registers. The register operand rs1 and immediate imm are
added to form the address. Stores write register operand rs2 into memory, and loads read from memory into the
destination register rd.
All load and store instructions to naturally aligned addresses on RISC-V are single-copy atomic . This means a naturally-
aligned load does not observe byte tearing between the values that a memory location held before and after any
naturally-aligned store to that location. Equivalently, all bytes covered by a single naturally-aligned load or store
instruction transfer in a single transaction with the memory subsystem.
Hazard3 raises an exception on a load or store to a non-naturally-aligned address. See Section 3.8.4.1  for an exhaustive
list of exception causes.
lb
Load signed byte from memory.
Usage:
lb rd, imm(rs1)
lb rd, (rs1)    // imm is implicitly 0 if omitted.
Operation:
reg [31:0] addr;
addr = rs1 + imm;
if (bus_fault(addr)) begin
    raise_exception(4'h5);  // Cause = load fault
end else begin
    rd <= {
        {24{mem[addr][7]}}, // Sign-extend
        mem[addr]
    };
end
Immediate range: -0x800 through 0x7ff for 32-bit, or 0x0 through 0x3 for 16-bit.
lbu
Load unsigned byte from memory.
Usage:
lbu rd, imm(rs1)
lbu rd, (rs1)    // imm is implicitly 0 if omitted.
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 248
reg [31:0] addr;
addr = rs1 + imm;
if (bus_fault(addr)) begin
    raise_exception(4'h5); // Cause = load fault
end else begin
    rd <= {
        24'h000000,        // Zero-extend
        mem[addr]
    };
end
Immediate range: -0x800 through 0x7ff for 32-bit, or 0x0 through 0x3 for 16-bit.
Compressible if: rd and rs1 are in x8 through x15, and immediate is in the range 0x0 through 0x3.
lh
Load signed halfword from memory.
Usage:
lh rd, imm(rs1)
lh rd, (rs1)    // imm is implicitly 0 if omitted.
Operation:
reg [31:0] addr;
addr = rs1 + imm;
if (addr[0]) begin
    raise_exception(4'h4);           // Cause = unaligned load
end else if (bus_fault(addr)) begin
    raise_exception(4'h5);           // Cause = load fault
end else begin
    rd <= {
        {16{mem[addr + 1][7]}},      // Sign-extend
        mem[addr + 1],
        mem[addr]
    };
end
Immediate range: -0x800 through 0x7ff for 32-bit, or even values in the range 0x0 through 0x2 for 16-bit.
Compressible if: rd and rs1 are in x8 through x15, and immediate is 0x0 or 0x2.
lhu
Load unsigned halfword from memory.
Usage:
lhu rd, imm(rs1)
lhu rd, (rs1)    // imm is implicitly 0 if omitted.
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 249
reg [31:0] addr;
addr = rs1 + imm;
if (addr[0]) begin
    raise_exception(4'h4);           // Cause = unaligned load
end else if (bus_fault(addr)) begin
    raise_exception(4'h5);           // Cause = load fault
end else begin
    rd <= {
        16'h0000,                    // Zero-extend
        mem[addr + 1],
        mem[addr]
    };
end
Immediate range: -0x800 through 0x7ff for 32-bit, or even values in the range 0x0 through 0x2 for 16-bit.
Compressible if: rd and rs1 are in x8 through x15, and immediate is 0x0 or 0x2.
lw
Load word from memory.
Usage:
lw rd, imm(rs1)
lw rd, (rs1)    // imm is implicitly 0 if omitted.
Operation:
reg [31:0] addr;
addr = rs1 + imm;
if (addr[1:0]) begin
    raise_exception(4'h4);           // Cause = unaligned load
end else if (bus_fault(addr)) begin
    raise_exception(4'h5);           // Cause = load fault
end else begin
    rd <= {
        mem[addr + 3],               // Note little-endian;
        mem[addr + 2],               // MSBs are highest address
        mem[addr + 1],
        mem[addr]
    };
end
Immediate range: -0x800 through 0x7ff for 32-bit, smaller for 16-bit.
Compressible if:
•rd and rs1 are in x8 - x15, and immediate is a multiple of four in the range 0x00 through 0x7c (aka c.lw)
•rd is not zero, rs1 is sp, and immediate is a multiple of four in the range 0x00 through 0xfc (aka c.lwsp)
sb
Store byte to memory.
Usage:
RP2350 Datasheet
3.8. Hazard3 processor 250
sb rs2, imm(rs1)
sb rs2, (rs1)    // imm is implicitly 0 if omitted.
Operation:
reg [31:0] addr;
addr = rs1 + imm;
if (bus_fault(addr)) begin
    raise_exception(4'h7);      // Cause = store/AMO fault
end else begin
    mem[addr] <= rs2[7:0];
end
Immediate range: -0x800 through 0x7ff for 32-bit, or 0x0 through 0x3 for 16-bit.
Compressible if: rd and rs1 are in x8 through x15, and immediate is in the range 0x0 through 0x3.
sh
Store halfword to memory.
Usage:
sh rs2, imm(rs1)
sh rs2, (rs1)    // imm is implicitly 0 if omitted.
Operation:
reg [31:0] addr;
addr = rs1 + imm;
if (addr[0]) begin
    raise_exception(4'h6);      // Cause = unaligned store/AMO
end else if (bus_fault(addr)) begin
    raise_exception(4'h7);      // Cause = store/AMO fault
end else begin
    mem[addr]     <= rs2[7:0];
    mem[addr + 1] <= rs2[15:8];
end
Immediate range: -0x800 through 0x7ff for 32-bit, or even values in the range 0x0 through 0x2 for 16-bit.
Compressible if: rd and rs1 are in x8 through x15, and immediate is 0x0 or 0x2.
sw
Store word to memory.
Usage:
sw rs2, imm(rs1)
sw rs2, (rs1)    // imm is implicitly 0 if omitted.
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 251
reg [31:0] addr;
addr = rs1 + imm;
if (addr[1:0]) begin
    raise_exception(4'h6);      // Cause = unaligned store/AMO
end else if (bus_fault(addr)) begin
    raise_exception(4'h7);      // Cause = store/AMO fault
end else begin
    mem[addr]     <= rs2[7:0];
    mem[addr + 1] <= rs2[15:8];
    mem[addr + 2] <= rs2[23:16];
    mem[addr + 3] <= rs2[31:24];
end
Immediate range: -0x800 through 0x7ff for 32-bit, smaller for 16-bit.
Compressible if:
•rs1 and rs2 are in x8 - x15, and immediate is a multiple of four in the range 0x00 through 0x7c (aka c.sw)
•rs2 is not zero, rs1 is sp, and immediate is a multiple of four in the range 0x00 through 0xfc (aka c.swsp)
3.8.1.12. M: Multiply and Divide
These instructions implement integer multiply, divide and modulo.
div
Divide (signed).
Usage:
div rd, rs1, rs2
Operation:
if (rs2 == 32'h0)
    rd <= 32'hffffffff;                              // Defined for division by zero
else if (rs1 == 32'h80000000 && rs2 == 32'hffffffff)
    rd <= 32'h80000000;                              // Defined for signed overflow
else
    rd <= $signed(rs1) / $signed(rs2);               // Sign of rd is XOR of signs
divu
Divide (unsigned).
Usage:
divu rd, rs1, rs2
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 252
if (rs2 == 32'h0)
    rd <= 32'hffffffff;                              // Defined for division by zero
else
    rd <= rs1 / rs2;
mul
Multiply 32 × 32 → 32.
Usage:
mul rd, rs1, rs2
Operation:
rd <= rs1 * rs2;
Compressible if: rd matches rs1, registers are in x8 through x15.
mulh
Multiply signed (32) by signed (32), return upper 32 bits of the 64-bit result.
Usage:
mulh rd, rs1, rs2
Operation:
// Both operands are sign-extended to 64 bits:
reg [63:0] result_full;
result_full = {{32{rs1[31]}}, rs1} * {{32{rs2[31]}}, rs2};
rd <= result_full[63:32];
mulhsu
Multiply signed (32) by unsigned (32), return upper 32 bits of the 64-bit result.
Usage:
mulhsu rd, rs1, rs2
Operation:
// rs1 is sign-extended, rs2 is zero-extended:
reg [63:0] result_full;
result_full = {{32{rs1[31}}, rs1} * {32'h00000000, rs2};
rd <= result_full[63:32];
RP2350 Datasheet
3.8. Hazard3 processor 253
mulhu
Multiply unsigned (32) by unsigned (32), return upper 32 bits of the 64-bit result.
Usage:
mulhu rd, rs1, rs2
Operation:
// Both operands are zero-extended to 64 bits:
reg [63:0] result_full;
result_full = {32'h00000000, rs1} * {32'h00000000, rs2};
rd <= result_full[63:32];
rem
Remainder (signed).
Usage:
rem rd, rs1, rs2
Operation:
if (rs2 == 32'h0)
    rd <= rs1;                         // Defined for division by zero
else
    rd <= $signed(rs1) % $signed(rs2); // Sign of rd is sign of rs1
remu
Remainder (unsigned).
Usage:
remu rd, rs1, rs2
Operation:
if (rs2 == 32'h0)
    rd <= rs1;
else
    rd <= rs1 % rs2;
3.8.1.13. A: Atomics
These instructions help software to safely and concurrently modify shared variables. They fall into two groups:
RP2350 Datasheet
3.8. Hazard3 processor 254
•lr.w and sc.w, load-reserved and store-conditional instructions, which allow software to safely perform read-modify-
write operations on shared variables by looping until success
•amo*.w instructions (atomic memory operations or AMOs), which atomically modify a memory location and return
the value it held immediately prior to modification
The pseudocode in this section references the 1-bit global variable local_monitor_valid . It is true when the hart has:
•previously completed a successful AHB5 exclusive read
•not attempted an exclusive write since the read
•not been interrupted or taken an exception since the read ( implementation-defined behaviour )
The pseudocode maintains this invariant over the local_monitor_valid  flag. This flag helps the hart maintain atomicity of
its read-modify-write sequences with respect to its own interrupts. Hardware refuses to perform exclusive writes when
the local monitor flag is not set.
AMOs clear the local monitor state even when bailing out during the read phase, since even in this case you have
attempted to execute an instruction which performs an exclusive write. In an lr.w, sc.w sequence with an AMO executed
in between, the sc.w always fails.
Hazard3 builds its atomic shared memory implementation on top of AHB5 exclusive accesses. The following tasks,
used throughout this section, represent AHB5 32-bit exclusive reads and writes:
// Read 32 bits from memory and return reservation success/fail according to
// global monitor. Set local monitor bit if the reservation succeeded.
task exclusive_read_32;
    input  [31:0]  addr;
    output [31:0]  data;
    output         exclusive_ok;
begin
    data = {
        mem[addr + 3],
        mem[addr + 2],
        mem[addr + 1],
        mem[addr]
    };
    local_monitor_valid = global_monitor_read(addr);
    exclusive_ok = local_monitor_valid;
end
endtask
// Attempt to write 32 bits to memory, and return write success/fail according
// to global monitor. Always clear the local monitor flag.
task exclusive_write_32;
    input  [31:0] addr;
    input  [31:0] data;
    output        exclusive_ok;
begin
    if (!local_monitor_valid) begin
        exclusive_ok = 0;                 // Write refused by local monitor
    end else if (global_monitor_write(addr)) begin
        exclusive_ok = 1;                 // Write succeeds
        mem[addr + 3] <= data[31:24];
        mem[addr + 2] <= data[23:16];
        mem[addr + 1] <= data[15: 8];
        mem[addr + 0] <= data[ 7: 0];
    end else begin
        exclusive_ok = 0;                 // Write refused by global monitor
    end
    local_monitor_valid = 0;              // Always clear local monitor
end
RP2350 Datasheet
3.8. Hazard3 processor 255
endtask
The functions global_monitor_read(addr);  and global_monitor_write(addr);  in the above code return the global monitor
response for an exclusive read or write to this address, following the rules laid out in Section 2.1.6 . The global monitor
enforces atomicity of this hart’s read-modify-write sequences with respect to other harts sharing the same memory.
Because Hazard3 implements an AMO as a hardware-sequenced read-modify-write retry loop using AHB5 exclusives,
the hardware promotes a read reservation failure during an AMO to a store/AMO fault exception ( mcause = 7). This
behaviour avoids an infinite loop when accessing locations which do not support exclusive access.
The following local variables are common to all AMO pseudocode:
reg        done = 0;
reg        exclusive_success;
reg [31:0] tmp;
amoadd.w
Atomically add register to memory and return original memory value.
Usage:
amoadd.w rd, rs2, (rs1)
Operation:
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        tmp = tmp + rs2;
        exclusive_write_32(rs1, tmp, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
amoand.w
Atomically bitwise AND register into memory. Return original memory value.
Usage:
amoand.w rd, rs2, (rs1)
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 256
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        tmp = tmp & rs2;
        exclusive_write_32(rs1, tmp, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
amomax.w
Atomically: check if register is signed-greater-than memory value, and write to memory if true. Return original
memory value.
Usage:
amomax.w rd, rs2, (rs1)
Operation:
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        tmp = $signed(tmp) < $signed(rs2) ? rs2 : tmp;
        exclusive_write_32(rs1, tmp, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
amomaxu.w
Atomically: check if register is unsigned-greater-than memory value, and write to memory if so. Return original
memory value.
Usage:
amomaxu.w rd, rs2, (rs1)
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 257
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        tmp = tmp < rs2 ? rs2 : tmp;
        exclusive_write_32(rs1, tmp, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
amomin.w
Atomically: check if register is signed-less-than memory value, and write to memory if so. Return original memory
value.
Usage:
amomin.w rd, rs2, (rs1)
Operation:
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        tmp = $signed(tmp) < $signed(rs2) ? tmp : rs2;
        exclusive_write_32(rs1, tmp, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
amominu.w
Atomically: check if register is unsigned-less-than memory value, and write to memory if so. Return original memory
value.
Usage:
amominu.w rd, rs2, (rs1)
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 258
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        tmp = tmp < rs2 ? tmp : rs2;
        exclusive_write_32(rs1, tmp, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
amoor.w
Atomically bitwise OR register into memory. Return original memory value.
Usage:
amoor.w rd, rs2, (rs1)
Operation:
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        tmp = tmp | rs2;
        exclusive_write_32(rs1, tmp, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
amoswap.w
Atomically: write a value to memory, and return the value the memory location held immediately prior to the write.
Usage:
amoswap.w rd, rs2, (rs1)
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 259
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        exclusive_write_32(rs1, rs2, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
amoxor.w
Atomically bitwise OR register into memory. Return original memory value.
Usage:
amoxor.w rd, rs2, (rs1)
Operation:
if (rs1[1:0]) begin
    raise_exception(4'h6);                            // Cause: store/AMO align
    done = 1;
end
while (!done) begin
    exclusive_read_32(rs1, tmp, exclusive_success);
    if (!exclusive_success || bus_fault(addr)) begin
        raise_exception(4'h7);                        // Cause: store/AMO fault
        done = 1;
    end else begin
        exclusive_write_32(rs1, rs2, done);
    end
end
local_monitor_valid = 0;                              // Always clear local monitor
lr.w
Load a value from memory and make a reservation with the global monitor. Set local monitor bit according to
reservation success.
Usage:
lr.w rd, (rs1)
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 260
if (rs1[1:0]) begin
    raise_exception(4'h4); // Cause: load align
end else if (bus_fault(rs1)) begin
    raise_exception(4'h5); // Cause: load fault
end else begin
    read_exclusive_32(rs1, tmp, local_monitor_valid);
    rd <= tmp;
end
sc.w
Conditionally store a value to memory. Succeed if reservation is valid at both local and global monitor. Return 1 for
failure, 0 for success.
Usage:
sc.w rd, rs2, (rs1)
Operation:
if (rs1[1:0]) begin
    raise_exception(4'h6);                // Cause: store/AMO align
end else if (bus_fault(addr)) begin
    raise_exception(4'h7);                // Cause: store/AMO fault
end else if (!local_monitor_valid) begin
    rd <= 1;                              // Refused by local monitor
end else begin
    write_exclusive_32(rs1, rs2, exclusive_success);
    rd <= !exclusive_success;
end
local_monitor_valid = 0;                  // Always clear local monitor
3.8.1.14. C: Compressed instructions
All instructions in the C extension are 16-bit aliases of 32-bit instructions from other extensions. In the case of Hazard3,
which lacks the F extension, these are all aliases of base I instructions. They behave identically to their 32-bit
counterparts.
C adds compressed aliases for the following instructions from RV32I:
Alphabetical order: left-to-right, then top-to-bottom.
add addi and andi beq bne
ebreak jal jalr lui lw or
slli srai srli sub sw xor
See the per-instruction documentation for the compression limitations of each instruction. The assembler automatically
uses compressed variants when the limitations are met, and when the relevant compressed instruction extension is
enabled for the assembler, for example by passing c in the -march ISA string.
The above also applies to Zca and Zcb: the former is an alias for the non-floating-point subset of C, and the latter adds 16-
bit aliases for additional common instructions from the I, M and Zbb extensions. Each Zcmp instruction expands to a
sequence of multiple instructions from the I extension.
RP2350 Datasheet
3.8. Hazard3 processor 261
(Return to index)
3.8.1.15. Zba: bit manipulation (address generation)
These instructions accelerate address generation for arrays of 2, 4 and 8-byte elements. They can also multiply by
constant values 3, 5 and 9 if that is more your style.
sh1add
Add, with the first addend shifted left by 1.
Usage:
sh1add rd, rs1, rs2
Operation:
rd <= (rs1 << 1) + rs2;
sh2add
Add, with the first addend shifted left by 2.
Usage:
sh2add rd, rs1, rs2
Operation:
rd <= (rs1 << 2) + rs2;
sh3add
Add, with the first addend shifted left by 3.
Usage:
sh3add rd, rs1, rs2
Operation:
rd <= (rs1 << 3) + rs2;
3.8.1.16. Zbb: bit manipulation (basic)
These instructions are useful for bitfield manipulation, and complex integer arithmetic, such as in soft floating point
routines. Many of them substitute directly for common pairs of RV32I instructions, like zext.h → sll, srl.
RP2350 Datasheet
3.8. Hazard3 processor 262
andn
Bitwise AND with inverted second operand.
Usage:
andn rd, rs1, rs2
Operation:
rd <= rs1 & ~rs2;
clz
Count leading zeroes (starting from MSB, searching LSB-ward).
Usage:
clz rd, rs1
Operation:
rd <= 32;         // Default = 32 if no set bits
reg found = 1'b0; // Local variable
for (i = 0; i < 32; i = i + 1) begin
    if (rs1[31 - i] && !found) begin
        found = 1'b1;
        rd <= i;
    end
end
cpop
Population count.
Usage:
cpop rd, rs1
Operation:
reg [5:0] sum = 6'd0;          // Local variable
for (i = 0; i < 32; i = i + 1)
    sum = sum + rs1[i];
rd <= sum;
ctz
Count trailing zeroes (starting from LSB, searching MSB-ward).
RP2350 Datasheet
3.8. Hazard3 processor 263
Usage:
ctz rd, rs1
Operation:
rd <= 32;          // Default = 32 if no set bits
reg found = 1'b0; // Local variable
for (i = 0; i < 32; i = i + 1) begin
    if (rs1[i] && !found) begin
        found = 1'b1;
        rd <= i;
    end
end
max
Maximum of two values (signed).
Usage:
max rd, rs1, rs2
Operation:
if ($signed(rs1) < $signed(rs2))
    rd <= rs2;
else
    rd <= rs1;
maxu
Maximum of two values (unsigned).
Usage:
maxu rd, rs1, rs2
Operation:
if (rs1 < rs2)
    rd <= rs2;
else
    rd <= rs1;
min
Minimum of two values (signed).
RP2350 Datasheet
3.8. Hazard3 processor 264
Usage:
min rd, rs1, rs2
Operation:
if ($signed(rs1) < $signed(rs2))
    rd <= rs1;
else
    rd <= rs2;
minu
Minimum of two values (unsigned).
Usage:
minu rd, rs1, rs2
Operation:
if (rs1 < rs2)
    rd <= rs1;
else
    rd <= rs2;
orc.b
OR-combine of bits within each byte. Generates a mask of nonzero bytes.
Usage:
orc.b rd, rs1
Operation:
rd <= {
    {8{|rs1[31:24]}},
    {8{|rs1[23:16]}},
    {8{|rs1[15:8]}},
    {8{|rs1[7:0]}}
};
orn
Bitwise OR with inverted second operand.
Usage:
RP2350 Datasheet
3.8. Hazard3 processor 265
orn rd, rs1, rs2
Operation:
rd <= rs1 | ~rs2;
rev8
Reverse bytes within word.
Usage:
rev8 rd, rs1
Operation:
rd <= {
    rs1[7:0],
    rs1[15:8],
    rs1[23:16],
    rs1[31:24]
};
rol
Rotate left by register, modulo 32.
Usage:
rol rd, rs1, rs2
Operation:
rd <= ({rs1, rs1} << rs2[4:0]) >> 32;
ror
Rotate right by register, modulo 32.
Usage:
ror rd, rs1, rs2
Operation:
RP2350 Datasheet
3.8. Hazard3 processor 266
rd <= {rs1, rs1} >> rs2[4:0];
rori
Rotate right by immediate.
Usage:
rori rd, rs1, imm
Operation:
rd <= {rs1, rs1} >> imm;
Immediate range: 0 through 31.
sext.b
Sign-extend from byte.
Usage:
sext.b rd, rs1
Operation:
rd <= {
    {24{rs1[7]}},
    rs1[7:0]
};
Compressible if: rd matches rs1, and registers are in x8 - x15.
sext.h
Sign-extend from halfword.
Usage:
sext.h rd, rs1
Operation:
rd <= {
    {16{rs1[15]}},
    rs1[15:0]
};
Compressible if: rd matches rs1, and registers are in x8 - x15.
RP2350 Datasheet
3.8. Hazard3 processor 267
xnor
Bitwise XOR with inverted operand. Equivalently, bitwise NOT of bitwise XOR.
Usage:
xnor rd, rs1, rs2
Operation:
rd <= rs1 ^ ~rs2;
zext.b
Zero-extend from byte.
Usage:
zext.b rd, rs1
Operation:
rd <= {
    24'h000000,
    rs1[7:0]
};
Compressible if: rd matches rs1, and registers are in x8 - x15.
The 32-bit opcode for zext.b is a pseudo-instruction for andi . However, the compressed variant is a dedicated
instruction from Zcb. It is not actually a part of Zbb, but is documented here for grouping with the other sext./zext
instructions.
zext.h
Zero-extend from halfword.
Usage:
zext.h rd, rs1
Operation:
rd <= {
    16'h0000,
    rs1[15:0]
};
Compressible if: rd matches rs1, and registers are in x8 - x15.
RP2350 Datasheet
3.8. Hazard3 processor 268
3.8.1.17. Zbs: Bit manipulation (single-bit)
These instructions invert, set, clear and extract single bits in a register.
bclr
Clear single bit.
Usage:
bclr rd, rs1, rs2
Operation:
rd <= rs1 & ~(32'h1 << rs2[4:0]);
bclri
Clear single bit (immediate).
Usage:
bclri rd, rs1, imm
Operation:
rd <= rs1 & ~(32'h1 << imm);
Immediate range: 0 through 31.
bext
Extract single bit.
Usage:
bext rd, rs1, rs2
Operation:
rd <= (rs1 >> rs2[4:0]) & 32'h1;
bexti
Extract single bit (immediate).
Usage:
bexti rd, rs1, imm
RP2350 Datasheet
3.8. Hazard3 processor 269
Operation:
rd <= (rs1 >> imm) & 32'h1;
Immediate range: 0 through 31.
binv
Invert single bit.
Usage:
binv rd, rs1, rs2
Operation:
rd <= rs1 ^ (32'h1 << rs2[4:0]);
binvi
Invert single bit (immediate).
Usage:
binvi rd, rs1, imm
Operation:
rd <= rs1 ^ (32'h1 << imm);
Immediate range: 0 through 31.
bset
Set single bit.
Usage:
bset rd, rs1, rs2
Operation:
rd <= rs1 | (32'h1 << rs2[4:0])
bseti
Set single bit (immediate).
Usage:
RP2350 Datasheet
3.8. Hazard3 processor 270
bseti rd, rs1, imm
Operation:
rd <= rs1 | (32'h1 << imm);
Immediate range: 0 through 31.
3.8.1.18. Zbkb: basic bit manipulation for cryptography
Zbkb has a large overlap with Zbb (basic bit manipulation). This section covers instructions in Zbkb but not in Zbb.
brev8
Bit-reverse within each byte.
Usage:
brev8 rd, rs1
Operation:
for (i = 0; i < 32; i = i + 8) begin
    for (j = 0; j < 8; j = j + 1) begin
        rd[i + j] <= rs1[i + (7 - j)];
    end
end
pack
Pack two halfwords into one word.
Usage:
pack rd, rs1, rs2
Operation:
rd <= {
    rs2[15:0],
    rs1[15:0]
};
packh
Pack two bytes into one halfword.
Usage:
RP2350 Datasheet
3.8. Hazard3 processor 271
packh rd, rs1, rs2
Operation:
rd <= {
    16'h0000,
    rs2[7:0],
    rs1[7:0]
};
unzip
Deinterleave odd/even bits of register into upper/lower half of result.
Usage:
unzip rd, rs1
Operation:
for (i = 0; i < 32; i = i + 2) begin
    rd[i / 2]      <= rs1[i];
    rd[i / 2 + 16] <= rs1[i + 1];
end
zip
Interleave upper/lower half of register into odd/even bits of result.
Usage:
zip rd, rs1
Operation:
for (i = 0; i < 32; i = i + 2) begin
    rd[i]     <= rs1[i / 2];
    rd[i + 1] <= rs1[i / 2 + 16];
end
3.8.1.19. Zcb: Additional basic compressed instructions
Zcb adds 16-bit compressed aliases for the following instructions from the I, M and Zbb extensions:
Alphabetical order: left-to-right, then top-to-bottom.
lbu lh lhu mul not sb
RP2350 Datasheet
3.8. Hazard3 processor 272
Alphabetical order: left-to-right, then top-to-bottom.
sext.b sext.h sh zext.b zext.h
See per-instruction documentation for the compressibility limitations for each instruction.
(Return to index)
3.8.1.20. Zcmp: Compressed push, pop, and double move
Zcmp adds 16-bit instructions which expand to common sequences of 32-bit RV32I instructions used in function
prologues and epilogues. The following is a rough description of the available instructions:
•cm.push: allocates a stack frame and saves registers.
◦Push ra onto the stack.
◦Optionally push a number of the s0 through s11 saved registers, consecutively up from s0.
◦Round the total stack decrement to a multiple of 16 bytes, to maintain stack alignment if already aligned.
◦Decrement the stack pointer by up to 48 additional bytes, in multiples of 16 bytes, to allocate additional frame
space.
◦There are twelve s* registers, and you can push any number of them except for eleven.  If you need to push
more than ten s* registers, push twelve.
•cm.pop: reverse of cm.push. Deallocates a stack frame and restores ra, optionally s0 through s11.
•cm.popret : equivalent to cm.pop followed by ret. Deallocates a stack frame, restores saved registers, and returns.
•cm.popretz : equivalent to cm.pop; li a0, 0; ret . It is common for functions to return a constant 0.
•cm.mvsa01 : move a0 and a1 into any two registers in the range s0 through s7. Used to save arguments over embedded
calls.
•cm.mva01s : move into a0 and a1, from any two registers in s0 through s7. Used to restore saved arguments.
See Section 3.8.1.1  for a link to the Zcmp specification which covers key details such as stack layout and atomicity with
respect to interrupts. See Section 3.8.7  for cycle counts for these instructions on Hazard3.
(Return to index)
3.8.1.21. RV32I and Zifencei: Memory ordering instructions
These instructions control observed memory ordering of loads and stores in multi-hart systems. They also enforce
when a hart’s instruction fetch observes its own stores.
fence
Constrain the position of this hart’s accesses in the total memory order, according to this hart’s program order.
Usage:
                   // <set> is a nonempty string which matches the regex i?o?r?w?
fence <set>, <set> // predecessor, successor
fence              // pseudo: fence iorw, iorw
fence.tso          // variant of fence rw, rw; see below
Operation: Hazard3 has no store buffer, and assumes the memory subsystem is sequentially consistent. Therefore
no additional book-keeping is required to enforce ordering on shared memory, and this instruction executes as a no-
op. (The SDK still uses fence instructions, and the ordered variants of amo*.w, for portability across platforms which
RP2350 Datasheet
3.8. Hazard3 processor 273
take advantage of relaxed memory ordering.)
Nominally a fence enforces that the predecessor  set appears before the successor  set in the total memory order.
These sets respectively contain the hart’s memory accesses before and after the fence instruction in program order,
and are further filtered by a 4-bit mask each:
•Device input (I)
•Device output (O)
•Read (R)
•Write (W)
The fence.tso  (total store order) variant is equivalent to fence rw, rw  except that it does not enforce write-before-
read ordering.
fence.i
Instruction fence. Ensure subsequent instruction fetches on this hart observe this hart’s previous stores.
Usage:
fence.i
Operation:
1.Clear the branch target buffer ( Section 3.8.7.10 )
2.Jump to the instruction at the sequentially-next address ( pc + 4), to clear the prefetch buffer.
The prefetch buffer can reorder instruction fetch against stores which are earlier in program order. For example:
    la a0, label   // get address for store instruction
    li a1, 0x9002  // get immediate value of c.ebreak
    div t1, t1, t1 // long-running instruction, fills prefetch buffer
    sh a1, (a0)    // write to next address. (16-bit opcode)
label:
    nop            // (16-bit opcode)
If you execute the above code on Hazard3, you may or may not get a breakpoint exception at label. The outcome
depends on how many cycles the bus accesses take. This is permitted by the RISC-V memory model.
This case is generally only reachable on fall-through, because Hazard3 does not prefetch through control flow
instructions except for the taken backward conditional branch currently allocated in the branch target buffer. In
particular it does not prefetch through indirect branches like ret. You are unlikely to hit this issue in practice;
however, be aware fence.i is the standard mechanism for solving this class of problem.
Hazard3 behaves unpredictably if you write to the address of a conditional branch instruction that is currently
tagged in the branch target buffer, and then execute that conditional branch instruction without first executing a
fence.i. Avoid this by always executing a fence.i between writing to memory and executing that same memory.
3.8.1.22. Zicsr: Control and status register access
These instructions access the control and status registers (CSRs) listed in Section 3.8.9 . A CSR instruction may read a
CSR, modify a CSR, or simultaneously read and modify the same CSR. A modification consists of a normal write, an
atomic bit-clear, or an atomic bit-set.
CSR addresses are in the range 0x000 through 0xfff (12 bits, 4096 possible CSRs). The CSR address is an immediate
constant in the instruction, so you cannot index CSRs with runtime values. The assembler accepts numeric constants or
RP2350 Datasheet
3.8. Hazard3 processor 274
CSR names such as mstatus as CSR addresses.
csrrc
Simultaneously read and clear bits in a CSR.
Usage:
csrrc rd, <addr>, rs1
csrc <addr>, rs1      // pseudo: rd is zero
Operation:
rd <= csr[addr];
if (regnum_rs1 != 5'h00)
    csr[addr] <= csr[addr] & ~rs1;
csrrci
Simultaneously read and clear bits in a CSR, with an immediate value for the clear.
Usage:
csrrci rd, <addr>, imm
csrci <addr>, imm      // pseudo: rd is zero
Operation:
rd <= csr[addr];
if (imm != 32'h0)
    csr[addr] <= csr[addr] & ~imm;
Immediate range: 0 through 31.
csrrs
Simultaneously read and set bits in a CSR.
Usage:
csrrs rd, <addr>, rs1
csrs <addr>, rs1       // pseudo: rd is zero
csrr rd, <addr>        // pseudo: rs1 is zero
Operation:
rd <= csr[addr];
if (regnum_rs1 != 5'h00)
    csr[addr] <= csr[addr] | rs1;
RP2350 Datasheet
3.8. Hazard3 processor 275
csrrsi
Simultaneously read and set bits in a CSR, with an immediate value for the set.
Usage:
csrrsi rd, <addr>, imm
csrsi <addr>, imm      // pseudo: rd is zero
Operation:
rd <= csr[addr];
if (imm != 32'h0)
    csr[addr] <= csr[addr] | imm;
Immediate range: 0 through 31.
csrrw
Simultaneously read and write a CSR.
Usage:
csrrw rd, <addr>, rs1
csrw <addr>, rs1       // pseudo: rd is zero
Operation:
if (regnum_rd != 5'h00)
    rd <= csr[addr];
csr[addr] <= rs1;
csrrwi
Simultaneously read and write a CSR, with an immediate value for the write.
Usage:
csrrwi rd, <addr>, imm
csrwi <addr>, imm      // pseudo: rd is zero
Operation:
if (regnum_rd != 5'h00)
    rd <= csr[addr];
csr[addr] <= imm;
Immediate range: 0 through 31.
RP2350 Datasheet
3.8. Hazard3 processor 276
3.8.1.23. Privileged instructions
These instructions are part of the trap and interrupt control support defined in the privileged ISA manual. The other part
of this support is the CSRs ( Section 3.8.9 ).
ebreak
Raise a breakpoint exception.
Usage:
ebreak
Operation:
raise_exception(4'h3); // Cause = ebreak
Compressible if: always.
Privilege requirements: any privilege level.
See Section 3.8.4  for details of the RISC-V trap entry sequence. All exceptions trap into M-mode on Hazard3. The
exception program counter mepc points to the start of the ebreak instruction.
An external debug host can catch the execution of breakpoint instructions. If the core is in M-mode, and
DCSR .EBREAKM is set, the core enters Debug mode instead of taking the exception. In U-mode, DCSR .EBREAKU
enables the same behaviour.
ecall
Environment call. Raise an exception to access a handler at a higher privilege level.
Usage:
ecall
Operation:
if (priv == 2'h3)
    raise_exception(4'hb); // Cause: Environment call from M-mode
else
    raise_exception(4'h8); // Cause: Environment call from U-mode
Privilege requirements: any privilege level.
See Section 3.8.4  for details of the RISC-V trap entry sequence. All exceptions trap into M-mode on Hazard3. The
exception program counter mepc points to the start of the ecall instruction.
mret
Return from M-mode trap.
Usage:
mret
RP2350 Datasheet
3.8. Hazard3 processor 277
Operation: execute the trap return sequence described in Section 3.8.4 .
Privilege requirements: M-mode only.
wfi
Wait for interrupt.
Usage:
wfi
Operation: pause execution until the processor is interrupted, or enters Debug mode.
Privilege requirements: M-mode is always permitted. U-mode is permitted if MSTATUS .TW is clear.
wfi ignores the global interrupt enable, MSTATUS .MIE. It respects all other interrupt controls. For example:
•If MIP.MEIP is 1, MIE.MEIE is 1, and MSTATUS .MIE is 0, a wfi instruction falls through immediately without
pausing.
•In this example, setting MSTATUS .MIE to 1 would cause the core to immediately take the interrupt.
•If no bit is set in both MIP and MIE, the wfi stalls until there is at least one such bit.
When a wfi is interrupted, the exception return address MEPC  points to the instruction following the wfi.
When the debugger halts the core during a wfi, DPC  points to the instruction immediately following the wfi
instruction. wfi executes as a no-op under instruction single-stepping (it does not stall), and under Debug-mode
execution in the Program Buffer.
Hazard3’s MSLEEP  CSR controls additional power-saving measures the core can implement during a wfi sleep
state.
3.8.2. Memory access
Hazard3 accesses memory within a 4 GB (232 bytes) physical address space. There is no address translation. Each
possible value of an integer register uniquely identifies a single byte in the physical address space. Multi-byte values
occupy consecutive byte addresses.
3.8.2.1. Endianness
Hazard3 is always little-endian for all load and store accesses. RISC-V instruction fetch is always little-endian.
This means in a multi-byte access such as a sw instruction (four bytes are transferred), data stored at higher byte
addresses has greater numerical significance. For example:
li a0, 0x0d0c0b0a            // materialise constant in register
la a4, some_global_variable  // materialise address (assume addr % 4 == 0)
sw a0, (a4)                  // 4-byte write to memory
lbu a0, 0(a4)                // load byte from addr + 0: 0x0a
lbu a1, 1(a4)                // load byte from addr + 1: 0x0b
lbu a2, 2(a4)                // load byte from addr + 2: 0x0c
lbu a3, 3(a4)                // load byte from addr + 3: 0x0d
RP2350 Datasheet
3.8. Hazard3 processor 278
3.8.2.2. Physical memory attributes
The RP2350 address space has the following physical memory attributes:
Table 366. List of
physical memory
attributes for the
RP2350 address
space. Main SRAM
supports all atomics,
other addresses
support none.
Peripherals are non-
idempotent, all other
addresses are
idempotent.Start End Description Access Atomicity Idempotency
0x00000000 0x00007fff Boot ROM No AMOs RsrvNone,
AMONoneIdempotent
0x10000000 0x13ffffff XIP, Cached No AMOs RsrvNone,
AMONoneIdempotent
0x14000000 0x17ffffff XIP, Uncached No AMOs RsrvNone,
AMONoneIdempotent
0x18000000 0x1bffffff XIP, Cache
MaintenanceWrite-only RsrvNone,
AMONoneIdempotent
0x1c000000 0x1fffffff XIP, Uncached +
UntranslatedNo AMOs RsrvNone,
AMONoneIdempotent
0x20000000 0x20081fff Main SRAM Any RsrvNonEventual,
AMOArithmeticIdempotent
0x40000000 0x4fffffff APB Peripherals No AMOs, no
instruction fetchRsrvNone,
AMONoneNon-idempotent
0x50000000 0x5fffffff AHB Peripherals No AMOs, no
instruction fetchRsrvNone,
AMONoneNon-idempotent
0xd0000000 0xdfffffff SIO Peripherals No AMOs, no
instruction fetchRsrvNone,
AMONoneNon-idempotent
All addresses have Strong ordering. Any address not listed in Table 366  is a Vacant address. Accessing these
addresses has no effect other than returning a bus fault.
Hazard3’s PMP implementation requires that non-read-idempotent PMAs are also non-executable, because it enforces
execute permissions at the point an instruction is executed, rather than the point an instruction is fetched. Therefore all
non-idempotent locations in Table 366  are also non-executable. This is enforced at a lower level than the PMP, and
executing these addresses at any privilege level will always fault.
Cached XIP regions are not cacheable from a PMA point of view, because the cache is private to the memory controller.
Each system address is served by either a single cache controller or none, so coherence between harts is irrelevant. You
might have to perform manual cache maintenance following some operations like flash programming, but this is a
detail of the XIP subsystem, not the system-level memory model.
For definitions of these attributes, see section 3.6 of the RISC-V privileged ISA manual linked in Section 3.8.1.1 .
3.8.3. Memory protection
Hazard3 implements Physical Memory Protection (PMP). It does not implement the Sv32 virtual memory extension or
its associated protections.
The PMP defines permissions for physical addresses. It mostly protects M-mode memory from S-mode and U-mode
access. Hazard3 only implements M-mode and U-mode.
A PMP region  applies read, write and execute permissions to a span of byte addresses. For each region there is one
address register, PMPADDR0  through PMPADDR15 , and an 8-bit configuration field packed into PMPCFG0  through
PMPCFG3 . The read, write and execute permissions are always enforced for U-mode. They may also be enforced for M-
mode, depending on the PMPCFG L bit for that region, and the PMPCFGM0  register.
RP2350 configures Hazard3’s PMP hardware with the following features:
RP2350 Datasheet
3.8. Hazard3 processor 279
•8× dynamically configurable regions, 0 through 7
•3× statically configured (hardwired) regions, 8 through 10
•(Remaining regions 11 through 15 are hardwired to OFF)
•A granule of 32 bytes
•Support for naturally aligned power of two ( NAPOT) region shapes only
•The custom PMPCFGM0  CSR can apply M-mode permissions to individual regions without locking them
Section 3.8.8.1  defines the configuration of the hardwired regions 8 through 10. These regions apply default U-mode
permissions to RP2350 ROM and peripherals, to avoid having to spend dynamic regions to cover these addresses. The
system-level ACCESSCTRL registers ( Section 10.6 ) can assign each peripheral individually to M-mode or U-mode.
When multiple PMP regions match the same byte address, the lowest-numbered of these regions takes effect. The
other regions are ignored.
3.8.3.1. PMP address registers
Addresses in PMP address registers PMPADDR0  through PMPADDR15  are stored with a right-shift of two, so that they
can cover a 16 GB physical address space when Sv32 address translation is in effect. Hazard3 does not implement
address translation, so the physical address space is 4 GB (32-bit byte-addressed) and the two MSBs of each address
register are hardwired to zero.
The RP2350 configuration of Hazard3 supports only the OFF and NAPOT values for the PMPCFG A fields (e.g.
PMPCFG0 .R0_A). Setting A to OFF means the region matches no bytes, and is effectively disabled. Setting A to NAPOT
means the region matches on a naturally aligned span of bytes (the base address modulo the size is zero) whose size is
a power of two.
The number of trailing 1s in the PMP address value encodes the size of an NAPOT region. This is the number of
consecutive 1s counted from the LSB without reaching a 0. A PMP address value with no trailing ones (ending in a 0)
matches a region eight bytes in size, and the region size is doubled with each additional 1 bit.
The PMP region matches on the address bits to the left of the least-significant 0 bit. Because the PMP address registers
are right-shifted by two, you must apply the same shift to the addresses being compared. The following examples
demonstrate how to match addresses based on PMPADDRx  values:
•The 30-bit all-ones bit pattern 0x3fffffff  has the maximum possible size, and matches all addresses.
•The all-zeroes bit pattern 0x00000000  has the minimum possible size.
◦Since there are no trailing 1s, this matches starting from bit 1 of the PMP address register.
◦Due to addresses being right-shifted by two, this is a region of eight bytes starting from address 0x0.
•The bit pattern 0x???????7  (where ? is any digit) matches any 64-byte region.
◦Shift the base address of this 64-byte region by two to get bits 29:4 of the PMPADDRx  value.
•The bit pattern 0x0800000f  matches byte addresses between 0x20000000  and 0x2000007f , the first 128 bytes of SRAM.
◦Right-shift the base address ( 0x20000000 ) by two to get 0x08000000 .
◦Add trailing ones to increase the region size and get the final value of 0x0800000f .
◦The size of the region is eight bytes times two to the power of the number of trailing 1 bits, which in this case
(four 1s) works out to 8 × 24 = 128 bytes.
For more examples of PMP address match patterns, see the hardwired PMP region values in Section 3.8.8.1 .
RP2350 configures Hazard3 with a granule  of 32 bytes. This means the two least-significant bits of each PMP address
register are hardwired to all-ones when the region is enabled. The hardware does not decode address regions smaller
than 32 bytes.
RP2350 Datasheet
3.8. Hazard3 processor 280
3.8.3.2. PMP permissions
Each 8-bit PMP configuration field contains three permission flags:
•R permits non-instruction-fetch reads:
◦load instructions
◦the read phase of AMOs
•W permits writes:
◦store instructions
◦the write phase of AMOs
•X permits instruction execution
A 1 value for each permission means it is granted, and a 0 means it is revoked. These permissions apply to U-mode
access to the region. They also apply to M-mode accesses when any of the following is true:
•The L (lock) configuration bit is 1
•The Hazard3 custom PMPCFGM0  register bit for this region is 1
The L (lock) bit also locks the associated PMP address register and 8-bit PMP configuration field, so that it ignores
future writes. You should always lock PMP regions consecutively from region 0, so that locked regions cannot be
bypassed by unlocked regions.
U-mode accesses that match no PMP regions have no permissions: all memory accesses fail. M-mode accesses that
match no PMP regions have all permissions. The hardwired PMP regions in Section 3.8.8.1  define additional U-mode
permissions for the ROM and peripheral address ranges: these can be overridden by enabling any of the dynamically
configured regions.
NOTE
Due to RP2350-E6  the field order in the PMP configuration fields is R, W, X (MSB-first) rather than the standard X, W, R.
The SDK register headers match the as-implemented order.
3.8.3.3. Accesses spanning multiple PMP regions
Hazard3 does not support non-naturally-aligned loads or stores, other than to generate standard exceptions when they
are attempted. Since NAPOT PMP regions are always naturally aligned, it is impossible for a load or store to span two
PMP regions. Therefore, all bytes covered by a load or store instruction are determined by at most a single active PMP
region that matches the lowest byte address accessed by that instruction.
Instructions are up to 32 bits in size with as little as 16-bit alignment. Therefore it is possible for an instruction to match
multiple PMP regions. When this happens, the instruction generates an instruction fault exception, ( mcause = 0x1), unless 
there is a lower-numbered PMP region that fully covers the instruction. Lower-numbered PMP regions take precedence.
The exact quote from the privileged ISA specification is: "The lowest-numbered PMP entry that matches any byte of an
access determines whether that access succeeds or fails. The matching PMP entry must match all bytes of an access, or
the access fails, irrespective of the L, R, W, and X bits."  (page 60 of RISC-V privileged ISA manual version 20211203).
The RISC-V specification is flexible in what is considered a single access for the purposes of memory protection
checking. Hazard3 considers the fetch of one instruction to be a single access. It therefore forbids instruction fetches
that straddle two PMP regions, even if both regions grant execute permission. Due to this architecture rule, portable
RISC-V software must not  assume it can execute instructions that span multiple PMP regions.
Avoid this issue by using hole-punching  region configurations in preference to glueing  configurations. Suppose you want
to cover the first 12 kB of SRAM ( 0x20000000  → 0x20002fff ), this can be achieved in two ways:
•One region adding permissions to 0x20000000  → 0x200001fff , and another region adding permissions to 0x20002000  →
0x20002fff
RP2350 Datasheet
3.8. Hazard3 processor 281
•One region adding permissions to 0x20000000  → 0x20003fff , and a lower-numbered region subtracting  permissions
from 0x20003000  → 0x20003fff
The former option has a crack between the two regions, which has potentially unwanted effects on some platforms. The
latter avoids this issue entirely.
3.8.4. Interrupts and exceptions
In the RISC-V privileged ISA manual, a trap refers to either an interrupt or an exception:
Interrupt
A signal from outside the processor requests that it temporarily abandons its current task to deal with some
system-level event. The processor responds by transferring control to an interrupt handler function.
Exception
An instruction encounters a condition that prevents that instruction from completing normally. The processor
transfers control to an exception handler function to deal with the exceptional condition before it can resume
execution.
The two are closely related, and they are collectively referred to as traps to avoid stating everything twice.
Hardware performs the following steps automatically and atomically when entering a trap:
1.Save the address of the interrupted or excepting instruction to MEPC
2.Set the MSB of MCAUSE  to indicate the cause is an interrupt, or clear it to indicate an exception
3.Write the detailed trap cause to the LSBs of the MCAUSE  register
4.Save the current privilege level to MSTATUS .MPP
5.Set the privilege to M-mode (note Hazard3 does not implement S-mode)
6.Save the current value of MSTATUS .MIE to MSTATUS .MPIE
7.Disable interrupts by clearing MSTATUS .MIE
8.Jump to the correct offset from MTVEC  depending on the trap cause
NOTE
The above sequence of events is standard and is also described in the RISC-V Privileged ISA Manual. See Section
3.8.1.1  for a list of links to RISC-V specifications.
All earlier instructions than the one pointed to by MEPC  execute normally, and their effects are visible to the trap
handler. These earlier instructions are not affected by the exception or interrupt. On the other hand the instruction
pointed to by MEPC , and all later instructions, does not execute before entering the trap handler. These instructions
have no visible side effects, with the possible exception of load/store fault exceptions, where the bus fault itself may
have observable effects on the bus or peripheral.
Expanding on the MEPC  behaviour in architectural terms, all traps are precise , meaning there exists some point in
program order where the trap handler observes all earlier instructions to have retired and all later instructions to have
not. The MEPC  register indicates this point. All exceptions are also synchronous , meaning there is a particular
instruction that originated the trap, and the trap architecturally takes place in between that instruction and its
predecessors in program order.
M-mode software executes an mret instruction to return to the interrupted or excepting instruction at the end of a
handler. This largely reverses the process of entering the trap:
1.Restore core privilege level to the value of MSTATUS .MPP
2.Write 0 (U-mode) to MSTATUS .MPP
RP2350 Datasheet
3.8. Hazard3 processor 282
3.Restore MSTATUS .MIE from MSTATUS .MPIE
4.Write 1 to MSTATUS .MPIE
5.Jump to the address in MEPC .
Often, the values restored on exit are exactly those values saved on entry. However this need not be the case, as all
CSRs mentioned above are read/writable by M-mode software at any time. Hand-manipulating the trap handling CSRs is
useful for low-level OS operations such as context switching, or to make exception handlers return to the instruction
after  the trap point by incrementing MEPC  before return. You can execute an mret without any prior trap, for example
when entering U-mode code from M-mode for the first time.
Hardware does not save or restore any other registers. In particular, it does not save the core GPRs, and software is
responsible for ensuring the execution of the handler does not perturb the foreground context. For an interrupt, this may
mean saving the core registers on the interruptee’s stack, or using the MSCRATCH  CSR to swap the stack pointer before
saving registers on a dedicated interrupt stack. For a fatal exception this may be unimportant, as there is no
requirement for the handler to return.
3.8.4.1. Exceptions
Exceptions occur for a variety of reasons. MCAUSE  indicates the specific reason for the latest exception:
Cause Meaning
0x0 Instruction alignment: Does not occur on RP2350, because 16-bit compressed instructions are
implemented, and it is impossible to jump to a byte-aligned address.
0x1 Instruction fetch fault: Attempted to fetch from an address that does not support instruction fetch (like
APB/AHB peripherals on RP2350), or lacks PMP execute permission, or is forbidden by ACCESSCTRL, or
returned a fault from the memory device itself.
0x2 Illegal instruction: Encountered an instruction that was not a valid RISC-V opcode implemented by this
processor, or attempted to access a nonexistent CSR, or attempted to execute a privileged instruction or
access a privileged CSR without sufficient privilege.
0x3 Breakpoint: An ebreak or c.ebreak  instruction was executed, and no external debug host caught it (
DCSR .EBREAKM or DCSR .EBREAKU was not set).
0x4 Load alignment: Attempted to load from an address that was not a multiple of access size.
0x5 Load fault: Attempted to load from an address that does not exist, or lacks PMP read permissions, or is
forbidden by ACCESSCTRL, or returned a fault from a peripheral.
0x6 Store/AMO alignment: Attempted to write to an address that was not a multiple of access size.
0x7 Store/AMO fault: Attempted to write to an address that does not exist, or lacks PMP write permissions, or
is forbidden by ACCESSCTRL, or returned a fault from a peripheral. Also raised when attempting an AMO
on an address that does not support AHB5 exclusives.
0x8 An ecall instruction was executed in U-mode.
0xb An ecall instruction was executed in M-mode.
Exceptions jump to exactly the address of MTVEC , no matter the cause and no matter whether vectoring is enabled.
The MSTATUS .MIE global interrupt enable does not affect exception entry. You can still take an exception and trap into
the exception handler when exceptions are disabled.
Returning from an exception will jump to MEPC , which hardware sets to the address of the excepting instruction before
entering the exception handler. This means by default you will return to the exact same instruction that caused the
exception. When emulating illegal instructions, you should increment mepc before returning, so that execution resumes
after the problematic instruction.
Hazard3 hardwires mtval to zero. To emulate a misaligned load/store instruction you must decode the instruction and
RP2350 Datasheet
3.8. Hazard3 processor 283
read the spilled register state to calculate the address, and to emulate an illegal instruction you must read the
instruction bits from memory yourself by dereferencing mepc.
3.8.4.2. Interrupts
Hazard3 implements the standard RISC-V interrupt scheme with a single external interrupt routed to MIP.MEIP, and the
standard timer and soft interrupts routed to MTIP and MSIP. An interrupt controller such as a standard RISC-V PLIC can
be integrated externally to route multiple interrupts through to the single external interrupt line. Alternatively, the
Hazard3 interrupt controller (see Xh3irq extension, Section 3.8.6.1 ) multiplexes multiple external interrupts onto
MIP.MEIP in such a way that interrupts can efficiently pre-empt one another, with configurable dynamic priority per
interrupt.
RP2350 configures Hazard3 with the Xh3irq interrupt controller, with 52 external interrupt lines and 16 levels of pre-
emption priority. The IRQ numbers for the system-level interrupts, documented in Section 3.2 , are the same on both Arm
and RISC-V.
The core enters an interrupt when all of the following are true:
•MSTATUS .MIE is set
•An interrupt pending bit in the standard MIP CSR is set
•The matching interrupt enable in the standard MIE CSR is also set
When vectoring is disabled (LSB of MTVEC  is clear), interrupts transfer control directly to the address indicated by mtvec.
Setting the LSB enables vectoring: interrupts transfer control to the address mtvec + 4 * cause , where the interrupt cause
is one of:
•meip: cause = 11
•mtip: cause = 7
•msip: cause = 3
The pointer written to mtvec must be word-aligned (4 bytes). Additionally, when vectoring is enabled, it must be aligned
to the size of the table, rounded up to a power of two. This works out to 64-byte alignment. On RP2350, mtvec is fully
writable except for bit 1, which is hardwired to zero as it is only used for additional vectoring modes not supported by
Hazard3.
When multiple interrupts are active, hardware picks one to enter, in the order meip > msip > mtip. (This is not quite the
same order as the cause values.)
3.8.4.2.1. RISC-V interrupt signals
The standard timer interrupt MIP.MTIP connects to the RISC-V platform timer in the SIO subsystem ( Section 3.1.8 ). This
is a 64-bit timer with a per-core 64-bit comparison value. The interrupt is asserted whenever the timer is greater than or
equal to the comparison value, and de-asserts automatically when less than. The same interrupt signal also appears in
the system-level IRQs, as SIO_IRQ_MTIMECMP  (IRQ 29). The timer is a standard RISC-V peripheral, often used by operating
systems to generate context switch interrupts.
The standard software interrupt MIP.MSIP connects to the RISCV_SOFTIRQ  register in the SIO subsystem. The register
has a single bit per hart, which asserts the soft IRQ interrupt to that hart. This can be used to interrupt the other hart, or
to interrupt yourself as though the other hart had interrupted you, which can help to make handler code more
symmetric. On RP2350 there is a one-to-one correspondence between harts and cores, so you could equivalently say
there is one soft IRQ per core.
Hazard3’s internal interrupt controller drives the MIP.MEIP external interrupt pending bit based on its internal state and
the system-level interrupt signals, to transfer control to the interrupt vector when it is both safe and necessary. Section
3.8.6.1  describes the Xh3irq interrupt controller in depth.
RP2350 Datasheet
3.8. Hazard3 processor 284
3.8.4.2.2. Interrupt calling convention
The default SDK hardware_irq  library expects function pointers registered for system-level IRQs to be normal C functions.
There must be no __attribute__((interrupt))  on an interrupt handler passed into functions such as
set_exclusive_irq_handler().  This is an API detail that is consistent across all architectures supported by the SDK. Using
regular C calling convention is also efficient under heavy interrupt load, because the cost of saving/restoring all caller
save and temporary registers can be amortised over multiple interrupt handlers due to tail sharing, and a save triggered
by a low-priority IRQ can be taken over by a high-priority IRQ that asserted during the save.
Conversely, handlers registered for the standard RISC-V mtip and msip interrupts via the SDK
irq_set_riscv_vector_handler()  function must be __attribute__((interrupt)) . In terms of the generated code, this means
they should use save-as-you-go calling convention, and end with an mret. These interrupts are entered directly by the
hardware without any intermediate dispatch code.
As software is responsible for the dispatch to individual system interrupt handlers from the meip vector, it is possible to
support other interrupt calling conventions by supplying a different implementation for the dispatch.
3.8.5. Debug
RISC-V debug specification
Hazard3 implements version 0.13.2 of the RISC-V External Debug Support specification, available at:
riscv.org/wp-content/uploads/2019/03/riscv-debug-release.pdf
RP2350 implements a single RISC-V Debug Module, which enables debug access to the two Hazard3 processor
instances. Hazard3 should be supported by any debug translator implementing version 0.13.2 of the RISC-V External
Debug Support specification, but some details of its implementation-defined behaviour are described here for
completeness. The Debug Module source code, available in the Hazard3 repository, can be consulted to answer more
detailed questions about the debug implementation.
As configured on RP2350, Hazard3 supports the following standard RISC-V debug features:
•Run/halt/reset control of each processor
•Halt-on-reset support for all processors
•Hart array mask register, for halting/resuming multiple processors simultaneously
•Abstract access to GPRs
•Program Buffer: 2 words with an implicit ebreak (impebreak )
•Automatic trigger of abstract commands ( abstractauto )
•System Bus Access, arbitrated with core 1’s load/store port
•An instruction address trigger unit with four hardware breakpoints
3.8.5.1. Accessing the Debug Module
The Debug Module is accessed through a CoreSight APB-AP, which can be accessed in one of two ways:
•Externally, through the system’s SW-DP (see Section 3.5 )
•Internally, via self-hosted debug (see Section 3.5.6 )
The APB-AP for the Debug Module is located at offset 0xa000 in the debug address space. The Debug Module starts at
address 0 in the APB-AP’s downstream address space. The Debug Module addresses registers in increments of four
bytes, as APB is byte-addressed rather than word-addressed. This means the Debug Module register addresses listed in
the RISC-V debug specification must be multiplied by four.
RP2350 Datasheet
3.8. Hazard3 processor 285
3.8.5.2. Harts
Each Hazard3 core possesses exactly one hardware thread, or hart. This means each processor executes only a single
stream of instructions at a time. The two Hazard3 processor cores on RP2350, core 0 and 1, have hart IDs of 0 and 1
respectively. These values can be read from the MHARTID  register on each processor, and match the values read from
the CPUID  register in SIO.
The dmcontrol.hartsel  field in RP2350’s Debug Module supports writing the values 0 and 1 only (it implements only a
single writable bit), and these correspond to hart IDs 0 and 1, which execute on core 0 and core 1 respectively.
3.8.5.3. Resets
The dmcontrol.hartreset  field resets the selected cores only. This can be a single core selected by dmcontrol.hartsel , or
multiple cores selected by the hart array mask. It does not reset cores that are not selected, nor does it reset any other
system hardware. There is a one-to-one correspondence between harts and cores on this system.
The dmcontrol.ndmreset  field resets both cores. It does not reset any other hardware. As per the specification: "Exactly
what is affected by this reset is implementation dependent, as long as it is possible to debug programs from the first
instruction executed."
3.8.5.4. Implementation-defined behaviour
The following are not implemented:
•Abstract access memory
•Abstract access CSR
•Post-incrementing abstract access GPR
The core behaves as follows:
•Branch, jal, jalr and auipc are illegal in Debug mode, because they observe PC: attempting to execute will halt
Program Buffer execution and report an exception in abstractcs.cmderr
•The dret instruction is not implemented (a special purpose DM-to-core signal is used to signal resume)
•The dscratch  CSRs are not implemented
•The Debug Module’s data0 register is mapped into the core as a CSR, DMDATA0
•dcsr.stepie  is hardwired to 0 (no interrupts during single stepping)
•dcsr.stopcount  and dcsr.stoptime  are hardwired to 1 (no counter or internal timer increment in Debug mode)
•dcsr.mprven  is hardwired to 0
•dcsr.prv  accepts only the values 3 (M-mode) and 0 (U-mode), rounding to nearest on write
For more details on the core-side Debug mode registers, see DCSR  and DPC .
The trigger unit implements four exact instruction address match triggers. Triggers can be configured to trap to M-
mode as well as Debug-mode, meaning M-mode can use triggers for self-hosted hardware breakpoint support. The
tcontrol.mte  and tcontrol.mpte  fields are implemented to avoid infinite exception loops when an M-mode trigger is set on
the M-mode exception handler.
3.8.6. Custom extensions
Hazard3 implements a small number of custom extensions. All are optional: custom extensions are only included if the
relevant feature flags are set to 1 when instantiating the processor ( Section 3.8.8 ). Hazard3 is always a conforming 
RISC-V implementation; when these extensions are disabled, it is also a standard  RISC-V implementation.
RP2350 Datasheet
3.8. Hazard3 processor 286
If any one of these extensions is enabled, the x bit in MISA  is set to indicate the presence of a non-standard extension.
3.8.6.1. Xh3irq: Hazard3 interrupt controller
Xh3irq controls up to 512 external interrupts, with up to 16 levels of pre-emption. It is architected as a layer on top of the
standard mip.meip  external interrupt line, and all standard RISC-V interrupt behaviour still applies. This extension adds no
new instructions, but does add several CSRs:
•MEIEA : external interrupt enable array
•MEIPA : external interrupt pending array
•MEIFA : external interrupt force array
•MEIPRA : external interrupt priority array
•MEINEXT : get next external interrupt
•MEICONTEXT : external interrupt context register
Xh3irq is geared towards supporting interrupt handlers as bare C functions, with dispatch implemented in software and
pre-emption priority logic implemented in hardware. However, the exact interrupt ABI is up to the implementation of the
soft dispatch routine installed as the mip.meip  external interrupt handler.
3.8.6.1.1. Array CSRs
RISC-V CSRs are ideal for interrupt controls because they are closely coupled to the processor, offer native atomic
set/clear accesses, and can be accessed in a single instruction without first having to materialise an address. However
there are issues with using CSRs for large bit arrays, such as interrupt enables:
•The CSR address space is limited
•CSRs can not be addressed indirectly, so are difficult to iterate over
•Using a CSR to index other CSRs is problematic for interrupt handlers due to additional mutable state
Xh3irq uses the array CSR  idiom to expose a large bit vector at a single CSR address, such as MEIEA . The upper half of
the CSR is a 16-bit window into the array, and the window is indexed by the LSBs of the write data for the same CSR
instruction.
For example, the following assembly code writes 0xa5a5 to bits 47:32 of the interrupt enable array, since the window
index is 0x2 and the window is 16 bits in size:
    li a0, 0xa5a50002
    csrw RVCSR_MEIEA_OFFSET, a0
The following reads bits 63:48 of the interrupt pending array into register a0, since the index is 0x3, and a CSR set of
0x0000 does not modify the window contents:
    csrrsi a0, RVCSR_MEIPA_OFFSET, 0x3
Setting an arbitrary IRQ enable from C works as follows:
void enable_irq(uint irq) {
    uint index = irq / 16;
    uint32_t mask = 1u << (irq % 16);
    asm (
RP2350 Datasheet
3.8. Hazard3 processor 287
        "csrs 0xbe0, %0\n"
        : : "r" (index | (mask << 16))
    );
}
Getting an arbitrary IRQ pending flag from C is as follows:
bool check_irq_pending(uint irq) {
    uint index = irq / 16;
    uint32_t csr_rdata;
    asm (
        "csrrs %0, 0xbe1, %1\n"
        : "=r" (csr_rdata)
        : "r" (index)
    );
    csr_rdata >>= 16;
    return csr_rdata & (1u << (irq % 16));
}
The SDK implements similar operations in the hardware_irq  API.
Hazard3 supports up to 512 interrupts, which is one 16-bit window for each of the possible values of a 5-bit CSR
immediate.
3.8.6.1.2. Enable, pending, and force arrays
The MEIEA , MEIPA  and MEIFA  CSRs expose the interrupt enable, pending and force arrays respectively. Each array
contains one bit per system-level interrupt line, of which there are 52 lines in total. (See Section 3.2  for the assignment
of system IRQ numbers to peripherals.)
The interrupt enable array gates the entry of interrupt signals into the core. When a bit is clear in MEIEA , the
corresponding interrupt signal is ignored. When a bit is set, assertion of the corresponding interrupt signal will send the
core to the meip vector as soon as it is safe and appropriate to do so. From there, the meip handler vectors to the correct
handler, after saving the interruptee’s context.
The SDK irq_set_enabled()  function in the hardware_irq  library is a convenient way to manipulate the interrupt enable
array.
The interrupt pending array displays the current status of the system-level interrupt signals. Interrupts are visible in
MEIPA  even if the corresponding bit is clear in MEIEA , and even if the interrupt has insufficient priority to interrupt the
core at this time. This register is read-only: bits in MEIPA  clear automatically when the corresponding interrupt source
de-asserts. For example, a UART RX FIFO interrupt should clear on its own after data has been read from the FIFO.
The interrupt force array causes interrupts to appear pending, even when the corresponding system-level interrupt
signal is de-asserted. When a bit is set in MEIFA , the corresponding bit in MEIPA  reads as 1, and will interrupt the core if
it meets the usual prerequisites.
MEIFA  bits clear automatically when the corresponding interrupt is sampled from MEINEXT . It is not necessary to write
a 1 bit to MEINEXT .UPDATE for the interrupt force bit to clear. This means setting an MEIFA  bit should cause the
interrupt to be taken once . Normal csrw and csrc instructions will also clear MEIFA .
Six spare interrupt lines 46 through 51, referred to as SPAREIRQ_IRQ_0  through SPAREIRQ_IRQ_5  in the SDK, deliberately do not
connect to system-level hardware. However they are still fully implemented in the interrupt controller, and fire when set
pending in MEIFA . For example, a fast interrupt top-half handler can schedule its longer-running bottom half to run at a
lower priority, or a high-priority context switch interrupt might schedule a context switch to take place at a lower priority
in order to clear interrupt frames off the stack.
RP2350 Datasheet
3.8. Hazard3 processor 288
3.8.6.1.3. Next interrupt register
MEINEXT  always displays the next interrupt that should be handled, taking priority order into account. Interrupts appear
in MEINEXT  when they meet all of the following criteria:
1.Pending in MEIPA
2.Enabled in MEIEA
3.Of priority greater than or equal to MEICONTEXT .PPREEMPT
The value returned is the IRQ number of the highest-priority interrupt that meets these three criteria, left-shifted by two.
When multiple interrupts have the highest priority, the lowest-numbered of those interrupts is chosen, as a tie-break.
The MSB of MEINEXT  is set to indicate there were no eligible interrupts, and the remaining bits are undefined in this
case. Software should repeatedly read MEINEXT until all available interrupts are exhausted. The bltz and bgez
instructions are a convenient way to test the MSB of a register.
The purpose of rule 3 above is to ensure that any interrupt that may already be in progress in a pre-empted interrupt
frame is not re-entered in the current frame. Without this rule, multiple executions of the same interrupt handler could be
interleaved due to pre-emption by other handlers. Programmers are usually surprised when this happens.
MEINEXT .UPDATE is a write-only field which instructs hardware to update MEICONTEXT  with information about the
interrupt displayed in MEINEXT  on that cycle. Section 3.8.6.1.5  goes into more detail about context register updates.
IMPORTANT
MEINEXT  is constantly changing as interrupt signals come and go. The write to MEINEXT .UPDATE must be the
same instruction  that reads the interrupt index from MEINEXT  to avoid a data race. This can be achieved with a csrrw
or csrrwi instruction.
3.8.6.1.4. Interrupt priority
The interrupt priority array MEIPRA  implements a four-bit field per interrupt. In hardware, numerically higher (unsigned)
MEIPRA  values have higher priority, taking precedence over lower-priority interrupts. The irq_set_priority()  SDK
function uses the opposite convention, with lower numeric values indicating greater precedence. This section uses the
hardware numbering.
The interrupt priority in MEIPRA  determines three things:
1.Whether the interrupt source is permitted to interrupt the core at this moment: must be greater than or equal
MEICONTEXT .PREEMPT
2.Whether the interrupt source can appear in MEINEXT : must be greater than or equal to MEICONTEXT .PPREEMPT
3.What order this interrupt will appear in when there are multiple candidates for MEINEXT
When MEICONTEXT  is correctly saved and restored, PREEMPT and PPREEMPT are both zero outside of interrupt
handlers, and PREEMPT is strictly greater than PPREEMPT when inside an interrupt handler. Together they define the
band of interrupt priorities which may be processed without any pushing or popping of interrupt stack frames.
Manipulating interrupt priority outside of interrupts is safe. There is no need to disable interrupts when writing to the
priority array. Manipulating interrupt priority inside  of an interrupt handler requires care: hardware operation is well-
defined, but the results can be surprising. Be wary of the following cases:
1.Increasing the priority of the current handler: if still enabled and pending, you will instantly pre-empt yourself.
2.Increasing the priority of a different interrupt, with priority lower than MEICONTEXT .PPREEMPT: this interrupt may
already be in progress in a frame that was pre-empted in order to run your handler. Increasing the priority may
cause it to execute in a higher frame before returning to the original frame where it is still in progress, thereby
interleaving with its own execution.
PPREEMPT is guaranteed to be no greater than the current handler priority if MEICONTEXT  is correctly saved/restored,
since it contains the previous value of PREEMPT at the time a pre-emption took place, and interrupts lower than
RP2350 Datasheet
3.8. Hazard3 processor 289
PREEMPT can not interrupt the core. Therefore a safe approximation for case 2 above is: do not increase (by any
amount) the priority of a handler with lower priority than the currently running handler.
If an interrupt must  increase the priority of a lower-priority interrupt, one solution is to queue up interrupt priority
updates, and pend a lowest-priority handler assigned to one of the spare IRQs, which processes the enqueued updates.
You can pend this handler manually by setting its bit in MEIFA . The handler will run last thing before returning to
foreground code. This is safe because an interrupt of the lowest priority by definition can not have pre-empted any other
interrupts.
3.8.6.1.5. Interrupt context management
The MEICONTEXT  register has two functions: manage the core pre-emption priority across multiple pre-empting
interrupt stack frames, and help software track which interrupt handler it is currently executing, if any.
MEICONTEXT .PREEMPT, MEICONTEXT .PPREEMPT and MEICONTEXT .PPPREEMPT form a three-level stack of pre-
emption priorities:
•PREEMPT sets the minimum interrupt priority which interrupts the core
•PPREEMPT  sets the minimum interrupt priority which appears in MEINEXT : this avoids redundant execution of
interrupt handlers which may have been pre-empted
•PPPREEMPT  has no hardware function other than save/restore of PPREEMPT
When entering the MIP.MEIP vector, hardware atomically performs the following updates to MEICONTEXT 
simultaneous to the standard trap entry sequence described in Section 3.8.4 :
1.Save the current value of MEICONTEXT .PPREEMPT to PPPREEMPT
2.Save the current value of MEICONTEXT .PREEMPT to PPREEMPT
3.Write one plus the priority of the IRQ which caused this interrupt to MEICONTEXT .PREEMPT
4.Write 1 to MEICONTEXT .MRETEIRQ, to enable priority restore on next mret
The standard trap entry sequence includes clearing MSTATUS .MIE, so interrupts are disabled at the start of the handler.
To implement pre-emption, the MIP.MEIP handler must re-enable interrupts after its context save critical section. This
should include saving MEICONTEXT , MSTATUS , MEPC , and the caller-saved general-purpose registers.
Any trap entry not caused by MIP.MEIP clears MRETEIRQ. Trap exit ( mret) also clears MRETEIRQ.
A trap exit where MEICONTEXT .MRETEIRQ is set atomically performs the following updates to MEICONTEXT 
simultaneous to the standard trap exit sequence:
1.Restore MEICONTEXT .PREEMPT from MEICONTEXT .PPREEMPT
2.Restore MEICONTEXT .PPREEMPT from MEICONTEXT .PPPREEMPT
3.Write 0 to MEICONTEXT .PPPREEMPT
The MRETEIRQ flag allows hardware to match each MIP.MEIP vector entry with its associated mret. This balances
pushes and pops of the PREEMPT priority stack. When there is no pre-emption, and no exceptions raised within
interrupt handlers, MRETEIRQ can be left in place in the MEICONTEXT .MRETEIRQ register. Otherwise, you must save
MEICONTEXT  upon entering the external interrupt vector and restore it before the mret at the end of the handler.
Interrupts must be disabled during save/restore.
Writing 1 to MEINEXT .UPDATE updates MEICONTEXT  as follows:
1.Write MEINEXT .NOIRQ to MEICONTEXT .NOIRQ
2.Write MEINEXT .IRQ (the IRQ number) to MEICONTEXT .IRQ
3.If MEINEXT .NOIRQ is…
◦Clear: Write one plus the priority of MEINEXT .IRQ to MEICONTEXT .PREEMPT
RP2350 Datasheet
3.8. Hazard3 processor 290
◦Set: Write 0x10 to MEICONTEXT .PREEMPT (greater than any interrupt priority in MEIPRA )
MEICONTEXT .IRQ and NOIRQ help code determine in which interrupt handler it is running. MEICONTEXT  should be
saved/restored by interrupts which pre-empt the current one, so is safe to check these fields during  the handler.
The update to MEICONTEXT .PREEMPT upon writing MEINEXT .UPDATE ensures the core will be pre-empted by
interrupts higher-priority than the one it is about to enter. Equally important, it ensures the core is not pre-empted by
lower or equal priority interrupts, including the one whose handler it is about to enter.
To avoid awkward interactions between the MIP.MEIP handler, which should be aware of the Xh3irq extension, and the
MTIP/MSIP handlers, which may not be, it’s best to avoid pre-emption of the former by the latter.
MEICONTEXT .CLEARTS, MTIESAVE and MSIESAVE support disabling and restoring the timer/software interrupt
enables as part of the MEICONTEXT  CSR accesses that take place during context save/restore in the MEIP handler.
3.8.6.1.6. Minimal handler example
This example demonstrates a minimal meip handler which dispatches to an array of C-function interrupt handlers,
without enabling pre-emption. In this case the priorities configured in MEIPRA  still determine the order in which
interrupts are entered when multiple are asserted, but when an interrupt handler starts running, no other interrupts are
serviced until that handler completes.
#include "hardware/regs/rvcsr.h"
isr_riscv_machine_external_irq:
    // Save all caller saves and temporaries before entering a C ABI function.
    // Note mstatus.mie is cleared by hardware on interrupt entry, and
    // we're going to leave it clear.
    addi sp, sp, -64
    sw ra,  0(sp)
    sw t0,  4(sp)
    sw t1,  8(sp)
    sw t2, 12(sp)
    sw a0, 16(sp)
    sw a1, 20(sp)
    sw a2, 24(sp)
    sw a3, 28(sp)
    sw a4, 32(sp)
    sw a5, 36(sp)
    sw a6, 40(sp)
    sw a7, 44(sp)
    sw t3, 48(sp)
    sw t4, 52(sp)
    sw t5, 56(sp)
    sw t6, 60(sp)
get_first_irq:
    // Sample the current highest-priority active IRQ (left-shifted by 2) from
    // meinext. Don't set the `update` bit as we aren't saving/restoring meicontext --
    // this is fine, just means you can't check meicontext to see whether you are in an IRQ.
    csrr a0, RVCSR_MEINEXT_OFFSET
    // MSB will be set if there is no active IRQ at the current priority level
    bltz a0, no_more_irqs
dispatch_irq:
    // Load indexed table entry and jump through it. No bounds checking is necessary
    // because the hardware will not return a nonexistent IRQ.
    lui a1, %hi(__soft_vector_table)
    add a1, a1, a0
    lw a1, %lo(__soft_vector_table)(a1)
    jalr ra, a1
get_next_irq:
RP2350 Datasheet
3.8. Hazard3 processor 291
    // Get the next-highest-priority IRQ
    csrr a0, RVCSR_MEINEXT_OFFSET
    // MSB will be set if there is no active IRQ at the current priority level
    bgez a0, dispatch_irq
no_more_irqs:
    // Restore saved context and return from IRQ
    lw ra,  0(sp)
    lw t0,  4(sp)
    lw t1,  8(sp)
    lw t2, 12(sp)
    lw a0, 16(sp)
    lw a1, 20(sp)
    lw a2, 24(sp)
    lw a3, 28(sp)
    lw a4, 32(sp)
    lw a5, 36(sp)
    lw a6, 40(sp)
    lw a7, 44(sp)
    lw t3, 48(sp)
    lw t4, 52(sp)
    lw t5, 56(sp)
    lw t6, 60(sp)
    addi sp, sp, 64
    mret
// Array of function pointers for interrupt handlers
.section ".bss"
.p2align 2
.global __soft_vector_table
__soft_vector_table:
.space 52 * 4
Since the handler loops on meinext until no more interrupts are pending, multiple interrupts are processed with a single
save/restore of the caller saves and temporaries.
The pending status of each IRQ in MEIPA  clears when the corresponding peripheral de-asserts its interrupt output. A
correctly programmed interrupt handler should cause the peripheral interrupt to de-assert, so each successive read
from meinext will return a new interrupt. Because meinext always returns the highest-priority active interrupt, this loop
iterates over active interrupts in descending priority order.
The overhead of performing the register save/restore in software is minimal because the save/restore routine is limited
by bus bandwidth, not by instruction execution overhead. This also makes the hardware more flexible because the same
hardware can support multiple interrupt ABIs.
3.8.6.2. Xh3pmpm: M-mode PMP regions
This extension adds a new M-mode CSR, PMPCFGM0 , which allows a PMP region to be enforced in M-mode without
locking the region.
This is useful when the PMP is used for non-security-related purposes such as stack guarding, or trapping and
emulation of peripheral accesses.
3.8.6.3. Xh3power: Hazard3 power management
This extension adds a new M-mode CSR ( MSLEEP ), and two new hint instructions, h3.block  and h3.unblock , in the slt
nop-compatible custom hint space.
The msleep CSR controls how deeply the processor sleeps in the WFI sleep state. By default, a WFI is implemented as a
RP2350 Datasheet
3.8. Hazard3 processor 292
normal pipeline stall. By configuring msleep appropriately, the processor can gate its own clock when asleep or, with a
simple 4-phase req/ack handshake, negotiate power up/down of external hardware with an external power controller.
These options can improve the sleep current at the cost of greater wakeup latency.
The hints allow processors to sleep until woken by other processors in a multiprocessor environment. They are
implemented on top of the standard WFI state, which means they interact in the same way with external debug, and
benefit from the same deep sleep states in msleep.
3.8.6.3.1. h3.block
Enter a WFI sleep state until either an unblock signal is received, or an interrupt is asserted that would cause a WFI to
exit.
If mstatus.tw  is set, attempting to execute this instruction in privilege modes lower than M-mode will generate an illegal
instruction exception.
If an unblock signal has been received in the time since the last h3.block , this instruction executes as a nop, and the
processor does not enter the sleep state. Conceptually, the sleep state falls through immediately because the
corresponding unblock signal has already been received.
An unblock signal is received when a neighbouring processor (the exact definition of "neighbouring" being left to the
implementer) executes an h3.unblock  instruction, or for some other platform-defined reason.
This instruction is encoded as slt x0, x0, x0 , which is part of the custom nop-compatible hint encoding space.
Example C macro:
#define __h3_block() asm ("slt x0, x0, x0")
Example assembly macro:
.macro h3.block
    slt x0, x0, x0
.endm
3.8.6.3.2. h3.unblock
Post an unblock signal to other processors in the system. For example, to notify another processor that a work queue is
now non-empty.
If mstatus.tw  is set, attempting to execute this instruction in privilege modes lower than M-mode will generate an illegal
instruction exception.
This instruction is encoded as slt x0, x0, x1 , which is part of the custom nop-compatible hint encoding space.
Example C macro:
#define __h3_unblock() asm ("slt x0, x0, x1")
Example assembly macro:
RP2350 Datasheet
3.8. Hazard3 processor 293
.macro h3.unblock
    slt x0, x0, x1
.endm
3.8.6.4. Xh3bextm: Hazard3 bit extract multiple
This is a small extension with multi-bit versions of the "bit extract" instructions from Zbs, used for extracting small,
contiguous bit fields.
3.8.6.4.1. h3.bextm
"Bit extract multiple", a multi-bit version of the bext instruction from Zbs. Perform a right-shift followed by a mask of 1-8
LSBs.
Encoding (R-type):
Bits Name Value Description
31:29 funct7[6:4] 0b000 RES0
28:26 size - Number of ones in mask, values 0 →7 encode 1 →8 bits.
25 funct7[0] 0b0 RES0, because aligns with shamt[5]  of potential RV64
version of h3.bextmi
24:20 rs2 - Source register 2 (shift amount)
19:15 rs1 - Source register 1
14:12 funct3 0b000 h3.bextm
11:7 rd - Destination register
6:2 opc 0b01011 custom0 opcode
1:0 size 0b11 32-bit instruction
Example C macro (using GCC statement expressions):
// nbits must be a constant expression
#define __h3_bextm(nbits, rs1, rs2) ({\
    uint32_t __h3_bextm_rd; \
    asm (".insn r 0x0b, 0, %3, %0, %1, %2"\
        : "=r" (__h3_bextm_rd) \
        : "r" (rs1), "r" (rs2), "i" ((((nbits) - 1) & 0x7) << 1)\
    ); \
    __h3_bextm_rd; \
})
Example assembly macro:
// rd = (rs1 >> rs2[4:0]) & ~(-1 << nbits)
.macro h3.bextm rd rs1 rs2 nbits
.if (\nbits < 1) || (\nbits > 8)
.err
.endif
#if NO_HAZARD3_CUSTOM
RP2350 Datasheet
3.8. Hazard3 processor 294
    srl  \rd, \rs1, \rs2
    andi \rd, \rd, ((1 << \nbits) - 1)
#else
.insn r 0x0b, 0x0, (((\nbits - 1) & 0x7 ) << 1), \rd, \rs1, \rs2
#endif
.endm
3.8.6.4.2. h3.bextmi
Immediate variant of h3.bextm .
Encoding (I-type):
Bits Name Value Description
31:29 imm[11:9] 0b000 RES0
28:26 size - Number of ones in mask, values 0 →7 encode 1 →8 bits.
25 imm[5] 0b0 RES0, for potential future RV64 version
24:20 shamt - Shift amount, 0 through 31
19:15 rs1 - Source register 1
14:12 funct3 0b100 h3.bextmi
11:7 rd - Destination register
6:2 opc 0b01011 custom0 opcode
1:0 size 0b11 32-bit instruction
Example C macro (using GCC statement expressions):
// nbits and shamt must be constant expressions
#define __h3_bextmi(nbits, rs1, shamt) ({\
    uint32_t __h3_bextmi_rd; \
    asm (".insn i 0x0b, 0x4, %0, %1, %2"\
        : "=r" (__h3_bextmi_rd) \
        : "r" (rs1), "i" ((((nbits) - 1) & 0x7) << 6 | ((shamt) & 0x1f)) \
    ); \
    __h3_bextmi_rd; \
})
Example assembly macro:
// rd = (rs1 >> shamt) & ~(-1 << nbits)
.macro h3.bextmi rd rs1 shamt nbits
.if (\nbits < 1) || (\nbits > 8)
.err
.endif
.if (\shamt < 0) || (\shamt > 31)
.err
.endif
#if NO_HAZARD3_CUSTOM
    srli \rd, \rs1, \shamt
    andi \rd, \rd, ((1 << \nbits) - 1)
#else
.insn i 0x0b, 0x4, \rd, \rs1, (\shamt & 0x1f) | (((\nbits - 1) & 0x7 ) << 6)
RP2350 Datasheet
3.8. Hazard3 processor 295
#endif
.endm
3.8.7. Instruction cycle counts
All timings are given assuming perfect bus behaviour (no downstream bus stalls).
See Section 3.8.1.6  for a synopsis of instruction behaviour.
3.8.7.1. RV32I
Instruction Cycles Note
Integer Register-register
add rd, rs1, rs2 1
sub rd, rs1, rs2 1
slt rd, rs1, rs2 1
sltu rd, rs1, rs2 1
and rd, rs1, rs2 1
or rd, rs1, rs2 1
xor rd, rs1, rs2 1
sll rd, rs1, rs2 1
srl rd, rs1, rs2 1
sra rd, rs1, rs2 1
Integer Register-immediate
addi rd, rs1, imm 1 nop is a pseudo-op for addi x0, x0, 0
slti rd, rs1, imm 1
sltiu rd, rs1, imm 1
andi rd, rs1, imm 1
ori rd, rs1, imm 1
xori rd, rs1, imm 1
slli rd, rs1, imm 1
srli rd, rs1, imm 1
srai rd, rs1, imm 1
Large Immediate
lui rd, imm 1
auipc rd, imm 1
Control Transfer
jal rd, label 2[1]
jalr rd, rs1, imm 2[1]
RP2350 Datasheet
3.8. Hazard3 processor 296
Instruction Cycles Note
beq rs1, rs2, label 1 or 2[1]1 if correctly predicted, 2 if mispredicted.
bne rs1, rs2, label 1 or 2[1]1 if correctly predicted, 2 if mispredicted.
blt rs1, rs2, label 1 or 2[1]1 if correctly predicted, 2 if mispredicted.
bge rs1, rs2, label 1 or 2[1]1 if correctly predicted, 2 if mispredicted.
bltu rs1, rs2, label 1 or 2[1]1 if correctly predicted, 2 if mispredicted.
bgeu rs1, rs2, label 1 or 2[1]1 if correctly predicted, 2 if mispredicted.
Load and Store
lw rd, imm(rs1) 1 or 2 1 if next instruction is independent, 2 if dependent.[2]
lh rd, imm(rs1) 1 or 2 1 if next instruction is independent, 2 if dependent.[2]
lhu rd, imm(rs1) 1 or 2 1 if next instruction is independent, 2 if dependent.[2]
lb rd, imm(rs1) 1 or 2 1 if next instruction is independent, 2 if dependent.[2]
lbu rd, imm(rs1) 1 or 2 1 if next instruction is independent, 2 if dependent.[2]
sw rs2, imm(rs1) 1
sh rs2, imm(rs1) 1
sb rs2, imm(rs1) 1
3.8.7.2. M extension
Instruction Cycles Note
32 × 32 → 32 Multiply
mul rd, rs1, rs2 1
32 × 32 → 64 Multiply, Upper Half
mulh rd, rs1, rs2 1
mulhsu rd, rs1, rs2 1
mulhu rd, rs1, rs2 1
Divide and Remainder
div rd, rs1, rs2 18 or 19 Depending on sign correction
divu rd, rs1, rs2 18
rem rd, rs1, rs2 18 or 19 Depending on sign correction
remu rd, rs1, rs2 18
3.8.7.3. A extension
Instruction Cycles Note
Load-Reserved/Store-Conditional
lr.w rd, (rs1) 1 or 2 2 if next instruction is dependent[2], an lr.w, sc.w or amo*.w.[3]
sc.w rd, rs2, (rs1) 1 or 2 2 if next instruction is dependent[2], an lr.w, sc.w or amo*.w.[3]
RP2350 Datasheet
3.8. Hazard3 processor 297
Instruction Cycles Note
Atomic Memory Operations
amoswap.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
amoadd.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
amoxor.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
amoand.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
amoor.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
amomin.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
amomax.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
amominu.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
amomaxu.w rd, rs2, (rs1) 4+ 4 per attempt. Multiple attempts if reservation is lost.[4]
3.8.7.4. C extension
All C extension 16-bit instructions are aliases of base RV32I instructions. On Hazard3, they perform identically to their
32-bit counterparts.
A consequence of the C extension is that 32-bit instructions can be non-naturally-aligned. This has no penalty during
sequential execution, but branching to a 32-bit instruction that is not 32-bit-aligned carries a 1 cycle penalty, because
the instruction fetch is cracked into two naturally-aligned bus accesses.
3.8.7.5. Privileged instructions (including Zicsr)
Instruction Cycles Note
CSR Access
csrrw rd, csr, rs1 1
csrrc rd, csr, rs1 1
csrrs rd, csr, rs1 1
csrrwi rd, csr, imm 1
csrrci rd, csr, imm 1
csrrsi rd, csr, imm 1
Traps and Interrupts
ecall 3 Time given is for jumping to mtvec
ebreak 3 Time given is for jumping to mtvec
mret 2[1]
wfi 2+ Always stalls for one cycle, no upper limit
3.8.7.6. Bit manipulation
RP2350 Datasheet
3.8. Hazard3 processor 298
Instruction Cycles Note
Zba (address generation)
sh1add rd, rs1, rs2 1
sh2add rd, rs1, rs2 1
sh3add rd, rs1, rs2 1
Zbb (basic bit manipulation)
andn rd, rs1, rs2 1
clz rd, rs1 1
cpop rd, rs1 1
ctz rd, rs1 1
max rd, rs1, rs2 1
maxu rd, rs1, rs2 1
min rd, rs1, rs2 1
minu rd, rs1, rs2 1
orc.b rd, rs1 1
orn rd, rs1, rs2 1
rev8 rd, rs1 1
rol rd, rs1, rs2 1
ror rd, rs1, rs2 1
rori rd, rs1, imm 1
sext.b rd, rs1 1
sext.h rd, rs1 1
xnor rd, rs1, rs2 1
zext.h rd, rs1 1
zext.b rd, rs1 1 zext.b is a pseudo-op for andi rd, rs1, 0xff
Zbs (single-bit manipulation)
bclr rd, rs1, rs2 1
bclri rd, rs1, imm 1
bext rd, rs1, rs2 1
bexti rd, rs1, imm 1
binv rd, rs1, rs2 1
binvi rd, rs1, imm 1
bset rd, rs1, rs2 1
bseti rd, rs1, imm 1
Zbkb (basic bit manipulation for cryptography)
pack rd, rs1, rs2 1
packh rd, rs1, rs2 1
RP2350 Datasheet
3.8. Hazard3 processor 299
Instruction Cycles Note
brev8 rd, rs1 1
zip rd, rs1 1
unzip rd, rs1 1
3.8.7.7. Zcb extension
Similarly to the C extension, this extension contains 16-bit variants of common 32-bit instructions:
•RV32I base ISA: lbu, lh, lhu, sb, sh, zext.b (alias of andi), not (alias of xori)
•Zbb extension: sext.b, zext.h, sext.h
•M extension: mul
They perform identically to their 32-bit counterparts.
3.8.7.8. Zcmp extension
Instruction Cycles Note
cm.push rlist, -imm 1 + n n is number of registers in rlist
cm.pop rlist, imm 1 + n n is number of registers in rlist
cm.popret rlist, imm 4 (n = 1)[5] or 2 + n (n >= 2)[1]n is number of registers in rlist
cm.popretz rlist, imm 5 (n = 1)[5] or 3 + n (n >= 2)[1]n is number of registers in rlist
cm.mva01s r1s', r2s' 2
cm.mvsa01 r1s', r2s' 2
3.8.7.9. Table footnotes
[1]A jump or branch to a 32-bit instruction that isn’t 32-bit-aligned requires one additional cycle because two
naturally aligned bus cycles are required to fetch the target instruction.
[2]If an instruction in stage 2 (e.g. an add) uses data from stage 3 (e.g. a lw result), a 1-cycle bubble is inserted
between the pair. A load data → store data dependency is not an example of this, because data is
produced and consumed in stage 3. However, load data → load address would  qualify, as would e.g. sc.w
→ beqz.
[3]AMOs are issued as a paired exclusive read and exclusive write on the bus, at the maximum speed of 2
cycles per access, since the bus does not permit pipelining of exclusive reads/writes. If the write phase
fails due to the global monitor reporting a lost reservation, the instruction loops at a rate of 4 cycles per
loop, until success. If the read reservation is refused by the global monitor, the instruction generates a
Store/AMO Fault exception, to avoid an infinite loop.
[4]A pipeline bubble is inserted between lr.w/sc.w and an immediately-following lr.w/sc.w/amo*, because the
AHB5 bus standard does not permit pipelined exclusive accesses. A stall would be inserted between lr.w
and sc.w anyhow, so the local monitor can be updated based on the lr.w data phase in time to suppress the
sc.w address phase.
[5]The single-register variants of cm.popret  and cm.popretz  take the same number of cycles as the two-register
variants, because of an internal load-use dependency on the loaded return address.
RP2350 Datasheet
3.8. Hazard3 processor 300
3.8.7.10. Branch predictor
Hazard3 includes a minimal branch predictor, to accelerate tight loops:
•The instruction frontend remembers the last taken, backward branch in a single-entry branch target buffer  (BTB)
•If the same branch is seen again, it is predicted taken
•All other branches are predicted non-taken
•If the core executes but does not take a predicted-taken branch:
◦The core clears the BTB
◦The branch is predicted non-taken on its next execution
Correctly predicted branches execute in one cycle: the frontend is able to stitch together the two nonsequential fetch
paths so that they appear sequential. Mispredicted branches incur a penalty cycle, since a nonsequential fetch address
must be issued when the branch is executed. Consider the following copy routine:
// a0 is dst pointer
// a1 is src pointer
// a2 is len
copy_data:
    beqz a2, 2f
    add a2, a2, a1
1:
    lbu a3, (a0)
    sb a3, (a1)
    addi a0, a0, 1
    addi a1, a1, 1
    bltu a1, a2, 1b
2:
    ret
In the steady state this executes at 5 cycles per loop:
•One cycle for the load
•One cycle for the store: though it depends on the load, the dependency is within stage 3 so there is no stall
•One cycle for each add
•One cycle for the repeatedly-taken backward branch
Without the branch predictor the throughput is 6 cycles per loop. The branch predictor increases the throughput by 20%,
and also reduces energy dissipation due to wasted instruction fetch (memory access is a large fraction of the
instruction energy cost for an embedded processor).
For the above example code, a copy of 10 bytes would take 52 cycles:
•The base cost is 5 cycles per iteration, and there are 10 iterations
•The mispredicted, taken branch at the end of the first iteration costs one cycle
•The mispredicted, non-taken branch at the end of the last iteration costs one cycle
3.8.7.10.1. Caveat: delay loops
The branch predictor does not engage when all of the following are true:
•The loop body consists of a single 16-bit instruction (followed by a repeatedly taken backward branch)
•The loop body is 32-bit-aligned
RP2350 Datasheet
3.8. Hazard3 processor 301
•There are no bus stalls on the instruction fetch port
This is because the branch predictor lookup functions by comparing bits 31:2 of the sequential-fetch counter to the BTB
tag. In this case the BTB tag points to the same word as the loop entry. In the aforementioned case the sequential-fetch
counter never actually contains the address of the loop entry, because the loop entry address goes straight to the bus,
and the sequential-fetch counter pre-increments to the next address. This manifests in delay loops like the following:
.p2align 2
delay_loop_bad_dont_copy_paste_this:
    addi a0, a0, -1
    bgez a0, delay_loop_bad_dont_copy_paste_this
Given the description in Section 3.8.7.10 , you might expect this loop to execute at two cycles per iteration in the steady
state. The actual behaviour is it executes at three  cycles per iteration until instruction fetch encounters a stall,
whereupon it accelerates to two cycles per instruction until the loop ends.
Avoid this by using a 32-bit instruction in the loop body. Force 32-bit alignment of the loop body to avoid an alignment
penalty. The following code executes at the expected two cycles per iteration in the steady state:
.p2align 2          // Force 4-byte alignment
delay_cycles:
.option push
.option norvc       // Force 32-bit opcode
    addi a0, a0, -1
.option pop
    bgez a0, delay_cycles
3.8.8. Configuration
Hazard3 uses the parameters given in the hazard3_config.vh  header to customise the core. These values are set before
taping out a Hazard3 instance on silicon, so they are fixed  from a user point of view. They determine which instructions
the processor supports, the area-performance trade-off for certain instructions, and static configuration for core
peripherals like the PMP. RP2350 uses the following values for these parameters:
Parameter Value
EXTENSION_A 1
EXTENSION_C 1
EXTENSION_M 1
EXTENSION_ZBA 1
EXTENSION_ZBB 1
EXTENSION_ZBC 0
EXTENSION_ZBS 1
EXTENSION_ZCB 1
EXTENSION_ZCMP 1
EXTENSION_ZBKB 1
EXTENSION_ZIFENCEI 1
EXTENSION_XH3BEXTM 1
EXTENSION_XH3IRQ 1
RP2350 Datasheet
3.8. Hazard3 processor 302
Parameter Value
EXTENSION_XH3PMPM 1
EXTENSION_XH3POWER 1
CSR_M_MANDATORY 1
CSR_M_TRAP 1
CSR_COUNTER 1
U_MODE 1
PMP_REGIONS 11
PMP_GRAIN 3
PMP_HARDWIRED 11’h700
PMP_HARDWIRED_ADDR See Section 3.8.8.1
PMP_HARDWIRED_CFG See Section 3.8.8.1
DEBUG_SUPPORT 1
BREAKPOINT_TRIGGERS 4
NUM_IRQS 52
IRQ_PRIORITY_BITS 4
IRQ_INPUT_BYPASS {NUM_IRQS{1 ’b1}}
MVENDORID_VAL 32’h00000493
MIMPID_VAL 32’h86fc4e3f
MCONFIGPTR_VAL 32’h0
REDUCED_BYPASS 0
MULDIV_UNROLL 2
MUL_FAST 1
MUL_FASTER 1
MULH_FAST 1
FAST_BRANCHCMP 1
RESET_REGFILE 1
BRANCH_PREDICTOR 1
MTVEC_WMASK 32’hfffffffd
3.8.8.1. Hardwired PMP regions
RP2350 configures Hazard3 with eight dynamically configured PMP regions, and three static ones. The static regions
provide default U-mode RWX permissions on the following ranges:
•ROM: 0x00000000  through 0x0fffffff
•Peripherals: 0x40000000  through 0x5fffffff
•SIO: 0xd0000000  through 0xdfffffff
These addresses appear in PMPADDR8 , PMPADDR9  and PMPADDR10 . The hardwired PMP address registers behave
the same as dynamic registers, except that they ignore writes (exercising the WARL rule). The permissions for these
RP2350 Datasheet
3.8. Hazard3 processor 303
regions are in PMPCFG2 .
The hardwired regions have a similar role to the Exempt regions added to the Cortex-M33 IDAU address map specified
in Section 10.2.2 .
RP2350 puts default U-mode permissions on AHB/APB peripherals because these are expected to be assigned using
ACCESSCTRL ( Section 10.6 ). ACCESSCTRL can assign each peripheral individually, using the existing address decoders
in the bus fabric, whereas PMP regions are in limited supply so are less useful for peripheral assignment.
Similarly, SIO has internal banking over Secure/Non-secure bus attribution, which is mapped onto Machine and User
modes as described in Section 10.6.2 .
The dynamic regions 0 through 7 take priority over the hardwired regions, because the PMP prioritises lower-numbered
regions.
3.8.9. Control and status registers
Control and status registers (CSRs) are registers internal to the processor that affect its behaviour. They are hart-local:
every hart has a copy of the CSRs. On RP2350 hart-local is a synonym for core-local.
Use dedicated CSR instructions to access the CSRs, as described in Section 3.8.1.22 . You cannot access CSRs with
load or store instructions.
The RISC-V privileged specification is flexible on which CSRs are implemented, and how they behave. This section
documents the as-implemented behaviour of CSRs on Hazard3 specifically, and does not enumerate all possible
behaviour of all platforms.
IMPORTANT
The RISC-V Privileged Specification  should be your primary reference for writing software to run on Hazard3.
Portable RISC-V software should not rely on any implementation-defined behaviour described in this section.
All CSRs are 32-bit, and MXLEN is fixed at 32 bits. CSR addresses not listed in this section are unimplemented.
Accessing an unimplemented CSR raises an illegal instruction exception ( mcause = 2). This includes all S-mode CSRs.
Table 367. List of
RVCSR registersOffset Name Info
0x300 MSTATUS Machine status register
0x301 MISA Summary of ISA extension support
0x302 MEDELEG Machine exception delegation register. Not implemented, as no
S-mode support.
0x303 MIDELEG Machine interrupt delegation register. Not implemented, as no S-
mode support.
0x304 MIE Machine interrupt enable register
0x305 MTVEC Machine trap handler base address.
0x306 MCOUNTEREN Counter enable. Control access to counters from U-mode. Not to
be confused with mcountinhibit.
0x30a MENVCFG Machine environment configuration register, low half
0x310 MSTATUSH High half of mstatus, hardwired to 0.
0x31a MENVCFGH Machine environment configuration register, high half
0x320 MCOUNTINHIBIT Count inhibit register for mcycle/minstret
0x323 MHPMEVENT3 Extended performance event selector, hardwired to 0.
RP2350 Datasheet
3.8. Hazard3 processor 304
Offset Name Info
0x324 MHPMEVENT4 Extended performance event selector, hardwired to 0.
0x325 MHPMEVENT5 Extended performance event selector, hardwired to 0.
0x326 MHPMEVENT6 Extended performance event selector, hardwired to 0.
0x327 MHPMEVENT7 Extended performance event selector, hardwired to 0.
0x328 MHPMEVENT8 Extended performance event selector, hardwired to 0.
0x329 MHPMEVENT9 Extended performance event selector, hardwired to 0.
0x32a MHPMEVENT10 Extended performance event selector, hardwired to 0.
0x32b MHPMEVENT11 Extended performance event selector, hardwired to 0.
0x32c MHPMEVENT12 Extended performance event selector, hardwired to 0.
0x32d MHPMEVENT13 Extended performance event selector, hardwired to 0.
0x32e MHPMEVENT14 Extended performance event selector, hardwired to 0.
0x32f MHPMEVENT15 Extended performance event selector, hardwired to 0.
0x330 MHPMEVENT16 Extended performance event selector, hardwired to 0.
0x331 MHPMEVENT17 Extended performance event selector, hardwired to 0.
0x332 MHPMEVENT18 Extended performance event selector, hardwired to 0.
0x333 MHPMEVENT19 Extended performance event selector, hardwired to 0.
0x334 MHPMEVENT20 Extended performance event selector, hardwired to 0.
0x335 MHPMEVENT21 Extended performance event selector, hardwired to 0.
0x336 MHPMEVENT22 Extended performance event selector, hardwired to 0.
0x337 MHPMEVENT23 Extended performance event selector, hardwired to 0.
0x338 MHPMEVENT24 Extended performance event selector, hardwired to 0.
0x339 MHPMEVENT25 Extended performance event selector, hardwired to 0.
0x33a MHPMEVENT26 Extended performance event selector, hardwired to 0.
0x33b MHPMEVENT27 Extended performance event selector, hardwired to 0.
0x33c MHPMEVENT28 Extended performance event selector, hardwired to 0.
0x33d MHPMEVENT29 Extended performance event selector, hardwired to 0.
0x33e MHPMEVENT30 Extended performance event selector, hardwired to 0.
0x33f MHPMEVENT31 Extended performance event selector, hardwired to 0.
0x340 MSCRATCH Scratch register for machine trap handlers
0x341 MEPC Machine exception program counter
0x342 MCAUSE Machine trap cause. Set when entering a trap to indicate the
reason for the trap. Readable and writable by software.
0x343 MTVAL Machine bad address or instruction. Hardwired to zero.
0x344 MIP Machine interrupt pending
0x3a0 PMPCFG0 Physical memory protection configuration for regions 0 through
3
RP2350 Datasheet
3.8. Hazard3 processor 305
Offset Name Info
0x3a1 PMPCFG1 Physical memory protection configuration for regions 4 through
7
0x3a2 PMPCFG2 Physical memory protection configuration for regions 8 through
11
0x3a3 PMPCFG3 Physical memory protection configuration for regions 12 through
15
0x3b0 PMPADDR0 Physical memory protection address for region 0
0x3b1 PMPADDR1 Physical memory protection address for region 1
0x3b2 PMPADDR2 Physical memory protection address for region 2
0x3b3 PMPADDR3 Physical memory protection address for region 3
0x3b4 PMPADDR4 Physical memory protection address for region 4
0x3b5 PMPADDR5 Physical memory protection address for region 5
0x3b6 PMPADDR6 Physical memory protection address for region 6
0x3b7 PMPADDR7 Physical memory protection address for region 7
0x3b8 PMPADDR8 Physical memory protection address for region 8
0x3b9 PMPADDR9 Physical memory protection address for region 9
0x3ba PMPADDR10 Physical memory protection address for region 10
0x3bb PMPADDR11 Physical memory protection address for region 11
0x3bc PMPADDR12 Physical memory protection address for region 12
0x3bd PMPADDR13 Physical memory protection address for region 13
0x3be PMPADDR14 Physical memory protection address for region 14
0x3bf PMPADDR15 Physical memory protection address for region 15
0x7a0 TSELECT Select trigger to be configured via tdata1/tdata2
0x7a1 TDATA1 Trigger configuration data 1
0x7a2 TDATA2 Trigger configuration data 2
0x7b0 DCSR Debug control and status register (Debug Mode only)
0x7b1 DPC Debug program counter (Debug Mode only)
0xb00 MCYCLE Machine-mode cycle counter, low half
0xb02 MINSTRET Machine-mode instruction retire counter, low half
0xb03 MHPMCOUNTER3 Extended performance counter, hardwired to 0.
0xb04 MHPMCOUNTER4 Extended performance counter, hardwired to 0.
0xb05 MHPMCOUNTER5 Extended performance counter, hardwired to 0.
0xb06 MHPMCOUNTER6 Extended performance counter, hardwired to 0.
0xb07 MHPMCOUNTER7 Extended performance counter, hardwired to 0.
0xb08 MHPMCOUNTER8 Extended performance counter, hardwired to 0.
0xb09 MHPMCOUNTER9 Extended performance counter, hardwired to 0.
0xb0a MHPMCOUNTER10 Extended performance counter, hardwired to 0.
RP2350 Datasheet
3.8. Hazard3 processor 306
Offset Name Info
0xb0b MHPMCOUNTER11 Extended performance counter, hardwired to 0.
0xb0c MHPMCOUNTER12 Extended performance counter, hardwired to 0.
0xb0d MHPMCOUNTER13 Extended performance counter, hardwired to 0.
0xb0e MHPMCOUNTER14 Extended performance counter, hardwired to 0.
0xb0f MHPMCOUNTER15 Extended performance counter, hardwired to 0.
0xb10 MHPMCOUNTER16 Extended performance counter, hardwired to 0.
0xb11 MHPMCOUNTER17 Extended performance counter, hardwired to 0.
0xb12 MHPMCOUNTER18 Extended performance counter, hardwired to 0.
0xb13 MHPMCOUNTER19 Extended performance counter, hardwired to 0.
0xb14 MHPMCOUNTER20 Extended performance counter, hardwired to 0.
0xb15 MHPMCOUNTER21 Extended performance counter, hardwired to 0.
0xb16 MHPMCOUNTER22 Extended performance counter, hardwired to 0.
0xb17 MHPMCOUNTER23 Extended performance counter, hardwired to 0.
0xb18 MHPMCOUNTER24 Extended performance counter, hardwired to 0.
0xb19 MHPMCOUNTER25 Extended performance counter, hardwired to 0.
0xb1a MHPMCOUNTER26 Extended performance counter, hardwired to 0.
0xb1b MHPMCOUNTER27 Extended performance counter, hardwired to 0.
0xb1c MHPMCOUNTER28 Extended performance counter, hardwired to 0.
0xb1d MHPMCOUNTER29 Extended performance counter, hardwired to 0.
0xb1e MHPMCOUNTER30 Extended performance counter, hardwired to 0.
0xb1f MHPMCOUNTER31 Extended performance counter, hardwired to 0.
0xb80 MCYCLEH Machine-mode cycle counter, high half
0xb82 MINSTRETH Machine-mode instruction retire counter, low half
0xb83 MHPMCOUNTER3H Extended performance counter, hardwired to 0.
0xb84 MHPMCOUNTER4H Extended performance counter, hardwired to 0.
0xb85 MHPMCOUNTER5H Extended performance counter, hardwired to 0.
0xb86 MHPMCOUNTER6H Extended performance counter, hardwired to 0.
0xb87 MHPMCOUNTER7H Extended performance counter, hardwired to 0.
0xb88 MHPMCOUNTER8H Extended performance counter, hardwired to 0.
0xb89 MHPMCOUNTER9H Extended performance counter, hardwired to 0.
0xb8a MHPMCOUNTER10H Extended performance counter, hardwired to 0.
0xb8b MHPMCOUNTER11H Extended performance counter, hardwired to 0.
0xb8c MHPMCOUNTER12H Extended performance counter, hardwired to 0.
0xb8d MHPMCOUNTER13H Extended performance counter, hardwired to 0.
0xb8e MHPMCOUNTER14H Extended performance counter, hardwired to 0.
0xb8f MHPMCOUNTER15H Extended performance counter, hardwired to 0.
RP2350 Datasheet
3.8. Hazard3 processor 307
Offset Name Info
0xb90 MHPMCOUNTER16H Extended performance counter, hardwired to 0.
0xb91 MHPMCOUNTER17H Extended performance counter, hardwired to 0.
0xb92 MHPMCOUNTER18H Extended performance counter, hardwired to 0.
0xb93 MHPMCOUNTER19H Extended performance counter, hardwired to 0.
0xb94 MHPMCOUNTER20H Extended performance counter, hardwired to 0.
0xb95 MHPMCOUNTER21H Extended performance counter, hardwired to 0.
0xb96 MHPMCOUNTER22H Extended performance counter, hardwired to 0.
0xb97 MHPMCOUNTER23H Extended performance counter, hardwired to 0.
0xb98 MHPMCOUNTER24H Extended performance counter, hardwired to 0.
0xb99 MHPMCOUNTER25H Extended performance counter, hardwired to 0.
0xb9a MHPMCOUNTER26H Extended performance counter, hardwired to 0.
0xb9b MHPMCOUNTER27H Extended performance counter, hardwired to 0.
0xb9c MHPMCOUNTER28H Extended performance counter, hardwired to 0.
0xb9d MHPMCOUNTER29H Extended performance counter, hardwired to 0.
0xb9e MHPMCOUNTER30H Extended performance counter, hardwired to 0.
0xb9f MHPMCOUNTER31H Extended performance counter, hardwired to 0.
0xbd0 PMPCFGM0 Set PMP regions to M-mode, without locking
0xbe0 MEIEA External interrupt enable array
0xbe1 MEIPA External interrupt pending array
0xbe2 MEIFA External interrupt force array
0xbe3 MEIPRA External interrupt priority array
0xbe4 MEINEXT Get next external interrupt
0xbe5 MEICONTEXT External interrupt context register
0xbf0 MSLEEP M-mode sleep control register
0xbff DMDATA0 Debug Module DATA0 access register (Debug Mode only)
0xc00 CYCLE Read-only U-mode alias of mcycle, accessible when mcounteren.cy
is set
0xc02 INSTRET Read-only U-mode alias of minstret, accessible when
mcounteren.ir  is set
0xc80 CYCLEH Read-only U-mode alias of mcycleh, accessible when
mcounteren.cy  is set
0xc82 INSTRETH Read-only U-mode alias of minstreth, accessible when
mcounteren.ir  is set
0xf11 MVENDORID Vendor ID
0xf12 MARCHID Architecture ID (Hazard3)
0xf13 MIMPID Implementation ID. On RP2350 this reads as 0x86fc4e3f, which
is release v1.0-rc1 of Hazard3.
RP2350 Datasheet
3.8. Hazard3 processor 308
Offset Name Info
0xf14 MHARTID Hardware thread ID
0xf15 MCONFIGPTR Pointer to configuration data structure (hardwired to 0)
RVCSR : MSTATUS Register
Offset : 0x300
Description
Machine status register
Table 368. MSTATUS
RegisterBits Description Type Reset
31:22 Reserved. - -
21 TW: Timeout wait. When 1, attempting to execute a WFI instruction in U-mode
will instantly cause an illegal instruction exception.RW 0x0
20:18 Reserved. - -
17 MPRV : Modify privilege. If 1, loads and stores behave as though the current
privilege level were mpp. This includes physical memory protection checks, and
the privilege level asserted on the system bus alongside the load/store
address.RW 0x0
16:13 Reserved. - -
12:11 MPP : Previous privilege level. Can store the values 3 (M-mode) or 0 (U-mode).
If another value is written, hardware rounds to the nearest supported mode.RW 0x3
10:8 Reserved. - -
7 MPIE : Previous interrupt enable. Readable and writable. Is set to the current
value of mstatus.mie  on trap entry. Is set to 1 on trap return.RW 0x0
6:4 Reserved. - -
3 MIE: Interrupt enable. Readable and writable. Is set to 0 on trap entry. Is set to
the current value of mstatus.mpie  on trap return.RW 0x0
2:0 Reserved. - -
RVCSR : MISA Register
Offset : 0x301
Description
Summary of ISA extension support
On RP2350, Hazard3’s full -march string is: rv32ima_zicsr_zifencei_zba_zbb_zbs_zbkb_zca_zcb_zcmp
Note Zca is equivalent to the C extension in this case; all instructions from the RISC-V C extension relevant to a 32-bit
non-floating-point processor are supported. On older toolchains which do not support the Zc extensions, the appropriate
-march string is: rv32imac_zicsr_zifencei_zba_zbb_zbs_zbkb
In addition the following custom extensions are configured: Xh3bm, Xh3power, Xh3irq, Xh3pmpm
Table 369. MISA
RegisterBits Description Type Reset
31:30 MXL : Value of 0x1 indicates this is a 32-bit processor. RO 0x1
29:24 Reserved. - -
RP2350 Datasheet
3.8. Hazard3 processor 309
Bits Description Type Reset
23 X: Value of 1 indicates nonstandard extensions are present. (Xh3b bit
manipulation, and custom sleep and interrupt control CSRs)RO 0x1
22 Reserved. - -
21 V: Vector extension (not implemented). RO 0x0
20 U: Value of 1 indicates U-mode is implemented. RO 0x1
19 Reserved. - -
18 S: Supervisor extension (not implemented). RO 0x0
17 Reserved. - -
16 Q: Quad-precision floating point extension (not implemented). RO 0x0
15:13 Reserved. - -
12 M: Value of 1 indicates the M extension (integer multiply/divide) is
implemented.RO 0x1
11:9 Reserved. - -
8 I: Value of 1 indicates the RVI base ISA is implemented (as opposed to RVE) RO 0x1
7 H: Hypervisor extension (not implemented, I agree it would be pretty cool on a
microcontroller through).RO 0x0
6 Reserved. - -
5 F: Single-precision floating point extension (not implemented). RO 0x0
4 E: RV32E/64E base ISA (not implemented). RO 0x0
3 D: Double-precision floating point extension (not implemented). RO 0x0
2 C: Value of 1 indicates the C extension (compressed instructions) is
implemented.RO 0x1
1 B: Value of 1 indicates the B extension (bit manipulation) is implemented. B is
the combination of Zba, Zbb and Zbs.
Hazard3 implements all of these extensions, but the definition of B as
ZbaZbbZbs did not exist at the point this version of Hazard3 was taped out.
This bit was reserved-0 at that point. Therefore this bit reads as 0.RO 0x0
0 A: Value of 1 indicates the A extension (atomics) is implemented. RO 0x1
RVCSR : MEDELEG Register
Offset : 0x302
Table 370. MEDELEG
RegisterBits Description Type Reset
31:0 Machine exception delegation register. Not implemented, as no S-mode
support.RW -
RVCSR : MIDELEG Register
Offset : 0x303
RP2350 Datasheet
3.8. Hazard3 processor 310
Table 371. MIDELEG
RegisterBits Description Type Reset
31:0 Machine interrupt delegation register. Not implemented, as no S-mode
support.RW -
RVCSR : MIE Register
Offset : 0x304
Description
Machine interrupt enable register
Table 372. MIE
RegisterBits Description Type Reset
31:12 Reserved. - -
11 MEIE : External interrupt enable. The processor transfers to the external
interrupt vector when mie.meie , mip.meip  and mstatus.mie  are all 1.
Hazard3 has internal registers to individually filter external interrupts (see
meiea), but this standard control can be used to mask all external interrupts at
once.RW 0x0
10:8 Reserved. - -
7 MTIE : Timer interrupt enable. The processor transfers to the timer interrupt
vector when mie.mtie , mip.mtip  and mstatus.mie  are all 1, unless a software or
external interrupt request is also both pending and enabled at this time.RW 0x0
6:4 Reserved. - -
3 MSIE : Software interrupt enable. The processor transfers to the software
interrupt vector when mie.msie , mip.msip  and mstatus.mie  are all 1, unless an
external interrupt request is also both pending and enabled at this time.RW 0x0
2:0 Reserved. - -
RVCSR : MTVEC Register
Offset : 0x305
Description
Machine trap handler base address.
Table 373. MTVEC
RegisterBits Description Type Reset
31:2 BASE : The upper 30 bits of the trap vector address (2 LSBs are implicitly 0).
Must be 64-byte-aligned if vectoring is enabled. Otherwise, must be 4-byte-
aligned.RW 0x00001fff
1:0 MODE : If 0 (direct mode), all traps set pc to the trap vector base. If 1
(vectored), exceptions set pc to the trap vector base, and interrupts set pc to 4
times the interrupt cause (3=soft IRQ, 7=timer IRQ, 11=external IRQ).
The upper bit is hardwired to zero, so attempting to set mode to 2 or 3 will
result in a value of 0 or 1 respectively.RW 0x0
Enumerated values:
0x0 → DIRECT: Direct entry to mtvec
0x1 → VECTORED: Vectored entry to a 16-entry jump table starting at mtvec
RP2350 Datasheet
3.8. Hazard3 processor 311
RVCSR : MCOUNTEREN Register
Offset : 0x306
Description
Counter enable. Control access to counters from U-mode. Not to be confused with mcountinhibit.
Table 374.
MCOUNTEREN
RegisterBits Description Type Reset
31:3 Reserved. - -
2 IR: If 1, U-mode is permitted to access the instret/instreth  instruction retire
counter CSRs. Otherwise, U-mode accesses to these CSRs will trap.RW 0x0
1 TM: No hardware effect, as the time/timeh CSRs are not implemented.
However, this field still exists, as M-mode software can use it to track whether
it should emulate U-mode attempts to access those CSRs.RW 0x0
0 CY: If 1, U-mode is permitted to access the cycle/cycleh cycle counter CSRs.
Otherwise, U-mode accesses to these CSRs will trap.RW 0x0
RVCSR : MENVCFG Register
Offset : 0x30a
Description
Machine environment configuration register, low half
Table 375. MENVCFG
RegisterBits Description Type Reset
31:1 Reserved. - -
0 FIOM : When set, fence instructions in modes less privileged than M-mode
which specify that IO memory accesses are ordered will also cause ordering
of main memory accesses.
FIOM is hardwired to zero on Hazard3, because S-mode is not supported, and
because fence instructions execute as NOPs (with the exception of fence.i)RO 0x0
RVCSR : MSTATUSH Register
Offset : 0x310
Table 376. MSTATUSH
RegisterBits Description Type Reset
31:0 High half of mstatus, hardwired to 0. RO 0x00000000
RVCSR : MENVCFGH Register
Offset : 0x31a
Description
Machine environment configuration register, high half
This register is fully reserved, as Hazard3 does not implement the relevant extensions. It is implemented as hardwired-
0.
RP2350 Datasheet
3.8. Hazard3 processor 312
Table 377.
MENVCFGH RegisterBits Description Type Reset
31:0 Reserved. - -
RVCSR : MCOUNTINHIBIT Register
Offset : 0x320
Description
Count inhibit register for mcycle/minstret
Table 378.
MCOUNTINHIBIT
RegisterBits Description Type Reset
31:3 Reserved. - -
2 IR: Inhibit counting of the minstret  and minstreth  registers. Set by default to
save power.RW 0x1
1 Reserved. - -
0 CY: Inhibit counting of the mcycle and mcycleh registers. Set by default to save
power.RW 0x1
RVCSR : MHPMEVENT3, MHPMEVENT4, …, MHPMEVENT30, MHPMEVENT31
Registers
Offsets : 0x323, 0x324, …, 0x33e, 0x33f
Table 379.
MHPMEVENT3,
MHPMEVENT4, …,
MHPMEVENT30,
MHPMEVENT31
RegistersBits Description Type Reset
31:0 Extended performance event selector, hardwired to 0. RO 0x00000000
RVCSR : MSCRATCH Register
Offset : 0x340
Table 380.
MSCRATCH RegisterBits Description Type Reset
31:0 Scratch register for machine trap handlers.
32-bit read/write register with no specific hardware function. Software may
use this to do a fast save/restore of a core register in a trap handler.RW 0x00000000
RVCSR : MEPC Register
Offset : 0x341
Table 381. MEPC
RegisterBits Description Type Reset
31:2 Machine exception program counter.
When entering a trap, the current value of the program counter is recorded
here. When executing an mret, the processor jumps to mepc. Can also be read
and written by software.RW 0x00000000
1:0 Reserved. - -
RVCSR : MCAUSE Register
Offset : 0x342
RP2350 Datasheet
3.8. Hazard3 processor 313
Description
Machine trap cause. Set when entering a trap to indicate the reason for the trap. Readable and writable by software.
Table 382. MCAUSE
RegisterBits Description Type Reset
31 INTERRUPT : If 1, the trap was caused by an interrupt. If 0, it was caused by an
exception.RW 0x0
30:4 Reserved. - -
3:0 CODE : If interrupt  is set, code indicates the index of the bit in mip that caused
the trap (3=soft IRQ, 7=timer IRQ, 11=external IRQ). Otherwise, code is set
according to the cause of the exception.RW 0x0
Enumerated values:
0x0 → INSTR_ALIGN: Instruction fetch was misaligned. Will never fire on
RP2350, since the C extension is enabled.
0x1 → INSTR_FAULT: Instruction access fault. Instruction fetch failed a PMP
check, or encountered a downstream bus fault, and then passed the point of
no speculation.
0x2 → ILLEGAL_INSTR: Illegal instruction was executed (including illegal CSR
accesses)
0x3 → BREAKPOINT: Breakpoint. An ebreak instruction was executed when
the relevant dcsr.ebreak bit was clear.
0x4 → LOAD_ALIGN: Load address misaligned. Hazard3 requires natural
alignment of all accesses.
0x5 → LOAD_FAULT: Load access fault. A load failed a PMP check, or
encountered a downstream bus error.
0x6 → STORE_ALIGN: Store/AMO address misaligned. Hazard3 requires
natural alignment of all accesses.
0x7 → STORE_FAULT: Store/AMO access fault. A store/AMO failed a PMP
check, or encountered a downstream bus error. Also set if an AMO is
attempted on a region that does not support atomics (on RP2350, anything
but SRAM).
0x8 → U_ECALL: Environment call from U-mode.
0xb → M_ECALL: Environment call from M-mode.
RVCSR : MTVAL Register
Offset : 0x343
Table 383. MTVAL
RegisterBits Description Type Reset
31:0 Machine bad address or instruction. Hardwired to zero. RO 0x00000000
RVCSR : MIP Register
Offset : 0x344
Description
Machine interrupt pending
RP2350 Datasheet
3.8. Hazard3 processor 314
Table 384. MIP
RegisterBits Description Type Reset
31:12 Reserved. - -
11 MEIP : External interrupt pending. The processor transfers to the external
interrupt vector when mie.meie , mip.meip  and mstatus.mie  are all 1.
Hazard3 has internal registers to individually filter which external IRQs appear
in meip. When meip is 1, this indicates there is at least one external interrupt
which is asserted (hence pending in mieipa), enabled in meiea, and of priority
greater than or equal to the current preemption level in meicontext.preempt .RO 0x0
10:8 Reserved. - -
7 MTIP : Timer interrupt pending. The processor transfers to the timer interrupt
vector when mie.mtie , mip.mtip  and mstatus.mie  are all 1, unless a software or
external interrupt request is also both pending and enabled at this time.RW 0x0
6:4 Reserved. - -
3 MSIP : Software interrupt pending. The processor transfers to the software
interrupt vector when mie.msie , mip.msip  and mstatus.mie  are all 1, unless an
external interrupt request is also both pending and enabled at this time.RW 0x0
2:0 Reserved. - -
RVCSR : PMPCFG0 Register
Offset : 0x3a0
Description
Physical memory protection configuration for regions 0 through 3
Table 385. PMPCFG0
RegisterBits Description Type Reset
31 R3_L : Lock region 3, and apply it to M-mode as well as U-mode. RW 0x0
30:29 Reserved. - -
28:27 R3_A : Address matching type for region 3. Writing an unsupported value (TOR)
will set the region to OFF.RW 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
26 R3_R : Read permission for region 3. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
25 R3_W : Write permission for region 3 RW 0x0
24 R3_X : Execute permission for region 3. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
23 R2_L : Lock region 2, and apply it to M-mode as well as U-mode. RW 0x0
22:21 Reserved. - -
20:19 R2_A : Address matching type for region 2. Writing an unsupported value (TOR)
will set the region to OFF.RW 0x0
RP2350 Datasheet
3.8. Hazard3 processor 315
Bits Description Type Reset
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
18 R2_R : Read permission for region 2. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
17 R2_W : Write permission for region 2 RW 0x0
16 R2_X : Execute permission for region 2. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
15 R1_L : Lock region 1, and apply it to M-mode as well as U-mode. RW 0x0
14:13 Reserved. - -
12:11 R1_A : Address matching type for region 1. Writing an unsupported value (TOR)
will set the region to OFF.RW 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
10 R1_R : Read permission for region 1. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
9 R1_W : Write permission for region 1 RW 0x0
8 R1_X : Execute permission for region 1. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
7 R0_L : Lock region 0, and apply it to M-mode as well as U-mode. RW 0x0
6:5 Reserved. - -
4:3 R0_A : Address matching type for region 0. Writing an unsupported value (TOR)
will set the region to OFF.RW 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
2 R0_R : Read permission for region 0. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
1 R0_W : Write permission for region 0 RW 0x0
0 R0_X : Execute permission for region 0. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
RVCSR : PMPCFG1 Register
Offset : 0x3a1
RP2350 Datasheet
3.8. Hazard3 processor 316
Description
Physical memory protection configuration for regions 4 through 7
Table 386. PMPCFG1
RegisterBits Description Type Reset
31 R7_L : Lock region 7, and apply it to M-mode as well as U-mode. RW 0x0
30:29 Reserved. - -
28:27 R7_A : Address matching type for region 7. Writing an unsupported value (TOR)
will set the region to OFF.RW 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
26 R7_R : Read permission for region 7. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
25 R7_W : Write permission for region 7 RW 0x0
24 R7_X : Execute permission for region 7. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
23 R6_L : Lock region 6, and apply it to M-mode as well as U-mode. RW 0x0
22:21 Reserved. - -
20:19 R6_A : Address matching type for region 6. Writing an unsupported value (TOR)
will set the region to OFF.RW 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
18 R6_R : Read permission for region 6. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
17 R6_W : Write permission for region 6 RW 0x0
16 R6_X : Execute permission for region 6. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
15 R5_L : Lock region 5, and apply it to M-mode as well as U-mode. RW 0x0
14:13 Reserved. - -
12:11 R5_A : Address matching type for region 5. Writing an unsupported value (TOR)
will set the region to OFF.RW 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
10 R5_R : Read permission for region 5. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
9 R5_W : Write permission for region 5 RW 0x0
RP2350 Datasheet
3.8. Hazard3 processor 317
Bits Description Type Reset
8 R5_X : Execute permission for region 5. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
7 R4_L : Lock region 4, and apply it to M-mode as well as U-mode. RW 0x0
6:5 Reserved. - -
4:3 R4_A : Address matching type for region 4. Writing an unsupported value (TOR)
will set the region to OFF.RW 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
2 R4_R : Read permission for region 4. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
1 R4_W : Write permission for region 4 RW 0x0
0 R4_X : Execute permission for region 4. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RW 0x0
RVCSR : PMPCFG2 Register
Offset : 0x3a2
Description
Physical memory protection configuration for regions 8 through 11
Table 387. PMPCFG2
RegisterBits Description Type Reset
31 R11_L : Lock region 11, and apply it to M-mode as well as U-mode. RO 0x0
30:29 Reserved. - -
28:27 R11_A : Address matching type for region 11. Writing an unsupported value
(TOR) will set the region to OFF.RO 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
26 R11_R : Read permission for region 11. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x0
25 R11_W : Write permission for region 11 RO 0x0
24 R11_X : Execute permission for region 11. Note R and X are transposed from
the standard bit order due to erratum RP2350-E6.RO 0x0
23 R10_L : Lock region 10, and apply it to M-mode as well as U-mode. RO 0x0
22:21 Reserved. - -
20:19 R10_A : Address matching type for region 10. Writing an unsupported value
(TOR) will set the region to OFF.RO 0x3
Enumerated values:
RP2350 Datasheet
3.8. Hazard3 processor 318
Bits Description Type Reset
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
18 R10_R : Read permission for region 10. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x1
17 R10_W : Write permission for region 10 RO 0x1
16 R10_X : Execute permission for region 10. Note R and X are transposed from
the standard bit order due to erratum RP2350-E6.RO 0x1
15 R9_L : Lock region 9, and apply it to M-mode as well as U-mode. RO 0x0
14:13 Reserved. - -
12:11 R9_A : Address matching type for region 9. Writing an unsupported value (TOR)
will set the region to OFF.RO 0x3
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
10 R9_R : Read permission for region 9. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x1
9 R9_W : Write permission for region 9 RO 0x1
8 R9_X : Execute permission for region 9. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x1
7 R8_L : Lock region 8, and apply it to M-mode as well as U-mode. RO 0x0
6:5 Reserved. - -
4:3 R8_A : Address matching type for region 8. Writing an unsupported value (TOR)
will set the region to OFF.RO 0x3
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
2 R8_R : Read permission for region 8. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x1
1 R8_W : Write permission for region 8 RO 0x1
0 R8_X : Execute permission for region 8. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x1
RVCSR : PMPCFG3 Register
Offset : 0x3a3
Description
Physical memory protection configuration for regions 12 through 15
RP2350 Datasheet
3.8. Hazard3 processor 319
Table 388. PMPCFG3
RegisterBits Description Type Reset
31 R15_L : Lock region 15, and apply it to M-mode as well as U-mode. RO 0x0
30:29 Reserved. - -
28:27 R15_A : Address matching type for region 15. Writing an unsupported value
(TOR) will set the region to OFF.RO 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
26 R15_R : Read permission for region 15. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x0
25 R15_W : Write permission for region 15 RO 0x0
24 R15_X : Execute permission for region 15. Note R and X are transposed from
the standard bit order due to erratum RP2350-E6.RO 0x0
23 R14_L : Lock region 14, and apply it to M-mode as well as U-mode. RO 0x0
22:21 Reserved. - -
20:19 R14_A : Address matching type for region 14. Writing an unsupported value
(TOR) will set the region to OFF.RO 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
18 R14_R : Read permission for region 14. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x0
17 R14_W : Write permission for region 14 RO 0x0
16 R14_X : Execute permission for region 14. Note R and X are transposed from
the standard bit order due to erratum RP2350-E6.RO 0x0
15 R13_L : Lock region 13, and apply it to M-mode as well as U-mode. RO 0x0
14:13 Reserved. - -
12:11 R13_A : Address matching type for region 13. Writing an unsupported value
(TOR) will set the region to OFF.RO 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
10 R13_R : Read permission for region 13. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x0
9 R13_W : Write permission for region 13 RO 0x0
8 R13_X : Execute permission for region 13. Note R and X are transposed from
the standard bit order due to erratum RP2350-E6.RO 0x0
RP2350 Datasheet
3.8. Hazard3 processor 320
Bits Description Type Reset
7 R12_L : Lock region 12, and apply it to M-mode as well as U-mode. RO 0x0
6:5 Reserved. - -
4:3 R12_A : Address matching type for region 12. Writing an unsupported value
(TOR) will set the region to OFF.RO 0x0
Enumerated values:
0x0 → OFF: Disable region
0x2 → NA4: Naturally aligned 4-byte
0x3 → NAPOT: Naturally aligned power-of-two (8 bytes to 4 GiB)
2 R12_R : Read permission for region 12. Note R and X are transposed from the
standard bit order due to erratum RP2350-E6.RO 0x0
1 R12_W : Write permission for region 12 RO 0x0
0 R12_X : Execute permission for region 12. Note R and X are transposed from
the standard bit order due to erratum RP2350-E6.RO 0x0
RVCSR : PMPADDR0 Register
Offset : 0x3b0
Table 389. PMPADDR0
RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 0. Note all PMP addresses are
in units of four bytes.RW 0x00000000
RVCSR : PMPADDR1 Register
Offset : 0x3b1
Table 390. PMPADDR1
RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 1. Note all PMP addresses are
in units of four bytes.RW 0x00000000
RVCSR : PMPADDR2 Register
Offset : 0x3b2
Table 391. PMPADDR2
RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 2. Note all PMP addresses are
in units of four bytes.RW 0x00000000
RVCSR : PMPADDR3 Register
Offset : 0x3b3
Table 392. PMPADDR3
RegisterBits Description Type Reset
31:30 Reserved. - -
RP2350 Datasheet
3.8. Hazard3 processor 321
Bits Description Type Reset
29:0 Physical memory protection address for region 3. Note all PMP addresses are
in units of four bytes.RW 0x00000000
RVCSR : PMPADDR4 Register
Offset : 0x3b4
Table 393. PMPADDR4
RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 4. Note all PMP addresses are
in units of four bytes.RW 0x00000000
RVCSR : PMPADDR5 Register
Offset : 0x3b5
Table 394. PMPADDR5
RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 5. Note all PMP addresses are
in units of four bytes.RW 0x00000000
RVCSR : PMPADDR6 Register
Offset : 0x3b6
Table 395. PMPADDR6
RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 6. Note all PMP addresses are
in units of four bytes.RW 0x00000000
RVCSR : PMPADDR7 Register
Offset : 0x3b7
Table 396. PMPADDR7
RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 7. Note all PMP addresses are
in units of four bytes.RW 0x00000000
RVCSR : PMPADDR8 Register
Offset : 0x3b8
Table 397. PMPADDR8
RegisterBits Description Type Reset
31:30 Reserved. - -
RP2350 Datasheet
3.8. Hazard3 processor 322
Bits Description Type Reset
29:0 Physical memory protection address for region 8. Note all PMP addresses are
in units of four bytes.
Hardwired to the address range 0x00000000  through 0x0fffffff , which contains
the boot ROM. This range is made accessible to User mode by default. User
mode access to this range can be disabled using one of the dynamically
configurable PMP regions, or using the permission registers in ACCESSCTRL.RO 0x01ffffff
RVCSR : PMPADDR9 Register
Offset : 0x3b9
Table 398. PMPADDR9
RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 9. Note all PMP addresses are
in units of four bytes.
Hardwired to the address range 0x40000000  through 0x5fffffff , which contains
the system peripherals. This range is made accessible to User mode by
default. User mode access to this range can be disabled using one of the
dynamically configurable PMP regions, or using the permission registers in
ACCESSCTRL.RO 0x13ffffff
RVCSR : PMPADDR10 Register
Offset : 0x3ba
Table 399.
PMPADDR10 RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 10. Note all PMP addresses
are in units of four bytes.
Hardwired to the address range 0xd0000000  through 0xdfffffff , which contains
the core-local peripherals (SIO). This range is made accessible to User mode
by default. User mode access to this range can be disabled using one of the
dynamically configurable PMP regions, or using the permission registers in
ACCESSCTRL.RO 0x35ffffff
RVCSR : PMPADDR11 Register
Offset : 0x3bb
RP2350 Datasheet
3.8. Hazard3 processor 323
Table 400.
PMPADDR11 RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 11. Note all PMP addresses
are in units of four bytes.
Hardwired to all-zeroes. This region is not implemented.RO 0x00000000
RVCSR : PMPADDR12 Register
Offset : 0x3bc
Table 401.
PMPADDR12 RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 12. Note all PMP addresses
are in units of four bytes.
Hardwired to all-zeroes. This region is not implemented.RO 0x00000000
RVCSR : PMPADDR13 Register
Offset : 0x3bd
Table 402.
PMPADDR13 RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 13. Note all PMP addresses
are in units of four bytes.
Hardwired to all-zeroes. This region is not implemented.RO 0x00000000
RVCSR : PMPADDR14 Register
Offset : 0x3be
Table 403.
PMPADDR14 RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 14. Note all PMP addresses
are in units of four bytes.
Hardwired to all-zeroes. This region is not implemented.RO 0x00000000
RVCSR : PMPADDR15 Register
Offset : 0x3bf
RP2350 Datasheet
3.8. Hazard3 processor 324
Table 404.
PMPADDR15 RegisterBits Description Type Reset
31:30 Reserved. - -
29:0 Physical memory protection address for region 15. Note all PMP addresses
are in units of four bytes.
Hardwired to all-zeroes. This region is not implemented.RO 0x00000000
RVCSR : TSELECT Register
Offset : 0x7a0
Table 405. TSELECT
RegisterBits Description Type Reset
31:2 Reserved. - -
1:0 Select trigger to be configured via tdata1/tdata2
On RP2350, four instruction address triggers are implemented, so only the two
LSBs of this register are writable.RW 0x0
RVCSR : TDATA1 Register
Offset : 0x7a1
Description
Trigger configuration data 1
Hazard 3 only supports address/data match triggers (type=2) so this register description includes the mcontrol  fields for
this type.
More precisely, Hazard3 only supports exact instruction address match triggers (hardware breakpoints) so many of this
register’s fields are hardwired.
Table 406. TDATA1
RegisterBits Description Type Reset
31:28 TYPE : Trigger type. Hardwired to type=2, meaning an address/data match
triggerRO 0x2
27 DMODE : If 0, both Debug and M-mode can write the tdata registers at the
selected tselect.
If 1, only Debug Mode can write the tdata registers at the selected tselect.
Writes from other modes are ignored.
This bit is only writable from Debug ModeRW 0x0
26:21 MASKMAX : Value of 0 indicates only exact address matches are supported RO 0x00
20 HIT: Trigger hit flag. Not implemented, hardwired to 0. RO 0x0
19 SELECT : Hardwired value of 0 indicates that only address matches are
supported, not data matchesRO 0x0
18 TIMING : Hardwired value of 0 indicates that trigger fires before the triggering
instruction executes, not afterwardRO 0x0
17:16 SIZELO : Hardwired value of 0 indicates that access size matching is not
supportedRO 0x0
15:12 ACTION : Select action to be taken when the trigger fires. RW 0x0
Enumerated values:
RP2350 Datasheet
3.8. Hazard3 processor 325
Bits Description Type Reset
0x0 → EBREAK: Raise a breakpoint exception, which can be handled by the M-
mode exception handler
0x1 → DEBUG: Enter debug mode. This action is only selectable when
tdata1.dmode  is 1.
11 CHAIN : Hardwired to 0 to indicate trigger chaining is not supported. RO 0x0
10:7 MATCH : Hardwired to 0 to indicate match is always on the full address
specified by tdata2RO 0x0
6 M: When set, enable this trigger in M-mode RW 0x0
5:4 Reserved. - -
3 U: When set, enable this trigger in U-mode RW 0x0
2 EXECUTE : When set, the trigger fires on the address of an instruction that is
executed.RW 0x0
1 STORE : Hardwired to 0 to indicate store address/data triggers are not
supportedRO 0x0
0 LOAD : Hardwired to 0 to indicate load address/data triggers are not supported RO 0x0
RVCSR : TDATA2 Register
Offset : 0x7a2
Table 407. TDATA2
RegisterBits Description Type Reset
31:0 Trigger configuration data 2
Contains the address for instruction address triggers (hardware breakpoints)RW 0x00000000
RVCSR : DCSR Register
Offset : 0x7b0
Description
Debug control and status register. Access outside of Debug Mode will cause an illegal instruction exception.
Table 408. DCSR
RegisterBits Description Type Reset
31:28 XDEBUGVER : Hardwired to 4: external debug support as per RISC-V 0.13.2
debug specification.RO 0x4
27:16 Reserved. - -
15 EBREAKM : When 1, ebreak instructions executed in M-mode will break to
Debug Mode instead of trappingRW 0x0
14:13 Reserved. - -
12 EBREAKU : When 1, ebreak instructions executed in U-mode will break to Debug
Mode instead of trapping.RW 0x0
11 STEPIE : Hardwired to 0: no interrupts are taken during hardware single-
stepping.RO 0x0
10 STOPCOUNT : Hardwired to 1: mcycle/mcycleh and minstret /minstreth  do not
increment in Debug Mode.RO 0x1
RP2350 Datasheet
3.8. Hazard3 processor 326
Bits Description Type Reset
9 STOPTIME : Hardwired to 1: core-local timers don’t increment in debug mode.
External timers (e.g. hart-shared) may be configured to ignore this.RO 0x1
8:6 CAUSE : Set by hardware when entering debug mode. RO 0x0
Enumerated values:
0x1 → EBREAK: An ebreak instruction was executed when the relevant
dcsr.ebreakx  bit was set.
0x2 → TRIGGER: The trigger module caused a breakpoint exception.
0x3 → HALTREQ: Processor entered Debug Mode due to a halt request, or a
reset-halt request present when the core reset was released.
0x4 → STEP: Processor entered Debug Mode after executing one instruction
with single-stepping enabled.
5:3 Reserved. - -
2 STEP : When 1, re-enter Debug Mode after each instruction executed in M-
mode or U-mode.RW 0x0
1:0 PRV : Read the privilege mode the core was in when entering Debug Mode, and
set the privilege mode the core will execute in when returning from Debug
Mode.RW 0x3
RVCSR : DPC Register
Offset : 0x7b1
Table 409. DPC
RegisterBits Description Type Reset
31:1 Debug program counter. When entering Debug Mode, dpc samples the current
program counter, e.g. the address of an ebreak which caused Debug Mode
entry. When leaving debug mode, the processor jumps to dpc. The host may
read/write this register whilst in Debug Mode.RW 0x00000000
0 Reserved. - -
RVCSR : MCYCLE Register
Offset : 0xb00
Description
Machine-mode cycle counter, low half
Table 410. MCYCLE
RegisterBits Description Type Reset
31:0 Counts up once per cycle, when mcountinhibit.cy  is 0. Disabled by default to
save power.RW 0x00000000
RVCSR : MINSTRET Register
Offset : 0xb02
Description
Machine-mode instruction retire counter, low half
RP2350 Datasheet
3.8. Hazard3 processor 327
Table 411. MINSTRET
RegisterBits Description Type Reset
31:0 Counts up once per instruction, when mcountinhibit.ir  is 0. Disabled by default
to save power.RW 0x00000000
RVCSR : MHPMCOUNTER3, MHPMCOUNTER4, …, MHPMCOUNTER30,
MHPMCOUNTER31 Registers
Offsets : 0xb03, 0xb04, …, 0xb1e, 0xb1f
Table 412.
MHPMCOUNTER3,
MHPMCOUNTER4, …,
MHPMCOUNTER30,
MHPMCOUNTER31
RegistersBits Description Type Reset
31:0 Extended performance counter, hardwired to 0. RO 0x00000000
RVCSR : MCYCLEH Register
Offset : 0xb80
Description
Machine-mode cycle counter, high half
Table 413. MCYCLEH
RegisterBits Description Type Reset
31:0 Counts up once per 1 << 32 cycles, when mcountinhibit.cy  is 0. Disabled by
default to save power.RW 0x00000000
RVCSR : MINSTRETH Register
Offset : 0xb82
Description
Machine-mode instruction retire counter, low half
Table 414.
MINSTRETH RegisterBits Description Type Reset
31:0 Counts up once per 1 << 32 instructions, when mcountinhibit.ir  is 0. Disabled
by default to save power.RW 0x00000000
RVCSR : MHPMCOUNTER3H, MHPMCOUNTER4H, …, MHPMCOUNTER30H,
MHPMCOUNTER31H Registers
Offsets : 0xb83, 0xb84, …, 0xb9e, 0xb9f
Table 415.
MHPMCOUNTER3H,
MHPMCOUNTER4H, …,
MHPMCOUNTER30H,
MHPMCOUNTER31H
RegistersBits Description Type Reset
31:0 Extended performance counter, hardwired to 0. RO 0x00000000
RVCSR : PMPCFGM0 Register
Offset : 0xbd0
Table 416.
PMPCFGM0 RegisterBits Description Type Reset
31:16 Reserved. - -
RP2350 Datasheet
3.8. Hazard3 processor 328
Bits Description Type Reset
15:0 PMP M-mode configuration. One bit per PMP region. Setting a bit makes the
corresponding region apply to M-mode (like the pmpcfg.L  bit) but does not lock
the region.
PMP is useful for non-security-related purposes, such as stack guarding and
peripheral emulation. This extension allows M-mode to freely use any
currently unlocked regions for its own purposes, without the inconvenience of
having to lock them.
Note that this does not grant any new capabilities to M-mode, since in the
base standard it is already possible to apply unlocked regions to M-mode by
locking them. In general, PMP regions should be locked in ascending region
number order so they can’t be subsequently overridden by currently unlocked
regions.
Note also that this is not the same as the rule locking bypass bit in the ePMP
extension, which does not permit locked and unlocked M-mode regions to
coexist.
This is a Hazard3 custom CSR.RW 0x0000
RVCSR : MEIEA Register
Offset : 0xbe0
Description
External interrupt enable array.
The array contains a read-write bit for each external interrupt request: a 1 bit indicates that interrupt is currently enabled.
At reset, all external interrupts are disabled.
If enabled, an external interrupt can cause assertion of the standard RISC-V machine external interrupt pending flag
(mip.meip ), and therefore cause the processor to enter the external interrupt vector. See meipa.
There are up to 512 external interrupts. The upper half of this register contains a 16-bit window into the full 512-bit
vector. The window is indexed by the 5 LSBs of the write data.
Table 417. MEIEA
RegisterBits Description Type Reset
31:16 WINDOW : 16-bit read/write window into the external interrupt enable array RW 0x0000
15:5 Reserved. - -
4:0 INDEX : Write-only self-clearing field (no value is stored) used to control which
window of the array appears in window.WO 0x00
RVCSR : MEIPA Register
Offset : 0xbe1
Description
External interrupt pending array
Contains a read-only bit for each external interrupt request. Similarly to meiea, this register is a window into an array of
up to 512 external interrupt flags. The status appears in the upper 16 bits of the value read from meipa, and the lower 5
bits of the value written  by the same CSR instruction (or 0 if no write takes place) select a 16-bit window of the full
interrupt pending array.
A 1 bit indicates that interrupt is currently asserted. IRQs are assumed to be level-sensitive, and the relevant meipa bit is
RP2350 Datasheet
3.8. Hazard3 processor 329
cleared by servicing the requestor so that it deasserts its interrupt request.
When any interrupt of sufficient priority is both set in meipa and enabled in meiea, the standard RISC-V external interrupt
pending bit mip.meip  is asserted. In other words, meipa is filtered by meiea to generate the standard mip.meip  flag.
Table 418. MEIPA
RegisterBits Description Type Reset
31:16 WINDOW : 16-bit read-only window into the external interrupt pending array RO -
15:5 Reserved. - -
4:0 INDEX : Write-only, self-clearing field (no value is stored) used to control which
window of the array appears in window.WO 0x00
RVCSR : MEIFA Register
Offset : 0xbe2
Description
External interrupt force array
Contains a read-write bit for every interrupt request. Writing a 1 to a bit in the interrupt force array causes the
corresponding bit to become pending in meipa. Software can use this feature to manually trigger a particular interrupt.
There are no restrictions on using meifa inside of an interrupt. The more useful case here is to schedule some lower-
priority handler from within a high-priority interrupt, so that it will execute before the core returns to the foreground
code. Implementers may wish to reserve some external IRQs with their external inputs tied to 0 for this purpose.
Bits can be cleared by software, and are cleared automatically by hardware upon a read of meinext which returns the
corresponding IRQ number in meinext.irq  with mienext.noirq  clear (no matter whether meinext.update  is written).
meifa implements the same array window indexing scheme as meiea and meipa.
Table 419. MEIFA
RegisterBits Description Type Reset
31:16 WINDOW : 16-bit read/write window into the external interrupt force array RW 0x0000
15:5 Reserved. - -
4:0 INDEX : Write-only, self-clearing field (no value is stored) used to control which
window of the array appears in window.WO 0x00
RVCSR : MEIPRA Register
Offset : 0xbe3
Description
External interrupt priority array
Each interrupt has an (up to) 4-bit priority value associated with it, and each access to this register reads and/or writes a
16-bit window containing four such priority values. When less than 16 priority levels are available, the LSBs of the
priority fields are hardwired to 0.
When an interrupt’s priority is lower than the current preemption priority meicontext.preempt , it is treated as not being
pending for the purposes of mip.meip . The pending bit in meipa will still assert, but the machine external interrupt pending
bit mip.meip  will not, so the processor will ignore this interrupt. See meicontext .
Table 420. MEIPRA
RegisterBits Description Type Reset
31:16 WINDOW : 16-bit read/write window into the external interrupt priority array,
containing four 4-bit priority values.RW 0x0000
15:5 Reserved. - -
RP2350 Datasheet
3.8. Hazard3 processor 330
Bits Description Type Reset
4:0 INDEX : Write-only, self-clearing field (no value is stored) used to control which
window of the array appears in window.WO 0x00
RVCSR : MEINEXT Register
Offset : 0xbe4
Description
Get next external interrupt
Contains the index of the highest-priority external interrupt which is both asserted in meipa and enabled in meiea, left-
shifted by 2 so that it can be used to index an array of 32-bit function pointers. If there is no such interrupt, the MSB is
set.
When multiple interrupts of the same priority are both pending and enabled, the lowest-numbered wins. Interrupts with
priority less than meicontext.ppreempt  — the previous  preemption priority — are treated as though they are not pending.
This is to ensure that a preempting interrupt frame does not service interrupts which may be in progress in the frame
that was preempted.
Table 421. MEINEXT
RegisterBits Description Type Reset
31 NOIRQ : Set when there is no external interrupt which is enabled, pending, and
has priority greater than or equal to meicontext.ppreempt . Can be efficiently
tested with a bltz or bgez instruction.RO 0x0
30:11 Reserved. - -
10:2 IRQ: Index of the highest-priority active external interrupt. Zero when no
external interrupts with sufficient priority are both pending and enabled.RO 0x000
1 Reserved. - -
0 UPDATE : Writing 1 (self-clearing) causes hardware to update meicontext 
according to the IRQ number and preemption priority of the interrupt indicated
in noirq/irq. This should be done in a single atomic operation, i.e. csrrsi a0,
meinext, 0x1 .SC 0x0
RVCSR : MEICONTEXT Register
Offset : 0xbe5
Description
External interrupt context register
Configures the priority level for interrupt preemption, and helps software track which interrupt it is currently in. The latter
is useful when a common interrupt service routine handles interrupt requests from multiple instances of the same
peripheral.
A three-level stack of preemption priorities is maintained in the preempt, ppreempt  and pppreempt  fields. The priority stack is
saved when hardware enters the external interrupt vector, and restored by an mret instruction if meicontext.mreteirq  is
set.
The top entry of the priority stack, preempt, is used by hardware to ensure that only higher-priority interrupts can preempt
the current interrupt. The next entry, ppreempt , is used to avoid servicing interrupts which may already be in progress in a
frame that was preempted. The third entry, pppreempt , has no hardware effect, but ensures that preempt and ppreempt  can
be correctly saved/restored across arbitary levels of preemption.
Table 422.
MEICONTEXT Register
RP2350 Datasheet
3.8. Hazard3 processor 331
Bits Description Type Reset
31:28 PPPREEMPT : Previous ppreempt . Set to ppreempt  on priority save, set to zero on
priority restore. Has no hardware effect, but ensures that when meicontext  is
saved/restored correctly, preempt and ppreempt  stack correctly through
arbitrarily many preemption frames.RW 0x0
27:24 PPREEMPT : Previous preempt. Set to preempt on priority save, restored to to
pppreempt  on priority restore.
IRQs of lower priority than ppreempt  are not visible in meinext, so that a
preemptee is not re-taken in the preempting frame.RW 0x0
23:21 Reserved. - -
20:16 PREEMPT : Minimum interrupt priority to preempt the current interrupt.
Interrupts with lower priority than preempt do not cause the core to transfer to
an interrupt handler. Updated by hardware when when meinext.update  is written,
or when hardware enters the external interrupt vector.
If an interrupt is present in meinext when this field is updated, then preempt is
set to one level greater than that interrupt’s priority. Otherwise, ppreempt  is set
to one level greater than the maximum interrupt priority, disabling preemption.RW 0x00
15 NOIRQ : Not in interrupt (read/write). Set to 1 at reset. Set to meinext.noirq 
when meinext.update  is written. No hardware effect.RW 0x1
14:13 Reserved. - -
12:4 IRQ: Current IRQ number (read/write). Set to meinext.irq  when meinext.update  is
written. No hardware effect.RW 0x000
3 MTIESAVE : Reads as the current value of mie.mtie , if clearts is set by the same
CSR access instruction. Otherwise reads as 0. Writes are ORed into mie.mtie .RO 0x0
2 MSIESAVE : Reads as the current value of mie.msie , if clearts is set by the same
CSR access instruction. Otherwise reads as 0. Writes are ORed into mie.msie .RO 0x0
1 CLEARTS : Write-1 self-clearing field. Writing 1 will clear mie.mtie  and mie.msie ,
and present their prior values in the mtiesave  and msiesave  of this register. This
makes it safe to re-enable IRQs (via mstatus.mie ) without the possibility of
being preempted by the standard timer and soft interrupt handlers, which may
not be aware of Hazard3’s interrupt hardware.
The clear due to clearts takes precedence over the set due to mtiesave /
msiesave , although it would be unusual for software to write both on the same
cycle.SC 0x0
0 MRETEIRQ : If 1, enable restore of the preemption priority stack on mret. This
bit is set on entering the external interrupt vector, cleared by mret, and cleared
upon taking any trap other than an external interrupt.
Provided meicontext  is saved on entry to the external interrupt vector (before
enabling preemption), is restored before exiting, and the standard
software/timer IRQs are prevented from preempting (e.g. by using clearts),
this flag allows the hardware to safely manage the preemption priority stack
even when an external interrupt handler may take exceptions.RW 0x0
RVCSR : MSLEEP Register
Offset : 0xbf0
RP2350 Datasheet
3.8. Hazard3 processor 332
Description
M-mode sleep control register
Table 423. MSLEEP
RegisterBits Description Type Reset
31:3 Reserved. - -
2 SLEEPONBLOCK : Enter the deep sleep state configured by
msleep.deepsleep/msleep.powerdown on a h3.block  instruction, as well as a
standard wfi. If this bit is clear, a h3.block  is always implemented as a simple
pipeline stall.RW 0x0
1 POWERDOWN : Release the external power request when going to sleep. The
function of this is platform-defined — it may do nothing, it may do something
simple like clock-gating the fabric, or it may be tied to some complex system-
level power controller.
When waking, the processor reasserts its external power-up request, and will
not fetch any instructions until the request is acknowledged. This may add
considerable latency to the wakeup.RW 0x0
0 DEEPSLEEP : Deassert the processor clock enable when entering the sleep
state. If a clock gate is instantiated, this allows most of the processor
(everything except the power state machine and the interrupt and halt input
registers) to be clock gated whilst asleep, which may reduce the sleep current.
This adds one cycle to the wakeup latency.RW 0x0
RVCSR : DMDATA0 Register
Offset : 0xbff
Table 424. DMDATA0
RegisterBits Description Type Reset
31:0 The Debug Module’s DATA0 register is mapped into Hazard3’s CSR space so
that the Debug Module can exchange data with the core by executing CSR
access instructions (this is used to implement the Abstract Access Register
command). Only accessible in Debug Mode.RW 0x00000000
RVCSR : CYCLE Register
Offset : 0xc00
Table 425. CYCLE
RegisterBits Description Type Reset
31:0 Read-only U-mode alias of mcycle, accessible when mcounteren.cy  is set RO 0x00000000
RVCSR : INSTRET Register
Offset : 0xc02
Table 426. INSTRET
RegisterBits Description Type Reset
31:0 Read-only U-mode alias of minstret, accessible when mcounteren.ir  is set RO 0x00000000
RVCSR : CYCLEH Register
Offset : 0xc80
RP2350 Datasheet
3.8. Hazard3 processor 333
Table 427. CYCLEH
RegisterBits Description Type Reset
31:0 Read-only U-mode alias of mcycleh, accessible when mcounteren.cy  is set RO 0x00000000
RVCSR : INSTRETH Register
Offset : 0xc82
Table 428. INSTRETH
RegisterBits Description Type Reset
31:0 Read-only U-mode alias of minstreth, accessible when mcounteren.ir  is set RO 0x00000000
RVCSR : MVENDORID Register
Offset : 0xf11
Description
Vendor ID
Table 429.
MVENDORID RegisterBits Description Type Reset
31:7 BANK : Value of 9 indicates 9 continuation codes, which is JEP106 bank 10. RO 0x0000009
6:0 OFFSET : ID 0x13 in bank 10 is the JEP106 ID for Raspberry Pi Ltd, the vendor
of RP2350.RO 0x13
RVCSR : MARCHID Register
Offset : 0xf12
Table 430. MARCHID
RegisterBits Description Type Reset
31:0 Architecture ID (Hazard3) RO 0x0000001b
RVCSR : MIMPID Register
Offset : 0xf13
Table 431. MIMPID
RegisterBits Description Type Reset
31:0 Implementation ID. On RP2350 this reads as 0x86fc4e3f, which is release
v1.0-rc1 of Hazard3.RO 0x86fc4e3f
RVCSR : MHARTID Register
Offset : 0xf14
Description
Hardware thread ID
Table 432. MHARTID
RegisterBits Description Type Reset
31:0 On RP2350, core 0 has a hart ID of 0, and core 1 has a hart ID of 1. RO -
RVCSR : MCONFIGPTR Register
Offset : 0xf15
RP2350 Datasheet
3.8. Hazard3 processor 334
Table 433.
MCONFIGPTR RegisterBits Description Type Reset
31:0 Pointer to configuration data structure (hardwired to 0) RO 0x00000000
3.9. Arm/RISC-V architecture switching
RP2350 supports both Arm and RISC-V processor architectures. SDK-based programs that don’t contain assembly code
typically run unmodified on either architecture by providing the appropriate build flag.
There are two processor sockets on RP2350, referred to as core 0 and core 1 throughout this document. Each socket
can be occupied either  by a Cortex-M33 processor (implementing the Armv8-M Main architecture, plus extensions) or by
a Hazard3 processor (implementing the RV32IMAC architecture, plus extensions).
When a processor reset is removed, hardware samples the ARCHSEL  register in the OTP control register block to
determine which processor to connect to that socket. The unused processor is held in reset indefinitely, with its clock
inputs gated. The default and allowable values of the ARCHSEL  register are determined by critical OTP flags:
1.If CRIT0_ARM_DISABLE  is set, only RISC-V is allowed.
2.Else if CRIT0_RISCV_DISABLE  is set, only Arm is allowed.
3.Else if CRIT1_SECURE_BOOT_ENABLE  is set, only Arm is allowed.
4.Else if CRIT1_BOOT_ARCH  is set, both architectures are permitted, and the default is RISC-V.
5.If none of the above flags are set, both architectures are permitted, and the default is Arm.
No CRIT1 flags are set by default, so on devices where both architectures are available, the default is Arm. To change the
default architecture to RISC-V, set the CRIT1_BOOT_ARCH  flag to 1.
Enabling secure boot disables the RISC-V cores because the RP2350 bootrom does not implement secure boot for
RISC-V. This prevents a bad actor from side-stepping secure boot by switching architectures.
NOTE
As of RP2350 A3 the CRIT0_ARM_DISABLE  flag has no effect, removing a potential unlock path for debug on a secured
RP2350. Additionally, the combination of CRIT0_RISCV_DISABLE=1  and CRIT1_BOOT_ARCH=1  is decoded to an invalid state,
preventing boot.
RP2350 only samples the ARCHSEL  register when a processor is reset. Its value is ignored at all other times, so
software can program the register before a watchdog reset to implement a software-initiated switch between
architectures.
Read the ARCHSEL_STATUS  register to check the ARCHSEL value most recently sampled by each processor.
3.9.1. Automatic switching
RP2350 binaries contain a binary marker recognised by the bootrom. This marker:
•contains additional information such as the binary’s entry point and the intended architecture: Arm, RISC-V, or both
•helps detect when a flash device is connected
•helps verify that the flash device was accessed using the correct SPI parameters
When booting with core 0 in Arm architecture mode, upon detecting a bootable RISC-V binary, the bootrom
automatically resets both cores and switches them to RISC-V architecture mode. After the reset, the bootrom detects
that the binary and processor architectures match, so the binary launches normally.
Likewise, when booting with core 0 in RISC-V architecture mode, upon detecting a bootable Arm binary, the bootrom
automatically resets both cores and switches them to Arm architecture mode.
RP2350 Datasheet
3.9. Arm/RISC-V architecture switching 335
As a result, the USB bootloader, which runs on both Arm and RISC-V, can accept a UF2 image download for either
architecture, and automatically boot it using the correct processors.
3.9.2. Mixed architecture combinations
The ARCHSEL  register has one bit for each processor socket, so it is possible to request mixed combinations of Arm
and RISC-V processors: either Arm core 0 and RISC-V core 1, or RISC-V core 0 and Arm core 1.
Practical applications for this are limited, since this requires two separate program images. The two cores interoperate
normally, including shared exclusives via the global monitor: a shared variable can be safely, concurrently accessed by
an Arm processor performing ldrex, strex instructions and a RISC-V processor performing amoadd.w  instructions, for
example.
Hardware supports debugging for a mixture of Arm and RISC-V processors, though this may prove challenging on the
host software side. Debug resources for unused processors are dynamically marked as non-PRESENT in the top-level
CoreSight ROM table.
RP2350 Datasheet
3.9. Arm/RISC-V architecture switching 336
Chapter 4. Memory
RP2350 has embedded ROM, OTP and SRAM. RP2350 provides access to external flash via a QSPI interface.
4.1. ROM
A 32 kB read-only memory (ROM) appears at address 0x00000000 . The ROM contents are fixed permanently at the time
the silicon is manufactured. Chapter 5  describes the ROM contents in detail, but in summary it contains:
•Core 0 Boot code ( Section 5.2 )
•Core 1 Launch code ( Section 5.3 )
•Runtime APIs ( Section 5.4 ).
•USB bootloader
◦Mass storage interface for drag and drop of UF2 flash and SRAM binaries ( Section 5.5 )
◦PICOBOOT interface to support picotool  and advanced operations like OTP programming ( Section 5.6 )
◦Support for white-labelling all USB exposed information/identifiers ( Section 5.7 )
•UART bootloader: minimal shell to load an SRAM binary from a host microcontroller ( Section 5.8 )
The ROM offers single-cycle access, and has a dedicated AHB5 arbiter, so it can be accessed simultaneously with other
memory devices. Writing to the ROM has no effect, and no bus fault is generated on write.
The ROM is covered by IDAU regions enumerated in Section 10.2.2 . These aid in partitioning the bootrom between
Secure and Non-secure code: in particular the USB/UART bootloader runs as a Non-secure client application on Arm, to
reduce the attack surface of the secure boot implementation.
Certain ROM features are not implemented on RISC-V, most notably secure boot.
4.2. SRAM
There is a total of 520 kB (520 × 1024 bytes) of on-chip SRAM. For performance reasons, this memory is physically
partitioned into ten banks , but logically it still behaves as a single, flat 520 kB memory. RP2350 does not restrict the
data stored in each bank: you can use any bank to store processor code, data buffers, or a mixture of the two. There are
eight 16,384 × 32-bit banks (64 kB each) and two 1024 × 32-bit banks (4 kB each).
NOTE
Banking is a physical  partitioning of SRAM which improves performance by allowing multiple simultaneous
accesses. Logically , there is a single 520 kB contiguous memory.
Each SRAM bank is accessed via a dedicated AHB5 arbiter. This means different bus managers can access different
SRAM banks in parallel, so up to six 32-bit SRAM accesses can take place every system clock cycle (one per manager).
SRAM is mapped to system addresses starting at 0x20000000 . The first 256 kB address region, up to and including
0x2003ffff , is word-striped across the first four 64 kB banks. The next 256 kB address region, up to 0x2007ffff  is word-
striped across the remaining four 64 kB banks. The watermark between these two striped regions, at 0x20040000 , marks
the boundary between the SRAM0 and SRAM1 power domains.
Consecutive words in the system address space are routed to different RAM banks as shown in Table 434 . This scheme
is referred to as sequential interleaving , and improves bus parallelism for typical memory access patterns.
RP2350 Datasheet
4.1. ROM 337
Table 434. SRAM
bank0/1/2/3 striped
mapping.System address SRAM Bank SRAM word address
0x20000000 Bank 0 0
0x20000004 Bank 1 0
0x20000008 Bank 2 0
0x2000000c Bank 3 0
0x20000010 Bank 0 1
0x20000014 Bank 1 1
0x20000018 Bank 2 1
0x2000001c Bank 3 1
0x20000020 Bank 0 2
0x20000024 Bank 1 2
0x20000028 Bank 2 2
0x2000002c Bank 3 2
etc
The top two 4 kB regions (starting at 0x20080000  and 0x20081000 ) map directly to the smaller 4 kB memory banks.
Software may choose to use these for per-core purposes (e.g. stack and frequently-executed code), guaranteeing that
the processors never stall on these accesses. Like all SRAM on RP2350, these banks have single-cycle access from all
managers, (provided no other managers access the bank in the same cycle) so it is reasonable to treat memory as a
single 520 kB device.
NOTE
RP2040 had a non-striped SRAM mirror. RP2350 no longer has a non-striped mirror, to avoid mapping the same
SRAM location as both Secure and Non-secure. You can still achieve some explicit bandwidth partitioning by
allocating data across two 256 kB blocks of 4-way-striped SRAM.
4.2.1. Other on-chip memory
Besides the 520 kB main memory, there are two other dedicated RAM blocks that may be used in some circumstances:
•Cache lines can be individually pinned within the XIP address space for use as SRAM, up to the total cache size of
16 kB (see Section 4.4.1.3 ). Unpinned cache lines remain available for transparent caching of XIP accesses.
•If USB is not used, the USB data DPRAM can be used as a 4 kB memory starting at 0x50100000 .
There is also 1 kB of dedicated boot RAM, hardwired to Secure access only, whose contents and layout is defined by the
bootrom — see Chapter 5 .
RP2350 Datasheet
4.2. SRAM 338
NOTE
Memory in the peripheral address space (addresses starting with 0x4, 0x5 or 0xd) does not support code execution.
This includes USB RAM and boot RAM. These address ranges are made IDAU-Exempt to simplify assigning
peripherals to security domains using ACCESSCTRL, and consequently must be made non-executable to avoid the
possibility of Non-secure-writable, Secure-executable memory.
4.3. Boot RAM
Boot RAM is a 1 kB (256 × 32-bit) SRAM dedicated for use by the bootrom. It is slower than main SRAM, as it is
accessed over APB, taking three cycles for a read and four cycles for a write.
Boot RAM is used for myriad purposes during boot, including the initial pre-boot stack. After the bootrom enters the
user application, boot RAM contains state for the user-facing ROM APIs, such as the resident partition table used for
flash programming protection, and a copy of the flash XIP setup function (formerly known as boot2) to quickly re-
initialise flash XIP modes following serial programming operations.
Boot RAM is hardwired to permit Secure access only (Arm) or Machine-mode access only (RISC-V). It is physically
impossible to execute code from boot RAM, regardless of MPU configuration, as it is on the APB peripheral bus
segment, which is not wired to the processor instruction fetch ports.
Since boot RAM is in the XIP RAM power domain, it is always powered when the switched core domain is powered. This
simplifies SRAM power management in the bootrom, because it doesn’t have to power up any RAM before it has a place
to store the call stack.
Boot RAM supports the standard atomic set/clear/XOR accesses used by other peripherals on RP2350 ( Section 2.1.3 ).
It is possible to use boot RAM for user-defined purposes, but this is not recommended, as it may cause ROM APIs to
behave unpredictably. Calling into the ROM could modify data stored in boot RAM.
4.3.1. List of registers
A small number of registers are located on the same bus endpoint as boot RAM:
Write Once Bits
These are flags which once set, can only be cleared by a system reset. They are used in the implementation of
certain bootrom security features.
Boot Locks
These function the same as the SIO spinlocks ( Section 3.1.4 ), however they are normally reserved for bootrom
purposes ( Section 5.4.4 ).
These registers start from an offset of 0x800 above the boot RAM base address of 0x400e0000  (defined as
BOOTRAM_BASE  in the SDK).
Table 435. List of
BOOTRAM registersOffset Name Info
0x800 WRITE_ONCE0 This registers always ORs writes into its current contents. Once a
bit is set, it can only be cleared by a reset.
0x804 WRITE_ONCE1 This registers always ORs writes into its current contents. Once a
bit is set, it can only be cleared by a reset.
0x808 BOOTLOCK_STAT Bootlock status register. 1=unclaimed, 0=claimed. These locks
function identically to the SIO spinlocks, but are reserved for
bootrom use.
RP2350 Datasheet
4.3. Boot RAM 339
Offset Name Info
0x80c BOOTLOCK0 Read to claim and check. Write to unclaim. The value returned on
successful claim is 1 << n, and on failed claim is zero.
0x810 BOOTLOCK1 Read to claim and check. Write to unclaim. The value returned on
successful claim is 1 << n, and on failed claim is zero.
0x814 BOOTLOCK2 Read to claim and check. Write to unclaim. The value returned on
successful claim is 1 << n, and on failed claim is zero.
0x818 BOOTLOCK3 Read to claim and check. Write to unclaim. The value returned on
successful claim is 1 << n, and on failed claim is zero.
0x81c BOOTLOCK4 Read to claim and check. Write to unclaim. The value returned on
successful claim is 1 << n, and on failed claim is zero.
0x820 BOOTLOCK5 Read to claim and check. Write to unclaim. The value returned on
successful claim is 1 << n, and on failed claim is zero.
0x824 BOOTLOCK6 Read to claim and check. Write to unclaim. The value returned on
successful claim is 1 << n, and on failed claim is zero.
0x828 BOOTLOCK7 Read to claim and check. Write to unclaim. The value returned on
successful claim is 1 << n, and on failed claim is zero.
BOOTRAM : WRITE_ONCE0, WRITE_ONCE1 Registers
Offsets : 0x800, 0x804
Table 436.
WRITE_ONCE0,
WRITE_ONCE1
RegistersBits Description Type Reset
31:0 This registers always ORs writes into its current contents. Once a bit is set, it
can only be cleared by a reset.RW 0x00000000
BOOTRAM : BOOTLOCK_STAT Register
Offset : 0x808
Table 437.
BOOTLOCK_STAT
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 Bootlock status register. 1=unclaimed, 0=claimed. These locks function
identically to the SIO spinlocks, but are reserved for bootrom use.RW 0xff
BOOTRAM : BOOTLOCK0, BOOTLOCK1, …, BOOTLOCK6, BOOTLOCK7
Registers
Offsets : 0x80c, 0x810, …, 0x824, 0x828
Table 438.
BOOTLOCK0,
BOOTLOCK1, …,
BOOTLOCK6,
BOOTLOCK7 RegistersBits Description Type Reset
31:0 Read to claim and check. Write to unclaim. The value returned on successful
claim is 1 << n, and on failed claim is zero.RW 0x00000000
4.4. External flash and PSRAM (XIP)
RP2350 can access external flash and PSRAM via its execute-in-place  (XIP) subsystem. The term execute-in-place
refers to external memory mapped directly into the chip’s internal address space. This enables you to execute code as-
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 340
is from the external memory without explicitly copying into on-chip SRAM. For example, a processor instruction fetch
from AHB address 0x10001234  results in a QSPI memory interface fetch from address 0x001234  in an external flash device.
A 16 kB on-chip cache retains the values of recent reads and writes. This reduces the chances that XIP bus accesses
must go to external memory, improving the average throughput and latency of the XIP interface. The cache is physically
structured as two 8 kB banks, interleaving odd and even cache lines of 8-byte granularity over the two banks. This
allows processors to access multiple cache lines during the same cycle. Logically, the XIP cache behaves as a single
16 kB cache.
APB: XIP_CTRL
XIP/Cache 
Control RegistersCache Bank 0
8 kB 2-wayCache Bank 1
8 kB 2-wayStreaming FIFOAHB: XIP
(Even cache lines)AHB: XIP
(Odd cache lines)AHB: AUX
(Streaming DMA)
QSPI Memory InterfaceAHB ArbiterAPB: QMI_CTRL
Data
SD[3:0] CSn[1:0] SCKConfigurationFigure 16. Flash
execute-in-place (XIP)
subsystem. The cache
is split into two banks
for performance, but
behaves as a single
16 kB cache. XIP
accesses first query
the cache. If a cache
entry is not found, the
QMI generates an
external serial access,
adds the resulting
data to the cache, and
forwards it on to the
system bus (for reads)
or merges it with the
AHB write data (for
writes).
When booting from flash, the RP2350 bootrom ( Chapter 5 ) sets up a baseline QMI execute-in-place configuration. User
code may later reconfigure this to improve performance for a specific flash device. QSPI clock divisors can be changed
at any time, including whilst executing from XIP. Other reconfiguration requires a momentary disable of the interface.
4.4.1. XIP cache
The cache is 16 kB, two-way set-associative, 1 cycle hit. It is internal to the XIP subsystem, and only involved in
accesses to the QSPI memory interface, so software does not have to consider cache coherence unless performing
flash programming operations. It caches accesses to a 26-bit downstream XIP address space. On RP2350, the lower
half of this space is occupied by two 16 MB windows for the two QMI chip selects. RP2350 reserves the remainder for
future expansion, but you can use the space to pin cache lines outside of the QMI address space for use as cache-as-
SRAM ( Section 4.4.1.3 ). The 26-bit XIP address space is mirrored multiple times in the RP2350 address space, decoded
on bits 27:26 of the system bus address:
•0x10… : Cached XIP access
•0x14… : Uncached XIP access
•0x18… : Cache maintenance writes
•0x1c… : Uncached, untranslated XIP access — bypass QMI address translation
You can disable cache lookup separately for Secure and Non-secure accesses via the CTRL .EN_SECURE and
CTRL .EN_NONSECURE register bits. The CTRL  register contains controls to disable Secure/Non-secure access to the
uncached and uncached/untranslated XIP windows, which avoids duplicate mappings that may otherwise require
additional SAU or PMP regions.
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 341
4.4.1.1. Cache maintenance
Cache maintenance is performed on a line-by-line basis by writing into the cache maintenance mirror of the XIP address
space, starting at 0x18000000 . Cache lines are 8 bytes in size. Write data is ignored; instead, the 3 LSBs of the address
select the maintenance operation:
•0x0: Invalidate by set/way
•0x1: Clean by set/way
•0x2: Invalidate by address
•0x3: Clean by address
•0x7: Pin cache set/way at address ( Section 4.4.1.3 )
Invalidate
Marks a cache line as no longer containing data; the next access to the same address will miss the cache.
Does not write back any data to external memory. Used when external memory has been modified in a way
that the cache would not automatically know about, such as a flash programming operation.
Clean
Instructs the cache to write out any data stored in the cache as a result of a previous cached write access that
has not yet been written out to external memory. Used to make cached writes available to uncached reads.
Also used when cache contents are about to be lost, but external memory is to stay powered (for example,
when the system is about to power down).
By set/way
Selects a particular cache line to be maintained, out of the 2048 × 8-byte lines that make up the cache. Bit 13 of
the system bus address selects the cache way. Bits 12:3 of the address select a particular cache line within
that way. Mainly used to iterate exhaustively over all cache lines (for example, during a full cache flush).
By address
Looks up an address in the cache, then performs the requested maintenance if that line is currently allocated
in the cache. Used when only a particular range of XIP addresses needs to be maintained, for example, a flash
page that was just programmed. Usually faster than a full flush, because the real cost of a cache flush is not in
the maintenance operations, but the large number of subsequent cache misses.
Pin
Prevents a particular cache line from being evicted. Used to mark important external memory contents that
must get guaranteed cache hits, or to allocate cache lines for use as cache-as-SRAM. If a cached access to
some other address misses the cache and attempts to evict a pinned cache line, the eviction fails, and the
access is downgraded to an uncached access.
Cache maintenance operations operate on the cache’s tag memory . This is the cache’s metadata store, which tracks
the state of each cache line. Maintenance operations do not affect the cache’s data memory , which contains the
cache’s copy of data bytes from external memory.
By default, cache maintenance is Secure-only. Non-secure writes to the cache maintenance address window have no
effect and return a bus error. Non-secure cache maintenance can be enabled by setting the CTRL .MAINT_NONSEC
register bit, but this is not recommended if Secure software may perform cached XIP accesses.
4.4.1.2. Cache line states
The changes to a cache line caused by cached accesses and maintenance operations can be summarised by a set of
state transitions.
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 342
Invalid
Pinned DirtyCleanInv, Evict
Inv, Clean R
R
R, W, Clean, Pin R, WCleanWW
InvPin
Inv, EvictPin
PinFigure 17. State
transition diagram for
each cache line. Inv,
Clean and Pin
represent
invalidate/clean/pin
maintenance
operations,
respectively. R and W
represent cached
reads and writes. Evict
represents a cache
line deallocation to
make room for a new
allocation due to a
read/write cache
miss.
Initially, the state of all cache lines is undefined. When booting from flash, the bootrom performs an invalidate by
set/way on every line of the cache to force them to a known state. In the diagram above, all states have an Inv arc to the
invalid state.
A dirty  cache line contains data not yet propagated to downstream memory.
A clean  cache line contains data that matches the downstream memory contents.
Accessing an invalid cache line causes an allocation : the cache fetches the corresponding data from downstream
memory, stores it in the cache, then marks the cache line as clean or dirty. The cache also stores part of the
downstream address, known as the tag, to recall the downstream address stored in each cache line. Read allocations
enter the clean state, so the cache line can be safely freed at any time. Write allocations enter the dirty state, so the
cache line must propagate downstream before it can be freed.
Writing to a clean cache line marks it as dirty because the cache now contains write data that has not propagated
downstream. The line can be explicitly returned to the clean state using a clean maintenance operation ( 0x1 or 0x3), but
this is not required. Typically, the cache automatically propagates dirty cache lines downstream when it needs to
reallocate them.
Evictions happen when a cached read or write needs to allocate a cache line that is already in the clean or dirty state.
The eviction transitions the line momentarily to the invalid state, ready for allocation. For clean cache lines, this happens
instantaneously. For dirty cache lines, the cache must first propagate the cache line contents downstream before it can
safely enter the invalid state.
Cache lines enter the pinned state using a pin maintenance operation ( 0x7) and exit only by an invalidate maintenance
operation ( 0x0 or 0x2).
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 343
NOTE
The pin maintenance operation only marks the line as pinned; it does not perform any copying of data. When pinning
lines that exist in external memory devices, you must first pin the line, then copy the downstream data into the
pinned line by reading from the uncached XIP window.
4.4.1.3. Cache-as-SRAM
When you disabled the cache of RP2040, the cache would map the entire cache memory at 0x15000000 . RP2350 replaces
this with the ability to pin individual cache lines. You can use this in the following ways:
•Pin the entire cache at some address range to use the entire cache as SRAM
•Pin one full cache way to make half of the cache available for cache-as-SRAM use (the remaining cache way still
functions as usual)
•Pin an address range that that maps critical flash contents
NOTE
Pinned cache lines are not accessible when the cache is disabled via the CTRL  register ( CTRL .EN_SECURE or
CTRL .EN_NONSECURE depending on security level of the bus access).
Because the QMI only occupies the lower half of the 64 MB XIP address space, you can pin cache lines outside of the
QMI address range (e.g. at the top of the XIP space) to avoid interfering with any QMI accesses. As a general rule, the
more cache you pin, the lower the cache hit rate for other accesses.
Cache lines are pinned using the pin maintenance operation ( 0x7), which performs the following steps:
1.An implicit invalidate-by-address operation ( 0x2) using the full address of the maintenance operation
◦This ensures that each address is allocated in only one cache way (required for correct cache operation)
2.Select the cache line to be pinned, using bit 13 to select the cache way, and bits 12:3 to select the cache set (as
with 0x0/0x1 invalidate/clean by set/way commands)
3.Write the address to the cache line’s tag entry
4.Change the cache line’s state to pinned (as per the state diagram in Section 4.4.1.2 )
5.Update the cache line’s tag with the full address of the maintenance operation
After a pin operation, cached reads and writes to the specified address always hit the cache until that cache line is
either invalidated or pinned to a different address.
NOTE
Pinning two addresses that are equal modulo cache size pins the same cache line twice. It does not pin two different
cache lines. The second pin will overwrite the first.
When a cached access hits a pinned cache line, it behaves the same as a dirty line. The cache reads and writes as if
allocated in the cache by normal means.
Cache eviction policy is random, and the cache only makes one attempt to select an eviction way. If the cache selects
to evict a pinned line, the eviction fails, and the access is demoted to an uncached access. As a result, a cache with one
way pinned does not behave exactly the same as a direct-mapped 8 kB cache, but average-case performance is similar.
Cache line states are stored in the cache tag memory stored in the XIP memory power domain. This memory contents
do not change on reset, so pinned lines remain pinned across resets. If the XIP memory power domain is not powered
down, memory contents do not change across power cycles of the switched core reset domain. The bootrom clears the
tag memory upon entering the flash boot or NSBOOT (USB boot) path, but watchdog scratch vector reboots can boot
directly into pinned XIP cache lines.
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 344
4.4.2. QSPI Memory Interface (QMI)
Uncached accesses and cache misses require access to external memory. The QSPI memory interface (QMI) provides
this access, as documented in Section 12.14 . The QMI supports:
•Up to two external QSPI devices, with separate chip selects and shared clock/data pins
◦Banked configuration registers, including different SCK frequencies and QSPI opcodes
•Memory-mapped reads and writes (writes must be enabled via CTRL .WRITABLE_M0/ CTRL .WRITABLE_M1)
•Serial/dual/quad-SPI transfer formats
•SCK speeds as high as clk_sys
•8/16/32-bit accesses for uncached accesses, and 64-bit accesses for cache line fills
•Automatic chaining of sequentially addressed accesses into a single QSPI transfer
•Address translation (4 × 4 MB windows per QSPI device)
◦Flash storage addresses can differ from runtime addresses, e.g. for multiple OTA upgrade image slots
◦Allows code and data segments, or Secure and Non-secure images, to be mapped separately
•Direct-mode FIFO interface for programming and configuring external QSPI devices
XIP accesses via the two cache AHB ports, and from the DMA streaming hardware, arbitrate for access to the QMI. A
separate APB port configures the QMI.
The QMI is a new memory interface designed for RP2350, replacing the SSI peripheral on RP2040.
4.4.3. Streaming DMA interface
As the flash is generally much larger than on-chip SRAM, it’s often useful to stream chunks of data into memory from
flash. It’s convenient to have the DMA stream this data in the background while software in the foreground does other
things. It’s even more convenient if code can continue to execute from flash whilst this takes place.
This doesn’t interact well with standard XIP operation because QMI serial transfers force lengthy bus stalls on the DMA.
These stalls are tolerable for a processor because an in-order processor tends to have nothing better to do while
waiting for an instruction fetch to retire, and because typical code execution tends to have much higher cache hit rates
than bulk streaming of infrequently accessed data. In contrast, stalling the DMA prevents any other active DMA
channels from making progress during this time, slowing overall DMA throughput.
The STREAM_ADDR  and STREAM_CTR  registers are used to program a linear sequence of flash reads. The XIP
subsystem performs these reads in the background in a best-effort fashion. To minimise impact on code executed from
flash whilst the stream is ongoing, the streaming hardware has lower priority access to the QMI than regular XIP
accesses, and there is a brief cooldown (9 cycles) between the last XIP cache miss and resuming streaming. This
avoids increases in initial access latency on XIP cache misses.
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/flash/xip_stream/flash_xip_stream.c  Lines 45 - 48
45     while (!(xip_ctrl_hw ->stat & XIP_STAT_FIFO_EMPTY ))
46         (void) xip_ctrl_hw ->stream_fifo ;
47     xip_ctrl_hw ->stream_addr  = (uint32_t ) &random_test_data [0];
48     xip_ctrl_hw ->stream_ctr  = count_of (random_test_data );
The streamed data is pushed to a small FIFO, which generates DREQ signals that tell the DMA to collect the streamed
data. As the DMA does not initiate a read until after  reading the data from flash, the DMA does not stall when accessing
the data. The DMA can then retrieve this data through the auxiliary AHB port, which provides direct single-cycle access
to the streaming data FIFO.
On RP2350, you can also use the auxiliary AHB port to access the QMI direct-mode FIFOs. This is faster than accessing
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 345
the FIFOs through the QMI APB configuration port. When QMI access chaining is enabled, the streaming XIP DMA is
close to the maximum theoretical QSPI throughput, but the direct-mode FIFOs are available on AHB for situations that
require 100% of the theoretical throughput.
Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/flash/xip_stream/flash_xip_stream.c  Lines 58 - 70
58     const uint dma_chan  = 0;
59     dma_channel_config  cfg = dma_channel_get_default_config (dma_chan );
60     channel_config_set_read_increment (&cfg, false);
61     channel_config_set_write_increment (&cfg, true);
62     channel_config_set_dreq (&cfg, DREQ_XIP_STREAM );
63     dma_channel_configure (
64             dma_chan ,
65             &cfg,
66             (void *) buf,                 // Write addr
67             (const void *) XIP_AUX_BASE ,  // Read addr
68             count_of (random_test_data ), // Transfer count
69             true                        // Start immediately!
70     );
4.4.4. Performance counters
The XIP subsystem provides two performance counters. These are 32 bits in size, saturate upon reaching 0xffffffff ,
and are cleared by writing any value. They count:
1.The total number of XIP accesses, to any alias
2.The number of XIP accesses that resulted in a cache hit
This provides a way to profile the cache hit rate for common use cases.
4.4.5. List of XIP_CTRL registers
The XIP control registers start at a base address of 0x400c8000  (defined as XIP_CTRL_BASE  in SDK).
Table 439. List of XIP
registersOffset Name Info
0x00 CTRL Cache control register. Read-only from a Non-secure context.
0x08 STAT
0x0c CTR_HIT Cache Hit counter
0x10 CTR_ACC Cache Access counter
0x14 STREAM_ADDR FIFO stream address
0x18 STREAM_CTR FIFO stream control
0x1c STREAM_FIFO FIFO stream data
XIP: CTRL Register
Offset : 0x00
Description
Cache control register. Read-only from a Non-secure context.
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 346
Table 440. CTRL
RegisterBits Description Type Reset
31:12 Reserved. - -
11 WRITABLE_M1 : If 1, enable writes to XIP memory window 1 (addresses
0x11000000 through 0x11ffffff, and their uncached mirrors). If 0, this region is
read-only.
XIP memory is read-only by default . This bit must be set to enable writes if a
RAM device is attached on QSPI chip select 1.
The default read-only behaviour avoids two issues with writing to a read-only
QSPI device (e.g. flash). First, a write will initially appear to succeed due to
caching, but the data will eventually be lost when the written line is evicted,
causing unpredictable behaviour.
Second, when a written line is evicted, it will cause a write command to be
issued to the flash, which can break the flash out of its continuous read mode.
After this point, flash reads will return garbage. This is a security concern, as it
allows Non-secure software to break Secure flash reads if it has permission to
write to any flash address.
Note the read-only behaviour is implemented by downgrading writes to reads,
so writes will still cause allocation of an address, but have no other effect.RW 0x0
10 WRITABLE_M0 : If 1, enable writes to XIP memory window 0 (addresses
0x10000000 through 0x10ffffff, and their uncached mirrors). If 0, this region is
read-only.
XIP memory is read-only by default . This bit must be set to enable writes if a
RAM device is attached on QSPI chip select 0.
The default read-only behaviour avoids two issues with writing to a read-only
QSPI device (e.g. flash). First, a write will initially appear to succeed due to
caching, but the data will eventually be lost when the written line is evicted,
causing unpredictable behaviour.
Second, when a written line is evicted, it will cause a write command to be
issued to the flash, which can break the flash out of its continuous read mode.
After this point, flash reads will return garbage. This is a security concern, as it
allows Non-secure software to break Secure flash reads if it has permission to
write to any flash address.
Note the read-only behaviour is implemented by downgrading writes to reads,
so writes will still cause allocation of an address, but have no other effect.RW 0x0
9 SPLIT_WAYS : When 1, route all cached+Secure accesses to way 0 of the
cache, and route all cached+Non-secure accesses to way 1 of the cache.
This partitions the cache into two half-sized direct-mapped regions, such that
Non-secure code can not observe cache line state changes caused by Secure
execution.
A full cache flush is required when changing the value of SPLIT_WAYS. The
flush should be performed whilst SPLIT_WAYS is 0, so that both cache ways
are accessible for invalidation.RW 0x0
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 347
Bits Description Type Reset
8 MAINT_NONSEC : When 0, Non-secure accesses to the cache maintenance
address window (addr[27] == 1, addr[26] == 0) will generate a bus error. When
1, Non-secure accesses can perform cache maintenance operations by writing
to the cache maintenance address window.
Cache maintenance operations may be used to corrupt Secure data by
invalidating cache lines inappropriately, or map Secure content into a Non-
secure region by pinning cache lines. Therefore this bit should generally be set
to 0, unless Secure code is not using the cache.
Care should also be taken to clear the cache data memory and tag memory
before granting maintenance operations to Non-secure code.RW 0x0
7 NO_UNTRANSLATED_NONSEC : When 1, Non-secure accesses to the
uncached, untranslated window (addr[27:26] == 3) will generate a bus error.RW 0x1
6 NO_UNTRANSLATED_SEC : When 1, Secure accesses to the uncached,
untranslated window (addr[27:26] == 3) will generate a bus error.RW 0x0
5 NO_UNCACHED_NONSEC : When 1, Non-secure accesses to the uncached
window (addr[27:26] == 1) will generate a bus error. This may reduce the
number of SAU/MPU/PMP regions required to protect flash contents.
Note this does not disable access to the uncached, untranslated
window — see NO_UNTRANSLATED_SEC.RW 0x0
4 NO_UNCACHED_SEC : When 1, Secure accesses to the uncached window
(addr[27:26] == 1) will generate a bus error. This may reduce the number of
SAU/MPU/PMP regions required to protect flash contents.
Note this does not disable access to the uncached, untranslated
window — see NO_UNTRANSLATED_SEC.RW 0x0
3 POWER_DOWN : When 1, the cache memories are powered down. They retain
state, but can not be accessed. This reduces static power dissipation. Writing
1 to this bit forces CTRL_EN_SECURE and CTRL_EN_NONSECURE to 0, i.e. the
cache cannot be enabled when powered down.RW 0x0
2 Reserved. - -
1 EN_NONSECURE : When 1, enable the cache for Non-secure accesses. When
enabled, Non-secure XIP accesses to the cached (addr[26] == 0) window will
query the cache, and QSPI accesses are performed only if the requested data
is not present. When disabled, Secure access ignore the cache contents, and
always access the QSPI interface.
Accesses to the uncached (addr[26] == 1) window will never query the cache,
irrespective of this bit.RW 0x1
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 348
Bits Description Type Reset
0 EN_SECURE : When 1, enable the cache for Secure accesses. When enabled,
Secure XIP accesses to the cached (addr[26] == 0) window will query the
cache, and QSPI accesses are performed only if the requested data is not
present. When disabled, Secure access ignore the cache contents, and always
access the QSPI interface.
Accesses to the uncached (addr[26] == 1) window will never query the cache,
irrespective of this bit.
There is no cache-as-SRAM address window. Cache lines are allocated for
SRAM-like use by individually pinning them, and keeping the cache enabled.RW 0x1
XIP: STAT Register
Offset : 0x08
Table 441. STAT
RegisterBits Description Type Reset
31:3 Reserved. - -
2 FIFO_FULL : When 1, indicates the XIP streaming FIFO is completely full.
The streaming FIFO is 2 entries deep, so the full and empty
flag allow its level to be ascertained.RO 0x0
1 FIFO_EMPTY : When 1, indicates the XIP streaming FIFO is completely empty. RO 0x1
0 Reserved. - -
XIP: CTR_HIT Register
Offset : 0x0c
Description
Cache Hit counter
Table 442. CTR_HIT
RegisterBits Description Type Reset
31:0 A 32 bit saturating counter that increments upon each cache hit,
i.e. when an XIP access is serviced directly from cached data.
Write any value to clear.WC 0x00000000
XIP: CTR_ACC Register
Offset : 0x10
Description
Cache Access counter
Table 443. CTR_ACC
RegisterBits Description Type Reset
31:0 A 32 bit saturating counter that increments upon each XIP access,
whether the cache is hit or not. This includes noncacheable accesses.
Write any value to clear.WC 0x00000000
XIP: STREAM_ADDR Register
Offset : 0x14
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 349
Description
FIFO stream address
Table 444.
STREAM_ADDR
RegisterBits Description Type Reset
31:2 The address of the next word to be streamed from flash to the streaming
FIFO.
Increments automatically after each flash access.
Write the initial access address here before starting a streaming read.RW 0x00000000
1:0 Reserved. - -
XIP: STREAM_CTR Register
Offset : 0x18
Description
FIFO stream control
Table 445.
STREAM_CTR RegisterBits Description Type Reset
31:22 Reserved. - -
21:0 Write a nonzero value to start a streaming read. This will then
progress in the background, using flash idle cycles to transfer
a linear data block from flash to the streaming FIFO.
Decrements automatically (1 at a time) as the stream
progresses, and halts on reaching 0.
Write 0 to halt an in-progress stream, and discard any in-flight
read, so that a new stream can immediately be started (after
draining the FIFO and reinitialising STREAM_ADDR)RW 0x000000
XIP: STREAM_FIFO Register
Offset : 0x1c
Description
FIFO stream data
Table 446.
STREAM_FIFO
RegisterBits Description Type Reset
31:0 Streamed data is buffered here, for retrieval by the system DMA.
This FIFO can also be accessed via the XIP_AUX slave, to avoid exposing
the DMA to bus stalls caused by other XIP traffic.RF 0x00000000
4.4.6. List of XIP_AUX registers
The XIP_AUX port provides fast AHB access to the streaming FIFO and the QMI Direct Mode FIFOs, to reduce the cost of
DMA access to these FIFOs.
Table 447. List of
XIP_AUX registersOffset Name Info
0x0 STREAM Read the XIP stream FIFO (fast bus access to
XIP_CTRL_STREAM_FIFO)
0x4 QMI_DIRECT_TX Write to the QMI direct-mode TX FIFO (fast bus access to
QMI_DIRECT_TX)
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 350
Offset Name Info
0x8 QMI_DIRECT_RX Read from the QMI direct-mode RX FIFO (fast bus access to
QMI_DIRECT_RX)
XIP_AUX : STREAM Register
Offset : 0x0
Table 448. STREAM
RegisterBits Description Type Reset
31:0 Read the XIP stream FIFO (fast bus access to XIP_CTRL_STREAM_FIFO) RF 0x00000000
XIP_AUX : QMI_DIRECT_TX Register
Offset : 0x4
Description
Write to the QMI direct-mode TX FIFO (fast bus access to QMI_DIRECT_TX)
Table 449.
QMI_DIRECT_TX
RegisterBits Description Type Reset
31:21 Reserved. - -
20 NOPUSH : Inhibit the RX FIFO push that would correspond to this TX FIFO
entry.
Useful to avoid garbage appearing in the RX FIFO when pushing the command
at the beginning of a SPI transfer.WF 0x0
19 OE: Output enable (active-high). For single width (SPI), this field is ignored, and
SD0 is always set to output, with SD1 always set to input.
For dual and quad width (DSPI/QSPI), this sets whether the relevant SDx pads
are set to output whilst transferring this FIFO record. In this case the
command/address should have OE set, and the data transfer should have OE
set or clear depending on the direction of the transfer.WF 0x0
18 DWIDTH : Data width. If 0, hardware will transmit the 8 LSBs of the DIRECT_TX
DATA field, and return an 8-bit value in the 8 LSBs of DIRECT_RX. If 1, the full
16-bit width is used. 8-bit and 16-bit transfers can be mixed freely.WF 0x0
17:16 IWIDTH : Configure whether this FIFO record is transferred with
single/dual/quad interface width (0/1/2). Different widths can be mixed freely.WF 0x0
Enumerated values:
0x0 → S: Single width
0x1 → D: Dual width
0x2 → Q: Quad width
15:0 DATA : Data pushed here will be clocked out falling edges of SCK (or before
the very first rising edge of SCK, if this is the first pulse). For each byte clocked
out, the interface will simultaneously sample one byte, on rising edges of SCK,
and push this to the DIRECT_RX FIFO.
For 16-bit data, the least-significant byte is transmitted first.WF 0x0000
XIP_AUX : QMI_DIRECT_RX Register
Offset : 0x8
RP2350 Datasheet
4.4. External flash and PSRAM (XIP) 351
Description
Read from the QMI direct-mode RX FIFO (fast bus access to QMI_DIRECT_RX)
Table 450.
QMI_DIRECT_RX
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 With each byte clocked out on the serial interface, one byte will simultaneously
be clocked in, and will appear in this FIFO. The serial interface will stall when
this FIFO is full, to avoid dropping data.
When 16-bit data is pushed into the TX FIFO, the corresponding RX FIFO push
will also contain 16 bits of data. The least-significant byte is the first one
received.RF 0x0000
4.5. OTP
RP2350 contains 8 kB of one-time-programmable storage (OTP), which stores:
•Manufacturing information such as unique device ID
•Boot configuration such as non-default crystal oscillator frequency
•Public key fingerprint(s) for boot signature enforcement
•Symmetric keys for decryption of external flash contents into SRAM
•User-defined contents, including bootable program images ( Section 5.10.7 )
The OTP storage is structured as 4096 × 24-bit rows. Each row contains 16 bits of data and 8 bits of parity information,
providing 8 kB of data storage. OTP bit cells are initially 0 and can be programmed to 1. However, they cannot be cleared
back to 0 under any circumstance. This ensures that security-critical flags, such as debug disables, are physically
impossible to clear once set. However, you must also take care to program the correct values.
For more information about the OTP subsystem, see Chapter 13 .
RP2350 Datasheet
4.5. OTP 352
Chapter 5. Bootrom
Each RP2350 device contains 32 kB of mask ROM: a physically immutable memory resource described in Section 4.1 .
The RP2350 bootrom is the binary image etched into this ROM that contains the first instructions executed at reset.
The bootrom concepts section ( Section 5.1 ) covers the following topics, which are necessary background for
understanding the bootrom features and their implementation:
•Partition tables  and their associated flash permissions
•Bootable images,  and the block loops  that store their metadata
•Versioning  for images and partition tables, and A/B versions  to support double-buffered upgrades
•Hashing and signing  to support secure boot with public key fingerprint in OTP (see also Section 10.1.1  in the
security chapter)
•Load maps  for bootable images, and packaged binaries  that the bootrom loads from flash into RAM according to
the image’s load map
•Anti-rollback protection  to revoke older, compromised versions of software
•Three forms of flash boot:
◦Flash image boot , with a single binary image written directly into flash
◦Flash partition boot , with the boot image selected from the partition table
◦Partition-table-in-image boot , where the boot image is not contained in a partition table, but still embeds a
partition table data structure to divide the flash address space
•Boot slots  for A/B versions of partition tables
•Flash update boot , a special one-time boot mode that enables version downgrades following an image download
•Try before you buy  support for phased upgrades with image self-test
•Address translation  for flash images, which provides a consistent runtime address to images regardless of
physical storage location
•Automatic architecture switch  when attempting to run a RISC-V binary on Arm, or vice versa
•Targeting UF2 downloads  to different flash partitions based on their permissions and the UF2 family ID
Besides features mentioned as concepts above, the RP2350 bootrom implements:
•The core 0 initial boot sequence ( Section 5.2 )
•The core 1 low-power wait and launch protocol ( Section 5.3 )
•Runtime APIs ( Section 5.4 ) exported through the ROM symbol table, such as flash and OTP programming
•A subset of runtime APIs available to Non-secure code, with permission for each API entry point individually
configured by Secure code
•A USB MSC class-compliant bootloader with UF2 support for downloading code/data to flash or RAM ( Section 5.5 ),
including support for versioning and A/B partitions
•The USB PICOBOOT interface for advanced operations like OTP programming ( Section 5.6 ) and to support picotool
or other host side tools
•Support for white-labelling all USB exposed information/identifiers ( Section 5.7 )
•A UART bootloader providing a minimal shell to load an SRAM binary from a host microcontroller ( Section 5.8 )
You should read the bootrom concepts section before diving into the features in the list above. RP2350 adds a
considerable amount of new functionality compared to the RP2040 bootrom. If you are in a terrible hurry, Section 5.9.5 
covers the absolute minimum requirements for a binary to be bootable on RP2350 when secure boot is not enabled.
RP2350 Datasheet
Chapter 5. Bootrom 353
Bootrom source code
All source files for the RP2350 bootrom are available under the terms of the 3-clause BSD licence:
github.com/raspberrypi/pico-bootrom-rp2350
5.1. Bootrom concepts
Bold type in the following sections introduces a concept . This chapter frequently refers back to these concepts.
5.1.1. Secure and Non-secure
This datasheet uses the (capitalised) terms Secure  and Non-secure  to refer to the Arm execution states of the same
name, defined in the Armv8-M Architecture Reference Manual . The uncapitalised term "secure" has no special meaning.
In some contexts, Secure can also refer to a RISC-V core, usually one running at the Machine privilege level. For
example, the low-level flash APIs are exported to Arm Secure code and RISC-V code only, so Secure serves as a
shorthand for this type of API.
A secured RP2350  is a device where secure boot is enabled ( Section 5.10.1 ). This is not the same as the Secure state,
since the device may run a mixture of Secure and Non-secure code after completing the secure boot process.
5.1.2. Partition tables
A partition table  divides flash into a maximum of 16 distinct regions, known as partitions . Each partition defines
attributes such as flash permissions  for a contiguous range of flash addresses. The PARTITION_TABLE  data structure
describes a partition table, and is an example of a block . Use of partition tables is strictly optional.
Dividing flash into multiple partitions enables you to:
•Store more than one executable image on the device. For example:
◦For A/B boot versions ( Section 5.1.7 )
◦For different architectures (Arm/RISC-V) or Secure/Non-secure
◦For use with a custom bootloader
•Provision space for data. For example:
◦Embedded file systems
◦Shared Wi-Fi firmware
◦Application resources
•Provide different security attributes for different regions of flash ( Section 5.1.3 )
•Target UF2 downloads to different partitions based on family ID ( Section 5.1.18 ), including custom-defined UF2
families specific to your platform
For more information about PARTITION_TABLE  discovery during flash boot, see Section 5.1.5.2 .
Partition tables can be versioned  to support A/B upgrades. They can also be hashed and signed  for security and
integrity purposes. We recommend hashing partition tables to ensure that they haven’t been corrupted. This is
especially important when using boot slots  to update your partition table, since a corrupted partition table with a higher
version could be chosen over a non-corrupted partition table with a lower version.
RP2350 Datasheet
5.1. Bootrom concepts 354
5.1.2.1. Partition attributes
Each partition specifies partition attributes  for the flash addresses it encompasses, including:
•Start/end offsets within the logical 32 MB address space of the two flash windows; these offsets are specified in
multiples of a flash sector (4 kB)
◦Bootable partitions must reside wholly in the first 16 MB flash window, due to limitations of the address
translation  hardware
•Access permissions for the partition: read/write for each of Secure ( S), Non-secure ( NS) and bootloader ( BL) access
•Information on which UF2 family IDs may be dropped into the partition via the UF2 bootloader
•An optional 64-bit identifier
•An optional name (a string for human-readable identification)
•Whether to ignore the partition during Arm or RISC-V boot
•Information to group partitions together (see Section 5.1.7  and Section 5.1.18 )
Section 5.9.4  documents the full list of partition attributes, along with the PARTITION_TABLE  binary format.
If there is no partition table, the entirety of flash is considered a single region, with no restricted permissions. Without a
partition table, there is no support for custom UF2 family IDs, therefore you must use one of the standard IDs specified
in Table 455 .
5.1.3. Flash permissions
One of the roles of the partition tables introduced in Section 5.1.2  is to define flash permissions , or simply permissions.
The partition table stores one set of permission flags for each partition: all bytes covered by a single partition have the
same permissions. The partition table separately defines permissions for unpartitioned space : flash addresses which
do not match any of partitions defined in the partition table.
Separate read/write permissions are specified for each of Secure ( S), Non-secure ( NS) and bootloader ( BL) access.
Bootloader permissions control where UF2s can be written to, and what can be accessed via picotool  when the device is
in BOOTSEL mode.
Because flash permissions may be changed dynamically at runtime, part of the partition table is resident in RAM at
runtime. You can modify this table to add permissions for other areas of flash at runtime, without changing the partition
table stored in flash itself. There is no bootrom API for this, however the in-memory partition table format is
documented, and a pointer is available in the ROM table. The SDK provides APIs to wrap this functionality.
5.1.4. Image definitions
An image  is a contiguous data blob which may contain code, or data, or a mixture. An image definition  is a block of
metadata embedded near the start of an image. The metadata stored in the image definition allows the bootrom to
recognise valid executable and non-executable images. The IMAGE_DEF  data structure represents the image definition in a
binary format, and is an example of a block .
For executable images, the IMAGE_DEF  could be considered similar to an ELF header, as it can include image attributes
such as architecture/chip, entry-point, load addresses, etc.
All IMAGE_DEF s can contain version information and be hashed or signed. Whilst the bootrom only directly boots
executable images, it does provide facilities for selecting a valid (possibly signed) data image from one or more
partitions on behalf of a user application.
The presence of a valid IMAGE_DEF  allows the bootrom to discern a valid application in flash from random data. As a
result, you must include a valid IMAGE_DEF  in any executable binary that you intend to boot.
For more information about how the bootrom discovers IMAGE_DEF s, see the section on block loops .
RP2350 Datasheet
5.1. Bootrom concepts 355
For details about the IMAGE_DEF  format itself, see Section 5.9.3 .
For a description of the minimum requirements for a bootable image, see Section 5.9.5 .
5.1.5. Blocks and block loops
5.1.5.1. Blocks
IMAGE_DEF s and PARTITION_TABLE s are both examples of blocks . A block is a recognisable, self-checking data structure
containing one or more distinct data items . The type of the first item in a block defines the type of that entire block.
Blocks are backwards and forwards compatible; item types will not be changed in the future in ways that could cause
existing code to misinterpret data. Consumers of blocks (including the bootrom) must skip items within the block
whose types are currently listed as reserved; encountering reserved item types must not cause a block to fail validation.
To be considered valid , a block must have the following properties:
•it must begin with the 4 byte magic header, PICOBIN_BLOCK_MARKER_START  (0xffffded3 )
•the end of each (variably-sized) item must also be the start of another valid item
•the last item must have type PICOBIN_BLOCK_ITEM_2BS_LAST  and specify the correct full length of the block
•it must end with the 4 byte magic footer, PICOBIN_BLOCK_MARKER_END  (0xab123579 )
The magic header and footer values are chosen to be unlikely to appear in executable Arm and RISC-V code. For more
information about the block format, see Section 5.9.1 .
Given a region of memory or flash (such as a partition), blocks are found by searching the first 4 kB of that given region
(for flash boot) or the entire region (for RAM/OTP image boots) for a valid block which is part of a valid block loop .
Currently IMAGE_DEF s and PARTITION_TABLE s are the only types of block used by the RP2350 bootrom, but the block format
reserves encoding space for future expansion.
5.1.5.2. Block loops
A block loop  is a cyclic linked list of blocks (a linked loop). Each block has a relative pointer to the next block, and the
last block must link to the first. A single block can form a block loop by linking back to itself with a relative pointer of 0.
The first block in a loop must have the lowest address of all blocks in the loop.
The purpose of a block loop is threefold:
•to discover which blocks belong to the same image without a brute-force search
•to allow metadata to be appended in post-link processing steps
•to detect parts of the binary being overwritten in a way that breaks the loop
For flash image boot  the bootrom searches the first 4 kB of flash; the 4 kB size is a compromise between allowing
flexibility for different languages' memory layouts, while avoiding scanning too much flash when trying different flash
access modes and QSPI clock frequencies. flash partition boot  also limits its search to the first 4 kB of the partition.
The search window may be larger, such as a RAM image boot following a UF2 SRAM download, where the search
window is all of SRAM. For the fastest boot time, locate the first block as close to the beginning of the binary as
possible.
Block loops support multiple blocks because:
•Signing an image duplicates the existing IMAGE_DEF  and adds another (bigger) IMAGE_DEF  with additional signature
information.
•An image may contain multiple IMAGE_DEF s, for example, with different signing keys.
RP2350 Datasheet
5.1. Bootrom concepts 356
•Placing a block at both the beginning and end of an image can detect some partial overwrites of the image (for
example, due to an overly enthusiastic absolute-addressed UF2 download). The SDK does this by default. Hashing
or signing the entire image is more robust, since it detects corruption in the middle of the image.
•A universal binary image might contain code for both Arm and RISC-V, including IMAGE_DEF s for both.
•PARTITION_TABLE s and IMAGE_DEF s are both present in the same block loop in the case of an embedded partition table .
If a block loop contains multiple IMAGE_DEF s or multiple PARTITION_TABLE s, the winner is generally the last one seen in
linked-list order. The exception is the case of two IMAGE_DEF s for different architectures (Arm and RISC-V); an IMAGE_DEF 
for the architecture currently executing the bootrom is always preferred over one for a different architecture.
5.1.6. Block versioning
Any block may contain a version . Version information consists of a tuple of either two or three 16-bit values:
(rollback).major.minor , where the rollback part is optional. An item of type VERSION contains the binary data structure
which defines the version of a block.
The rollback version may only be specified for IMAGE_DEF s and defaults to zero if not present. You cannot specify this
version for partition tables. The rollback version can be used on a secured RP2350 , where it, along with a current
rollback verson number stored in OTP, can prevent installation of older, vulnerable code once a newer version is
installed ( Section 5.1.11 ).
The full version number can be used to pick the latest version between two IMAGE_DEF s or two PARTITION_TABLE s (see
Section 5.1.7 ). Versions compare in lexicographic order:
1.If version x has a different rollback version than version y, then the greater rollback version determines which
version is greater overall
2.Else if version x has a different major version than version y, then the greater major version determines which
version is greater overall
3.Else the minor version determines which of x and y is greater
See Section 5.9.2.1  for full details on the VERSION item in a block.
5.1.7. A/B versions
A pair of partitions may be grouped into an A/B pair. By logically grouping A and B partitions, you can keep the current
executable image (or data) in one partition, and write a newer version into the other partition. When you finish writing a
new version, you can safely switch to it, reverting to the older version if problems arise. This avoids partially written
states that could render RP2350 un-bootable.
•When booting an A/B partition pair, the bootrom typically uses the partition with the higher version. For scenarios
where this is not the case, see Section 5.1.16 .
•When dragging a UF2 onto the BOOTSEL USB drive, the UF2 targets the opposite  A/B partition to the one preferred
at boot. See Section 5.1.18  for more details.
NOTE
It is also possible to have A/B versions of the partition table. For more information about this advanced topic, see
Section 5.1.15 .
5.1.8. Hashing and signing
Any block may be hashed  or signed . A hashed block stores the image hash value (see Section 5.9.2.3 ). At runtime, the
bootrom calculates a hash and compares it to the stored hash to determine if the block is valid. Hashes guard against
RP2350 Datasheet
5.1. Bootrom concepts 357
corruption of an image, but do not provide any security guarantees.
On a secured RP2350, a hash is not sufficient for an image to be considered valid. All images must have a signature : a
hash encrypted by a private key, plus metadata (also covered by the hash) describing how the hash was generated. This
signature is stored as part of an IMAGE_DEF  block. An image with a signature in its IMAGE_DEF  block is called a signed
image .
NOTE
For background on signatures and boot keys, see the introduction to secure boot in the security chapter ( Section
10.1.1 ).
To verify a signed image, the bootrom decrypts the hash stored in the signature using a secp256k1  public key. The
bootrom also computes its own hash of the image and compares its measured hash value with the one in the signature.
The public key is also stored in the block via a SIGNATURE  item (see Section 5.9.2.4 ): this key’s (SHA-256) hash must
match one of the boot key hashes stored in OTP locations BOOTKEY0_0  onwards. Up to four public keys can be
registered in OTP, with the count defined by BOOT_FLAGS1 .KEY_VALID and BOOT_FLAGS1 .KEY_INVALID. A hash of a
key is also referred to as a key fingerprint .
The data to be hashed is defined by a HASH_DEF  item (see Section 5.9.2.2 ), which indicates the type of hash. It also
indicates how much of the block itself is to be hashed. For a signed block, the hash must  contain all contents of the
block up to the final SIGNATURE  item.
To be useful your hash or signature must cover actual image data in addition to the metadata stored in the block. The
block’s load map  item specifies which data the bootrom hashes during hash or signature verification.
The above discussion mostly applies to IMAGE_DEF s. On a secured RP2350 with the
BOOT_FLAGS0 .SECURE_PARTITION_TABLE flag set, the bootrom also enforces signatures on PARTITION_TABLE s.
5.1.9. Load maps
A load map  describes regions of the binary and what to do with them before the bootrom runs the binary.
The load map supports:
•Copying portions of the binary from flash to RAM (or to the XIP cache)
•Clearing parts of RAM (either .bss clear, or erasing uninitialised memory during secure boot)
•Defining what parts of the binary are included in a hash or signature
•Preventing the flushing of the XIP cache when to keep loaded lines pinned up to the point the binary starts
For full details on the LOAD_MAP  item type of IMAGE_DEF  blocks, see Section 5.9.3.2 .
When booting a signed binary from flash, it is desirable to load the signed data and code into RAM before  checking the
signature and subsequently executing it. Otherwise, an adversary could replace the flash device in between the
signature check and execution, subverting the check. For this reason, the load map also serves as a convenient
description of what to include in a hash or signature. The load map itself is covered by the hash or signature, and the
entire metadata block  is loaded into RAM before processing, so it is not itself subject to this time-of-check versus time-
of-use concern.
5.1.10. Packaged binaries
As described in Section 5.1.9 , signed binaries in flash on a secured RP2350 are commonly loaded from flash into RAM,
go through signature verification in RAM, and then execute from the verified version in RAM.
A packaged binary  is a binary stored in flash that runs entirely from RAM. The binary is likely compiled to run from RAM
as a RAM-only binary (unfortunately named no_flash  in SDK parlance), but subsequently post-processed for flash
RP2350 Datasheet
5.1. Bootrom concepts 358
residence. The bootrom unpackages  the binary into RAM before execution.
As part of the packaging process, tooling like picotool  adds a LOAD_MAP  that tells the bootrom which parts of the flash-
resident image it must load into RAM, and where to put them. This tooling may also hash or sign  the binary in the same
step. In this case, the bootrom hashes the data it loads as it unpackages the binary, as well as relevant metadata such
as the LOAD_MAP  itself. The bootrom compares the resulting hash to the precomputed hash or signature in the IMAGE_DEF  to
verify the unpackaged contents in RAM before running those contents.
Compare this with RP2040, where a flash-resident binary which executes from RAM (a copy_to_ram  binary in SDK
parlance) must begin by executing from flash, then copy itself to RAM before continuing from there. In the RP2040 case,
the loader itself (or rather the SDK crt0) executes in-place in flash to perform the copy. This makes it impossible to
perform any trustworthy level of verification, because the loader itself executes in untrusted memory.
5.1.11. Anti-rollback protection
Anti-rollback  on a secured RP2350 prevents booting an older binary which may have known vulnerabilities. It prevents
this even if the binary is correctly signed and meets all other requirements for bootability.
Full IMAGE_DEF  version information is of the form (rollback).major.minor , where the rollback part is optional. If a rollback
version  is present, it is accompanied by a list of OTP rows whose ordered values are used to form a thermometer  of
bits indicating the minimum rollback version that may run on the device.
A thermometer code is a base-1 (unary) number where the integer value is one plus the index of the most-significant set
bit. For example, the bit strings 00001111 , 00001001 , and 00001000  all encode a value of four, and the all-zeroes bit pattern
encodes a value of zero. The bootrom uses this encoding because:
•it allows OTP rows containing counters to be incremented, and
•it does not allow them to be decremented
On a secured RP2350, the bootrom compares the rollback version of the IMAGE_DEF  against the thermometer-coded
minimum rollback version stored in OTP. If the IMAGE_DEF  value is lower, the bootrom refuses to boot the image.
The IMAGE_DEF  rollback version is covered by the image’s signature, thus cannot be modified by an adversary who does
not know the signing key. The list of OTP rows which define the chip’s minimum rollback version is also stored in the
program image, and also covered by the image signature.
The list of OTP rows in the IMAGE_DEF  must always have at least one bit spare beyond the IMAGE_DEF 's rollback version
(enforced by picotool ). As a result, older binaries always contain enough information for the bootrom to detect that the
chip’s minimum rollback version has been incremented past the rollback version in the IMAGE_DEF . You can append more
rows to the list on newer binaries to accommodate higher rollback versions without ambiguity.
When an executable image with a non-zero rollback version is successfully booted, its rollback version is written to the
OTP thermometer. The BOOT_FLAGS0 .ROLLBACK_REQUIRED flag may be used to require  an IMAGE_DEF  have a rollback
version on a secured RP2350. This flag is set automatically when updating the rollback version in OTP.
NOTE
An IMAGE_DEF  with a rollback version of 0 will not automatically set the BOOT_FLAGS0 .ROLLBACK_REQUIRED flag, so
it is recommended that the minimum rollback version used is 1, unless the BOOT_FLAGS0 .ROLLBACK_REQUIRED
flag is manually set during provisioning.
5.1.12. Flash image boot
RP2350 is designed primarily to run code from a QSPI flash device, either in-package or soldered separately to the
circuit board. Code runs either in-place in flash, or in SRAM after being loaded from flash. Flash boot  is the process of
discovering that code and preparing to run it. Flash image boot  uses a program binary stored directly in flash rather
than in a flash partition . Flash image boot requires the bootrom to discover a block loop starting within the first 4 kB of
flash which contains a valid IMAGE_DEF  (and no PARTITION_TABLE ).
RP2350 Datasheet
5.1. Bootrom concepts 359
Flash image boot has no partition table, so it cannot be used with A/B version checking, which requires separate A/B
partitions. The IMAGE_DEF  will boot if it is valid (which includes requiring a signature on a secured RP2350).
For the non-signed case, the IMAGE_DEF  can be as small as a 20-bytes; see Section 5.9.5 .
TIP
A more complicated version of this scenario stores multiple IMAGE_DEF s in the block loop. In this case, the last
IMAGE_DEF  for the current architecture is booted, if valid. You can use this to implement universal binaries for various
supported architectures, or to include multiple signatures for targeting devices with different keys.
5.1.13. Flash partition boot
If a PARTITION_TABLE , but no IMAGE_DEF , is found in the valid block loop that starts within the first 4 kB of flash, and it is valid
(including signature if necessary on a secured RP2350), the bootrom searches that partition table’s partitions for an
executable image to boot. This process, when successful, is referred to as flash partition boot .
The partitions are searched in order, skipping those marked as ignored for the current architecture. The bootrom
ignores partitions as an optimisation, or to prevent automatic architecture switching .
If the partition is not part of an A/B pair, the first 4 kB is searched for the start of a valid block loop. If a valid block loop
is found, and it contains an executable image with a valid (including signature on a secured RP2350) IMAGE_DEF , then that
executable image is chosen for boot.
If the partition is the A partition of an A/B pair, the bootrom searches both partitions as described above. If both
partitions result in a bootable IMAGE_DEF , the IMAGE_DEF  with the higher version number is chosen. Otherwise, the valid
IMAGE_DEF  is chosen. There are some exceptions to this rule in advanced scenarios; see Section 5.1.16  and Section
5.1.17  for details.
5.1.14. Partition-Table-in-Image boot
If both a PARTITION_TABLE  and an IMAGE_DEF  block are found in the valid block loop that starts within the first 4 kB of flash, a
third type of flash boot takes place. The IMAGE_DEF  and PARTITION_TABLE  must only be recognised, not necessarily valid or
correctly signed. This stipulation prevents a causality loop.
This is known as partition-table-in-image  boot, since the application contains the partition table (instead of vice versa).
This partition table is referred to as an embedded partition table .
The PARTITION_TABLE  is loaded as the current partition table, and the IMAGE_DEF  is launched directly. The table defined by
the PARTITION_TABLE  is not searched for IMAGE_DEF s to boot.
The following common cases might use this scenario:
•You are only using the PARTITION_TABLE  for flash permissions. You want to load that partition table, then boot as
normal.
•The IMAGE_DEF  contains a small bootloader stored alongside the partition table. In this case, the partition table will
once again be loaded, and the associated image entered. The entered image will then likely pick a partition from
the partition table, and launch an image from there itself.
5.1.15. Flash boot slots
The previous sections within this chapter discuss block loops starting within the first 4 kB of flash. Such a block loop
contained either an IMAGE_DEF , a partition table (searched for IMAGE_DEF s), or an IMAGE_DEF  and a PARTITION_TABLE  (not
searched).
All the previously mentioned cases discovered their block loop in slot 0 . Under certain circumstances, the neighbouring
slot 1  is also searched.
RP2350 Datasheet
5.1. Bootrom concepts 360
Slot 0 starts at the beginning of flash, and has a size of n × 4 kB sectors. Slot 1 has the same size and follows
immediately after slot 0. The value of n defaults to 1. Both slots are 4 kB in size, but you can override this value by
specifying a value in FLASH_PARTITION_SLOT_SIZE  and then setting
BOOT_FLAGS0 .OVERRIDE_FLASH_PARTITION_SLOT_SIZE.
Similarly to how a choice can be made between IMAGE_DEF s in A/B partitions, a choice can be made between A/B
PARTITION_TABLE s via the two boot slots . This allows for versioning partition tables, targeted drag and drop of UF2s
(Section 5.1.18 ) containing partition tables, etc. similar to the process used for images.
Slot 1 is only of use when potentially using partition tables. In the simple case of an IMAGE_DEF  and no PARTITION_TABLE 
found in a block loop starting in slot 0, that image likely actually overlays the space where slot 1 would be, but in any
case, slot 1 is ignored since there is no PARTITION_TABLE .
If slot 0 contains a PARTITION_TABLE  or does not contain an IMAGE_DEF  (including nothing/garbage in slot 0), slot 1 can be
considered. As an optimisation, in the former case, the scanning of slot 1 can be prevented by setting the singleton flag
in the PARTITION_TABLE .
NOTE
When IMAGE_DEF s are also present in the slots, the PARTITION_TABLE 's VERSION item determines which of slot 0 and slot 1
to use. The IMAGE_DEF  metadata is ignored for the purpose of version comparison.
5.1.16. Flash update boot and version downgrade
Normally the choice of slot 0 versus slot 1, and partition A versus partition B, is made based on the version  of the valid
PARTITION_TABLE  or IMAGE_DEF  in those slots or partitions respectively. The greater of the two versions wins.
It is however perfectly valid to downgrade to a lower-versioned IMAGE_DEF  when using A/B partitions, provided this does
not violate anti-rollback  rules on a secured RP2350.
Downloading the new image (and its IMAGE_DEF ) into the non-currently-booting partition and doing a normal reboot will
not work in this case, as the newly downloaded image has a lower version.
For this purpose, you can enable a flash update boot  boot by passing the FLASH_UPDATE  boot type constant flag through
the watchdog scratch registers and a pointer to the start of the region of flash that has just been updated.
The bootrom automatically performs a flash update boot after programming a flash UF2 written to the USB Mass
Storage drive. You can also invoke a flash update boot programmatically via the reboot()  API (see Section 5.4.8.24 ).
The flash address range passed through the reboot parameters is treated specially during a flash update boot. A
PARTITION_TABLE  in a slot, or IMAGE_DEF  in a partition, will be chosen for boot irrespective of version, if the start of the region
is the start of the respective slot or partition.
In order for the downgrade to persist, the first sector of the previously booting slot or partition must be erased so that
the newly installed PARTITION_TABLE  or IMAGE_DEF  will continue to be chosen on subsequent boots. This erase is performed
as follows during a FLASH_UPDATE  boot.
1.When a PARTITION_TABLE  is valid (and correctly signed if necessary) and its slot is chosen for boot, the first sector of
the other slot is erased.
2.When a valid (and correctly signed if necessary) IMAGE_DEF  is launched, the first sector of the other image is erased.
3.On explicit request by the image, after it is launched, the first sector of the other image is erased. This is an
alternative to the standard behaviour in the previous bullet, and is selected by a special "Try Before You Buy" flag in
the IMAGE_DEF . For more information about this feature, see Section 5.1.17 .
RP2350 Datasheet
5.1. Bootrom concepts 361
NOTE
Flash update and version downgrade have no effect when using a single slot, or standalone (non A/B) partitions.
5.1.17. Try before you buy
Try before you buy  (abbreviated TBYB ) is an IMAGE_DEF -only feature that allows for a completely safe cycle of version
upgrade:
1.An executable image is running from say partition B.
2.A new image is downloaded into partition A.
3.On download completion, a FLASH_UPDATE  reboot is performed for the newly updated partition A.
4.The bootrom will preferentially try to boot partition A (due to the flash update). Note that a non TBYB image will
always be chosen over a TBYB image in A/B partitions during a normal non- FLASH_UPDATE  boot.
◦If the new image fails validation/signature then the old image in partition B will be used on subsequent (non-
FLASH_UPDATE ) boots, recovering from the failed upgrade.
5.If the new image is valid (and correctly signed if necessary), it is entered under a watchdog timer, and has 16.7
seconds to mark itself OK via the explicit_buy()  function.
◦If the image calls back, the first 4 kB sector of the other partition (containing image B) is erased, and the
TBYB flag of the current image is cleared, so that A becomes the preferred partition for subsequent boots.
◦If the image does not call back within the allotted time, then the system reboots, and will continue to boot
partition B (containing the original image) as partition A is still marked as TBYB image.
The erase of the first sector of the opposite partition in the A/B pair severs its image’s block loop , rendering it
unbootable. This ensures the tentative image booted under TBYB becomes the preferred boot image going forward,
even if the opposite image had a higher version.
The watchdog timeout is fixed at 16.7 seconds (24-bit count on a 1-microsecond timebase). This can be shortened after
entering the target image, for example if it only needs a few hundred milliseconds for its self-test routine. It can also be
extended by reloading the watchdog counter, at the risk of getting stuck in the tentative image if it fails in a way that
repeatedly reloads the watchdog.
5.1.18. UF2 targeting
Section 5.5  describes the USB Mass Storage drive, and the ability to download UF2 files to that drive to store and/or
execute code/data on the RP2350.
Since RP2350 supports multiple processor architectures, and partition tables with multiple partitions, some information
on the device must be used to determine what to do with a flash-addressed UF2. Depending on the context, the flash
addresses in the UF2 may be absolute flash storage addresses (as was always the case on RP2040), or runtime
addresses of code and data within a flash partition. UF2 targeting  refers to the rules the bootrom applies to interpret
flash addresses in a UF2 file.
UF2 supports a 32-bit family ID embedded in the file. This enables the device to recognise firmware that targets it
specifically, as opposed to firmware intended for some other device. The RP2350 bootrom recognises some standard
UF2 family IDs ( rp2040, rp2350-arm-s , rp2350-arm-ns , rp2350-riscv , data and absolute ) defined in Table 455 . You may define
your own family IDs in the partition table for more refined targeting.
The UF2 family ID is used as follows:
1.A UF2 with the absolute  family ID is downloaded without regard to partition boundaries. A partition table (if present)
or OTP configuration define whether absolute  family ID downloads are allowed. The default factory settings do
allow for absolute  family ID downloads.
RP2350 Datasheet
5.1. Bootrom concepts 362
2.If there is no partition table, then the data, rp2350-arm-s  (if Arm is enabled) and rp2350-riscv  (if RISC-V is enabled)
family IDs are allowed by default. The UF2 is always downloaded to the start of flash.
3.If there is a partition table, then non- absolute  family IDs target a single partition under the control of the partition
table:
a.A UF2 will not be downloaded to a partition that doesn’t have BL-write flash permissions
b.Each partition lists which family IDs it accepts (both RP2350 standard and user defined)
c.With A/B partitions; the A partition indicates the family IDs supported, and the UF2 goes to the partition that
isn’t the currently booting one (strictly the one that won’t be the one chosen if the device were rebooted now).
d.Further refinement with A/B is allowed to support secondary A/B partitions containing data/executables used
(owned) by the main partitions; see Section 5.1.18.1  for detailed information.
For details of the exact rules used when picking a UF2 target partition, see Section 5.5.3 .
NOTE
UF2 family ids are used for partition targeting when copying UF2s to the USB drive, or when using picotool load -p .
When using picotool load  without the -p flag images can be written anywhere in flash that has BL-write permissions.
5.1.18.1. Owned partitions
An executable might require data from another partition (such as Wi-Fi firmware). When the main executable is stored in
A/B partitions , for safe upgrades, it may be desirable to associate two other partitions C and D with the primary A and B
partitions, such that:
•the data in partition C is used for executable in partition A, and
•the data in partition D is used for the executable in partition B.
In this scenario A is marked as the owner  of C in the partition table, and C is A’s owned partition . This affects UF2
image downloads which (due to their UF2 family ID) target partitions C and D.
When a UF2 download targets the C/D partition pair, the bootrom checks the state of the A and B owning partitions to
determine which of the owned partitions (C and D) receives the download. By default:
•If B would be the target partition for a UF2 with an A/B-compatible family ID, then D is the target for a UF2 with the
C/D compatible family ID.
•Conversely, when A is the target partition for A/B downloads, C is the target partition for C/D downloads.
The FLAGS_UF2_DOWNLOAD_AB_NON_BOOTABLE_OWNER_AFFINITY  flag in the partition table reverses this mapping.
5.1.19. Address translation
RP2040 required images to be stored at the beginning of flash ( 0x10000000 ). RP2350 supports storing executable images
in a partitions at arbitrary locations, to support more robust upgrade cycles via A/B versions , among other uses. This
presents the issue that the address an executable is linked at, and therefore the binary contents of the image, would
have to depend on the address it is stored at. This can be worked around to an extent with position-independent code,
at cost to code size and performance.
RP2350 avoids this pitfall with hardware and bootrom support for address translation . An image stored at any 4 kB-
aligned location in flash can appear at flash address 0x10000000  at runtime. The SDK continues to assume an image base
of 0x10000000  by default.
When launching an image from a partition, the bootrom initialises QMI registers ATRANS0  through ATRANS3  to map a
flash runtime address  of 0x10000000  (by default) to the flash storage address  of the start of the partition. It sets the total
size of the mapped region to the size of the partition, with a maximum size of 16 MB. Accessing flash addresses
beyond the size of the booted partition (but below the 0x11000000  chip select watermark) returns a bus fault.
RP2350 Datasheet
5.1. Bootrom concepts 363
As an example, if the booted partition was 6 MB big, starting 1 MB into flash, the registers would be set up as follows:
Name / Memory Start Flash Start Size
ATRANS0 / 0x10000000 0x10100000 4 MB
ATRANS1 / 0x10400000 0x10500000 2 MB
ATRANS2 / 0x10800000 - 0
ATRANS3 / 0x10c00000 - 0
This maps the physical flash range from 0x10100000 -0x10700000  to flash addresses 0x10000000 -0x10600000 , ensuring the
partition appears at the start of flash at runtime.
In this case, since ATRANS2  and ATRANS3  aren’t needed to map the partition, they could be used by the application to
map another part of flash.
Mapping the start of the partition to a runtime address of 0x10000000  is the default behaviour, but you may choose a
different address, with some restrictions. The bootrom allows for runtime address values of 0x10000000 , 0x10400000 ,
0x10800000 , and 0x10c00000  for the beginning of the mapped regions, with the choice specified in the IMAGE_DEF . You must
link your binary to run at the correct, higher base address. This is useful, for example, when an application runs from a
high flash address and remains mapped there while launching a second application at address 0x10000000 . You might
use this setup when a Secure image provides services to a Non-secure client image.
This custom address translation is enabled by a negative ROLLING_WINDOW_DELTA  value (see Section 5.9.3.5 ). The above
four runtime addresses translate to a ROLLING_WINDOW_DELTA  of 0, -0x400000 , -0x800000 , or -0xc00000 , which are the only
supported non-positive values. The delta indicates how many bytes into the partition the runtime address 0x10000000 
appears. A negative delta value indicates that address 0x10000000  appears before the start of the partition; the partition
starts that many bytes higher than 0x10000000 .
Positive values are also useful, for example, when prepending data to an already linked image as a post-processing
step. Positive deltas must be multiples of 4 kB. For example, a ROLLING_WINDOW_DELTA  of 0x1000 will set up address
translation so that the image data starting at offset 0x1000 within the partition is mapped to 0x10000000  at runtime,
omitting the first 4 kB of the image from the mapped region. The first 4 kB is inaccessible except through the
untranslated XIP window, which defaults to Secure access only.
NOTE
Because address translation within the 0x100000000  → 0x11000000  and 0x11000000  → 0x12000000  windows is independent,
it is only possible to boot from partitions which are entirely contained within the first 16 MB of flash.
This address translation is performed by hardware in the QMI. For more information, see Section 12.14.4 .
5.1.20. Automatic architecture switching
If the bootrom encounters a valid and correctly signed IMAGE_DEF  for the non-current architecture (RISC-V when booted in
Arm mode, or Arm when booted in RISC-V), it performs an automatic architecture switch . The bootrom initiates a reboot
into the correct architecture for the binary it discovered, which then boots successfully on the second attempt.
Information passed in watchdog scratch registers (such as a RAM image boot type ) is retained, so that the second boot
makes the same decisions as the first, and arrives at the same preferred image to boot.
This happens only when:
•The architecture to be switched to is available according to OTP critical flags
•The architecture switch feature is not disabled by the BOOT_FLAGS0 .DISABLE_AUTO_SWITCH_ARCH flag
•The bootrom found no valid binary for the current  architecture before finding one for the other  architecture
RP2350 Datasheet
5.1. Bootrom concepts 364
TIP
When storing executable images for both architectures in flash, it’s usually preferable to boot an image for the
current  architecture. To do this, keep the images in different partitions, marking the partition for Arm as ignored
during boot under RISC-V and vice versa. This avoids always picking the image in the first partition and auto-
switching to run it under the other architecture.
For hardware support details for architecture switching, see Section 3.9 .
5.2. Processor-controlled boot sequence
The bootrom contains the first instructions the processors execute following a reset. Both processors enter the
bootrom at the same time, and in the same location, but the boot sequence runs mostly on core 0.
Core 1 redirects very early in the boot sequence to a low-power state where it waits to be launched, after boot, by user
software on core 0. If core 1 is unused, it remains in this low-power state.
Source Code Reference
The sequence described in this section is implemented on Arm by the source files arm8_bootrom_rt0.S 
and varm_boot_path.c  in the bootrom source code repository. RISC-V cores instead begin from
riscv_bootrom_rt0.S , but share the boot path implementation with Arm.
5.2.1. Boot outcomes
The bootrom decides the boot outcome  based on the following system state:
•The contents of the attached QSPI memory device on chip select 0, if any
•The contents of POWMAN registers BOOT0  through BOOT3
•The contents of watchdog registers SCRATCH4  through SCRATCH7
•The contents of OTP, particularly CRIT1 , BOOT_FLAGS0  and BOOT_FLAGS1
•The QSPI CSn pin being driven low externally (to select BOOTSEL)
•The QSPI SD1 pin being driven high externally (to select UART boot in BOOTSEL mode)
Based on these, the outcome of the boot sequence may be to:
•Call code through a vector  specified in SCRATCH or BOOT registers prior to the most recent reboot, for example, into
code retained in RAM following a power-up from a low-power state.
•Run an image from external flash.
◦This can happen in one of two ways: either the image runs in-place directly from external flash, or the image is
loaded into RAM during the boot sequence.
◦In-package flash on RP2354 is external for boot purposes. It’s a separate silicon die, and the RP2350 die
doesn’t implicitly trust it.
•Run an image preloaded into SRAM (distinct from the vector case).
•Load and run an image from OTP into SRAM.
•Enter the USB bootloader.
•Enter the UART bootloader.
•Perform a one-shot operation requested via the reboot()  API, such as a flash update boot . This may be requested
RP2350 Datasheet
5.2. Processor-controlled boot sequence 365
by the user, or by the UART or UF2 bootloaders.
•Refuse to boot, due to lack of suitable images and the UART and USB bootloaders being disabled via OTP.
This section makes no distinction between the different types of flash boot ( flash image boot , flash partition boot  and
flash partition-table-in-image boot ). Likewise, it does not distinguish these types from packaged binaries , which are
loaded into RAM at boot time, because these are just flash binaries with a special load map . This section just describes
the sequence of decisions the bootrom makes to decide which medium to boot from.
5.2.2. Sequence
This section enumerates the steps of the processor-controlled boot sequence for Arm processors. There are some
minor differences on Arm versus RISC-V, which are discussed in Section 5.2.2.2 .
A valid  image in Table 451  refers to one that contains a valid block loop , with one of those blocks being a valid image
definition . On a secured RP2350 this image must be (correctly) signed , and must meet all other security requirements
such as minimum rollback version .
Shaded cells in the Action column of Table 451  indicate a boot outcome as described in Section 5.2.1 . Other cells are
transitory states which continue through the sequence. Both cores start the sequence at Entry.
The main sequential steps in Table 451  are:
•Entry
•Core 1 Wait
•Boot Path Start
•Await Rescue
•Generate Boot Random
•Check POWMAN Vector
•Check Watchdog Vector
•Prepare for Image Boot
•Try RAM Image Boot
•Check BOOTSEL
•Try OTP Boot
•Try Flash Boot
•Prepare for BOOTSEL
•Enter USB Boot
•Enter UART Boot
•Boot Failure
For a summary of Table 451  in pseudocode form, see Section 5.2.2.1 .
Table 451. Processor-
controlled boot
sequenceCondition (If…) Action (Then…)
Step: Entry
Always Check core number in CPUID  or MHARTID .
Running on core 0 Clear boot RAM (except for core 1 region and the always region).
Go to Boot Path Start .
Running on core 1 Go to Core 1 Wait .
RP2350 Datasheet
5.2. Processor-controlled boot sequence 366
Condition (If…) Action (Then…)
Step: Core 1 Wait 
Always Wait for RCP salt register to be marked valid by core 0.
Wait for core 0 to provide an entry point through Secure SIO FIFO, using the protocol
described in Section 5.3 .
Outcome: Set Secure main sp and VTOR, then jump into the entry point provided.
Step: Boot Path Start 
Always Check rescue flag, CHIP_RESET .RESCUE_FLAG
Rescue flag set Go to Await Rescue .
Rescue flag clear Go to Generate Boot Random .
Step: Await Rescue 
Always Clear the rescue flag to acknowledge the request.
Outcome: Halt in place. The debugger attaches to give the processor further instruction.
Step: Generate Boot Random 
Always Sample TRNG ROSC into the SHA-256 to generate a 256-bit per-boot random number.
Store 128 bits in boot RAM for retrieval by get_sys_info() , and distribute the remainder to
the RCP salt registers.
Go to Check POWMAN Vector .
Step: Check POWMAN Vector 
Always Read BOOT0  through BOOT3  to determine requested boot type.
Boot type parity is valid Clear BOOT0  so this is ignored on subsequent boots.
A BOOTDIS flag is set Go to Check Watchdog Vector .
Boot type is VECTOR Outcome: Set Secure main sp, then call into the entry point provided.
(Return from VECTOR) Go to Check Watchdog Vector .
Other or invalid boot type Go to Check Watchdog Vector .
Step: Check Watchdog Vector 
Always Read watchdog SCRATCH4  through SCRATCH7  to determine requested boot type.
Boot type parity is valid Clear SCRATCH4  so this is ignored on subsequent boots.
Boot type is BOOTSEL Make note for later: equivalent to selecting BOOTSEL by driving QSPI CSn low.
A BOOTDIS flag is set Go to Prepare for Image Boot  (so BOOTSEL is the only permitted type when the OTP
BOOTDIS .NOW or POWMAN BOOTDIS .NOW flag is set).
Boot type is VECTOR Outcome: Set Secure main sp, then call into the entry point provided.
(Return from VECTOR) Go to Prepare for Image Boot .
Boot type is RAM_IMAGE Make note for later: this requests a scan of a RAM region for a preloaded image.
Boot type is FLASH_UPDATE Make note for later: modifies some flash boot behaviour, as described in Section 5.1.16 .
Always Go to Prepare for Image Boot .
Step: Prepare for Image Boot 
RP2350 Datasheet
5.2. Processor-controlled boot sequence 367
Condition (If…) Action (Then…)
Always Clear BOOTDIS flags (OTP BOOTDIS .NOW and POWMAN BOOTDIS .NOW).
Power up SRAM0 and SRAM1 power domains (XIP RAM domain is already powered).
Reset all PADS and IO registers, and remove isolation from QSPI pads.
Release USB reset and clear upper 3 kB of USB RAM (for search workspace).
Go to Try RAM Image Boot .
Step: Try RAM Image Boot 
Watchdog type is not
RAM_IMAGEGo to Check BOOTSEL .
BOOT_FLAGS0 .DISABLE_SR
AM_WINDOW_BOOT is setGo to Check BOOTSEL .
Otherwise Scan indicated RAM address range for a valid image (base in SCRATCH2 , length in
SCRATCH3 ). This is used to boot into a RAM image downloaded via UF2, for example.
RAM image is valid Outcome: Enter RAM image in the manner specified by its image definition.
No valid image Go to Prepare for Bootsel  (skipping flash and OTP boot).
Step: Check BOOTSEL 
Always Check BOOTSEL request: QSPI CSn is low (BOOTSEL button), watchdog type is BOOTSEL, or
RUN pin double-tap was detected (enabled by BOOT_FLAGS1 .DOUBLE_TAP).
BOOTSEL requested Go to Prepare for BOOTSEL  (skipping flash and OTP boot).
Otherwise Go to Try OTP Boot .
Step: Try OTP Boot 
Always Check BOOT_FLAGS0 .DISABLE_OTP_BOOT and BOOT_FLAGS0 .ENABLE_OTP_BOOT
(the disable takes precedence).
OTP boot disabled Go to Try Flash Boot .
OTP boot enabled Load data from OTPBOOT_SRC  (in OTP) to OTPBOOT_DST0 /OTPBOOT_DST1  (in
SRAM), with the length specified by OTPBOOT_LEN .
Check validity of the image in-place in SRAM.
Image is valid Outcome: Enter RAM image in the manner specified by its image definition.
No valid image Go to Try Flash Boot .
Step: Try Flash Boot 
Flash boot disabled by
BOOT_FLAGS0Go to Prepare for BOOTSEL .
Always Issue XIP exit sequence to chip select 0.
FLASH_DEVINFO  has GPIO
and size for chip select 1Issue XIP exit sequence to chip select 1.
Always Scan flash for a valid image (potentially in a partition) with a range of instructions (EBh,
BBh, 0Bh, 03h) and SCK divisors (3 to 24)
RP2350 Datasheet
5.2. Processor-controlled boot sequence 368
Condition (If…) Action (Then…)
Valid image found Outcome: Enter flash image in the manner specified by its image definition. This may
including loading some flash contents into RAM.
Save the current flash read mode as an XIP setup function at the base of boot RAM,
which can be called later to restore the current mode (for example, following a serial
programming operation).
No valid image Go to Prepare for BOOTSEL .
Step: Prepare for BOOTSEL 
Always Erase SRAM0 through SRAM9, XIP cache and USB RAM to all-zeroes before
relinquishing memory and peripherals to Non-secure.
Enable XOSC and configure PLL for 48 MHz, according to BOOTSEL_XOSC_CFG  and
BOOTSEL_PLL_CFG  (default is to expect a 12 MHz crystal).
Check QSPI SD1 pin (with default pull-down resistor) for UART/USB boot select.
Scan flash for a partition table (always using an 03h serial read command with an SCK
divisor of 6). The USB bootloader may download UF2s to different flash addresses
depending on partitions and their contents.
Advance all OTP soft locks to the BL state from OTP, if more restrictive than their S state.
QSPI SD1 pulled low Go to Enter USB Boot .
QSPI SD1 driven high Go to Enter UART boot .
Step: Enter USB Boot 
Always Check BOOT_FLAGS0 .DISABLE_BOOTSEL_USB_PICOBOOT_IFC and
BOOT_FLAGS0 .DISABLE_BOOTSEL_USB_MSD_IFC to see which USB interfaces are
permitted.
Both USB interfaces
disabledGo to Boot Failure .
Otherwise Outcome: Enter USB bootloader. The bootloader reboots if a UF2 image is downloaded,
marking a FLASH_UPDATE  in the watchdog scratch registers if applicable, and the boot path
restarts from Entry. Valid images boot; invalid images usually end up back in the USB
bootloader.
Step: Enter UART Boot 
Always Check BOOT_FLAGS0 .DISABLE_BOOTSEL_UART_BOOT to see if UART boot is
permitted.
UART boot disabled Go to Boot Failure .
Otherwise Outcome: Enter UART bootloader. The bootloader reboots once an image has been
downloaded, with a RAM_IMAGE  boot type, and the boot path restarts from Entry. Valid
images boot; invalid images usually end up back in the UART bootloader.
Step: Boot Failure 
Always Outcome: Take no further action. No valid boot image was discovered, and the selected
BOOTSEL interface was disabled. Attach the debugger to give the processor further
instruction. See the boot reason in boot RAM for diagnostics on why the boot failed.
RP2350 Datasheet
5.2. Processor-controlled boot sequence 369
TIP
The bootrom internally refers to BOOTSEL mode as NSBOOT, because the USB and UART bootloaders run in the
Non-secure state under Arm. This chapter may also occasionally refer to BOOTSEL as NSBOOT.
5.2.2.1. Boot sequence pseudocode
The following pseudocode summarises Table 451 .
if (powman_vector_valid  && powman_reboot_mode_is_pcsp ) {
    // This call may return and continue the boot path
    if (correct_arch ) powman_vector_pc (); else hang();
}
if (watchdog_vector_valid ) {
    // Make note of RAM_IMAGE, FLASH_UPDATE, BOOTSEL reboot types
    check_special_reboot_mode ();
    if (watchdog_reboot_mode_is_pcsp ) {
        // This call may return and continue the boot path
        if (correct_arch ) watchdog_vector_pc (); else hang();
    }
}
// RAM image window specified by watchdog_scratch, e.g. after a UF2 RAM
// download: either execute the RAM image or fall back to UART/USB boot.
if (watchdog_reboot_mode_is_ram_image  && !ram_boot_disabled_in_otp ) {
    // This only returns if there is no valid RAM image to enter.
    // You can't return from the RAM image.
    try_boot_ram_image (ram_image_window );
} else {
    // Otherwise try OTP and flash boot (unless there is a request to skip)
    skip_flash_and_otp_boot  =
        bootsel_button_pressed () ||
        watchdog_reboot_mode_is_bootsel  ||
        (double_tap_enabled_in_otp () && double_run_reset_detected ());
    if (!skip_flash_and_otp_boot ) {
        if (otp_boot_enabled_in_otp  && !otp_boot_disabled_in_otp ) {
            // This only returns if there is no valid OTP image to enter.
            // You can't return from the OTP image.
            try_otp_boot ();
        }
        if (!flash_boot_disabled_in_otp ) {
            // This only returns if there is no valid flash image to enter.
            // You can't return from the flash image.
            try_flash_boot ();
        }
    }
}
// Failed to find an image, so drop down into one of the bootloaders
if (sd1_high_select_uart ) {
    // Does not return except via reboot
    if (nsboot_uart_disabled ) hang(); else nsboot(uart);
} else {
    // Does not return except via reboot
    if (nsboot_usb_disabled ) hang(); else nsboot(usb);
}
RP2350 Datasheet
5.2. Processor-controlled boot sequence 370
5.2.2.2. Differences between Arm and RISC-V
The boot sequence outlined in Table 451  has the following differences on RISC-V:
•Secure boot is not supported (from any image source).
•Anti-rollback checking is not supported as it applies only to secure boot.
•Additional security checks such as the use of the RCP to validate booleans are disabled.
•The UART and USB bootloaders continue to run in Machine mode, rather than transitioning from the Arm Secure to
Non-secure state, meaning there is no hardware-enforced security boundary between these boot phases.
•The XIP setup function written to boot RAM on a successful flash boot contains RISC-V rather than Arm
instructions.
5.2.3. POWMAN boot vector
POWMAN contains scratch registers similar to the watchdog scratch registers, which persist over power-down of the
switched core power domain, in addition to most system resets. These registers allow users to install their own boot
handler, and divert control away from the main boot sequence on non-POR/BOR resets. It recognises the following
values written to BOOT0  through BOOT3 :
•BOOT0 : magic number 0xb007c0d3
•BOOT1 : Entry point XORed with magic -0xb007c0d3  (0x4ff83f2d )
•BOOT2 : Stack pointer
•BOOT3 : Entry point
Use this to vector into code preloaded in RAM which was retained during a low-power state.
If either of the magic numbers mismatch, POWMAN vector boot does not take place. If the numbers match, the
bootrom zeroes BOOT0 before entering the vector, so that the behaviour does not persist over subsequent reboots.
The POWMAN boot vector is permitted to return. The boot sequence continues as normal after a return from POWMAN
vector boot, as though the vector boot had not taken place. There is no requirement for the vector to preserve the global
pointer ( gp) register on RISC-V. Use this to perform any additional setup required for the boot path, such as issuing a
power-up command to an external QSPI device that may have been powered down (for example, through a B9h power-
down command).
The entry point ( pc) must have the LSB set on Arm (the Thumb bit) and clear on RISC-V. If this condition is not met, the
bootrom assumes you have passed a RISC-V function pointer to an Arm processor (or vice versa) and hangs the core
rather than continuing, since executing code for the wrong architecture has spectacularly undefined consequences.
The linker should automatically set the Thumb bit appropriately for a function pointer relocation, but this is something to
be aware of if you pass hardcoded values such as the base of SRAM: this is correctly passed as 0x20000001  on Arm
(Thumb bit set) and 0x20000000  on RISC-V (no Thumb bit, halfword-aligned).
5.2.4. Watchdog boot vector
Watchdog boot allows users to install their own boot handler, and divert control away from the main boot sequence on
non-POR/BOR resets. It recognises the following values written to the watchdog’s upper scratch registers:
•SCRATCH4 : magic number 0xb007c0d3
•SCRATCH5 : entry point XORed with magic -0xb007c0d3  (0x4ff83f2d )
•SCRATCH6 : stack pointer
•SCRATCH7 : entry point
If either of the magic numbers mismatch, watchdog boot does not take place. If the numbers match, the Bootrom
RP2350 Datasheet
5.2. Processor-controlled boot sequence 371
zeroes SCRATCH4  before transferring control, so that the behaviour does not persist over subsequent reboots.
Watchdog boot can also be used to select the bootrom’s special one-shot boot modes, described in Section 5.2.4.1 . The
term one-shot  refers to the fact these only affect the next boot (and not subsequent ones) due to the bootrom clearing
SCRATCH4  each boot. These boot types are encoded by setting a special entry point ( pc) value of 0xb007c0d3 , which is
otherwise not a valid entry address, and then setting the boot type in the stack pointer ( sp) value. Section 5.2.4.1  lists
the supported values.
The watchdog boot vector is permitted to return. The boot path continues as normal when it returns: use this to perform
any additional setup required for the boot path, such as issuing additional commands to an external QSPI device. On
RISC-V the vector is permitted to use its own global pointer ( gp) value, as the bootrom only uses gp during USB boot,
which installs its own value.
With the exception of the magic boot type entry point ( 0xb007c0d3 ), the vector entry point pc must have the LSB set on
Arm (the Thumb bit) and clear on RISC-V. If this condition is not met, the bootrom assumes you have passed a RISC-V
function pointer to an Arm processor (or vice versa) and hangs the core rather than continuing.
5.2.4.1. Special watchdog boot types
The magic entry point 0xb007c0d3  indicates a special one-shot boot type, identified by the stack pointer value:
BOOTSEL
Selected by sp = 2. Boot into BOOTSEL mode. This will be either UART or USB boot depending on whether QSPI SD1
is driven high (default pull-down selects USB boot). See Section 5.2.8  for more details.
RAM_IMAGE
Selected by sp = 3. Boot into an image stored in SRAM or XIP SRAM. BOOTSEL mode uses this to request execution
of an image it loaded into RAM before rebooting. See Section 5.2.5  for more details.
FLASH_UPDATE
Selected by sp = 4. BOOTSEL selects this mode when rebooting following a flash download. Changes some flash
boot behaviour, such as allowing older versions  to boot in preference to newer ones. See Section 5.1.16  for more
details.
Parameters to the one-shot boot type are passed in:
•SCRATCH2 : Parameter 0
•SCRATCH3 : Parameter 1
These directly correspond to the p0 and p1 boot parameters passed into the reboot()  API. For example, on a RAM_IMAGE 
boot, this specifies the base and size of the RAM region to be searched for a valid IMAGE_DEF . See the API listing in
Section 5.4.8.24  for more details. When not performing one of the listed boot types, SCRATCH2  and SCRATCH3  remain
free for arbitrary user values, and the bootrom doesn’t modify or interpret their contents.
5.2.5. RAM image boot
The bootrom is directed (through values in the watchdog registers) to boot into an image in SRAM or XIP SRAM. The
two parameters indicate the start and size of the region to search for a block loop containing a valid (and correctly
signed if necessary) IMAGE_DEF . These are passed as parameter 0/1, in watchdog scratch 2/3.
If the image to be booted is contained in XIP SRAM, the XIP SRAM must be pinned in place by the bootrom prior to
launch. For this reason, if you are using XIP SRAM for your binaries, you must add a special entry to the LOAD_MAP  item
(see Section 5.9.3.2 ).
RP2350 Datasheet
5.2. Processor-controlled boot sequence 372
5.2.6. OTP boot
If OTP boot is enabled, then code from OTP is executed in preference to code from flash. Note that the OTP code is free
to "chain" into an executable stored in flash.
Code from OTP is copied into SRAM at the specified location, then execution proceeds similarly to RAM Image Boot.
The SRAM with the data copied from OTP is searched for a valid (and correctly signed if necessary) IMAGE_DEF . If found, it
is booted; otherwise OTP boot falls through to Flash Boot (if enabled).
OTP boot could, for example, be used to execute some hidden decryption code to decode a flash image on startup. The
OTP boot code can hide itself (in OTP) even from Secure code, once it is done.
5.2.7. Flash boot
The bootrom scans flash up to 16 times until it finds a valid IMAGE_DEF  or PARTITION_TABLE . At this point, the flash settings
are considered valid, and the flash boot proceeds if a valid bootable IMAGE_DEF  is found with these settings. It uses the
following combinations of flash read instruction and SCK divisor for the 16 attempts:
Table 452. QSPI read
modes supported by
the bootrom, in the
order it attempts
them.Mode Clock Divisor
EBh quad 3
BBh dual 3
0Bh serial 3
03h serial 3
EBh quad 6
BBh dual 6
0Bh serial 6
03h serial 6
EBh quad 12
BBh dual 12
0Bh serial 12
03h serial 12
EBh quad 24
BBh dual 24
0Bh serial 24
03h serial 24
QSPI does not provide a reliable method to detect whether a device is attached. However, this is not much of an issue
for boot purposes: either there is a device with valid and bootable contents, or there are no such contents (either due to
lack of a connected device, invalid device contents, or failure to communicate in the current QSPI mode).
When there is no device (or no recognisable contents), the bootrom tries all 16 modes in Table 452  before finally giving
up. The size of the initial search region is limited to 4 kB to minimise the time spent scanning flash before falling
through to USB or UART boot. This same 4 kB limit also applies to search within a flash partition , which allows the
bootrom to reliably sever the contained image’s block loop with a single 4 kB sector erase at the start of a partition,
such as on a version downgrade .
There are three main ways that the bootrom locates flash images:
RP2350 Datasheet
5.2. Processor-controlled boot sequence 373
Flash image boot
A flash image can be written directly to flash storage address 0x0, and the bootrom will find it from there. This is the
most similar to flash boot on RP2040 (the main differences being the removal of a boot2 in the first 256 bytes of the
image, and the new requirement for a valid image definition  anywhere within the first 4 kB of the image).
Flash partition boot
A flash image can be written into a partition of a partition table . The partition table is described by a PARTITION_TABLE 
block stored at the start of flash. The bootrom finds the partition table and scans its partitions to look for bootable
images.
Partition-table-in-image boot
A flash image containing an IMAGE_DEF  and PARTITION_TABLE  block in a single block loop  is written to the start of flash.
The bootrom loads the embedded partition table, and enters the image in the same way as the flash image boot 
case.
Revisit the linked bootrom concepts sections to get the fullest understanding of each of these three forms of flash boot.
For the purposes of this section, all that matters is whether the bootrom can discover a valid, bootable image or not. In
all three cases, the image must have a valid IMAGE_DEF , and meet all relevant security requirements such as being
correctly signed , and having a rollback version  greater than or equal to the one stored in OTP.
The bootrom enters the flash image in whatever QSPI mode it discovered to work during flash programming. Any
further setup (such as prefixless continuous read modes) is performed by the flash image itself. This setup code,
referred to as an XIP setup function , is usually copied into RAM before execution to avoid running from flash whilst the
XIP interface is being reconfigured.
TIP
The PICO_EMBED_XIP_SETUP=1  flag in the SDK enables inclusion and execution of an XIP setup function on RP2350
builds. In this case the function executes on the core 0 stack during early startup, so no additional static memory
need be allocated. This is not the case for subsequent calls, because the stack is often not executable post-startup.
You should save your XIP setup function in the first 256 bytes of boot RAM to make it easily locatable when the XIP
mode is re-initialised following a serial flash programming operation which had to drop out of XIP mode. The bootrom
writes a default XIP setup function to this address before entering the flash image, which restores the mode the
bootrom discovered during flash programming.
NOTE
You cannot execute an XIP setup function directly from boot RAM, because boot RAM is never executable. You must
copy it into SRAM before execution.
XIP setup functions should be fully position-independent, and no more than 256 bytes in size. If you are unable to meet
these requirements, you should install a stub function which calls your XIP setup function elsewhere in RAM.
5.2.8. BOOTSEL (USB/UART) boot
The bootrom samples the state of QSPI CSn shortly after reset. Based on the result, the bootrom decides whether to
enter BOOTSEL mode, which refers collectively to the USB and UART bootloaders.
The bootrom initialises the chip select to the following state:
•Output disabled
•Pulled high (note CSn is an active-low signal, so this deselects the external QSPI device if there is one)
If the chip select remains high, the bootrom continues with its normal, non-BOOTSEL sequence. By default on a blank
device, this means driving the chip select low and attempting to boot from an external flash or PSRAM device.
If chip select is driven low externally, the bootrom enters BOOTSEL mode. You must drive the chip select low with a
RP2350 Datasheet
5.2. Processor-controlled boot sequence 374
sufficiently low impedance to overcome the internal pull-up. A 4.7 kΩ resistance to ground is a good intermediate value
which reliably creates a low input logic level, but will not affect the output levels when RP2350 drives the chip select.
The QSPI SD1 line, which RP2350 initially pulls low, selects which bootloader to enter:
•SD1 remains pulled low: enter USB bootloader
•SD1 driven high: enter UART bootloader
USB boot is a low-friction method for programming an RP2350 from a sophisticated host like a Linux PC. It also directly
exposes more advanced options like OTP programming. See Section 5.5  for the drag-and-drop mass storage interface,
or Section 5.6  for the PICOBOOT vendor interface.
UART boot is a minimal interface for bootstrapping a flashless RP2350 from another microcontroller. UART boot uses
QSPI SD2 for UART TX, and QSPI SD3 for UART RX, at a fixed baud rate of 1 Mbaud. For more details about UART boot,
see Section 5.8 .
5.2.8.1. BOOTSEL clock requirements
BOOTSEL mode requires either a crystal attached across the XIN and XOUT pins, or a clock signal from an external
oscillator driven into the XIN pin. See Table 1439  for the electrical specifications of these two XOSC pins.
The bootrom assumes a default XOSC frequency of 12 MHz. It configures the USB PLL to derive a fixed 48 MHz
frequency from the XOSC reference. For USB, this must be a precise frequency. If you use a non-12 MHz crystal, and
intend to use USB boot, program BOOTSEL_PLL_CFG  and BOOTSEL_XOSC_CFG  in OTP, and then set
BOOT_FLAGS0 .ENABLE_BOOTSEL_NON_DEFAULT_PLL_XOSC_CFG. For details about calculating the correct PLL
parameters for your crystal, see Section 8.6.3 .
UART boot uses the same PLL configuration as USB boot. However, the permissible range of crystal frequencies under
the default PLL configuration is wider. See Section 5.8.1 .
5.2.9. Boot configuration (OTP)
User configuration stored in OTP can be found in Section 13.10 , starting at CRIT1 .
The main controls for the bootrom are stored in BOOT_FLAGS0  and BOOT_FLAGS1 . These are both in page 1 of OTP,
which has the following default permissions on a blank device:
•Read-write for Secure ( S)
•Read-write for bootloader ( BL)
•Read-only for Non-secure ( NS)
Boot key hashes are stored in page 2 of OTP, starting from BOOTKEY0_0 . There is space for up to four boot key hashes
in this page. See Section 5.10.1  for an example of how keys can be installed.
5.3. Launching code on Processor Core 1
As described in Section 5.2 , after reset, processor core 1 sleeps at start-up, and remains asleep until woken by core 0
via the SIO FIFOs.
If you are using the SDK then you can use the multicore_launch_core1()  function to launch code on processor core 1.
However this section describes the procedure to launch code on processor core 1 yourself.
The procedure to start running on processor core 1 involves both cores moving in lockstep through a state machine
coordinated by passing messages over the inter-processor FIFOs. This state machine is designed to be robust enough
to cope with a recently reset processor core 1 which may be anywhere in its boot code, up to and including going to
sleep. As result, the procedure may be performed at any point after processor core 1 has been reset (either by system
RP2350 Datasheet
5.3. Launching code on Processor Core 1 375
reset, or explicitly resetting just processor core 1).
The following C code describes the procedure:
// values to be sent in order over the FIFO from core 0 to core 1
//
// vector_table is value for VTOR register
// sp is initial stack pointer (SP)
// entry is the initial program counter (PC) (don't forget to set the thumb bit!)
const uint32_t  cmd_sequence [] =
        {0, 0, 1, (uintptr_t ) vector_table , (uintptr_t ) sp, (uintptr_t ) entry};
uint seq = 0;
do {
    uint cmd = cmd_sequence [seq];
    // always drain the READ FIFO (from core 1) before sending a 0
    if (!cmd) {
        // discard data from read FIFO until empty
        multicore_fifo_drain ();
        // execute a SEV as core 1 may be waiting for FIFO space
        __sev();
    }
    // write 32 bit value to write FIFO
    multicore_fifo_push_blocking (cmd);
    // read 32 bit value from read FIFO once available
    uint32_t  response  = multicore_fifo_pop_blocking ();
    // move to next state on correct response (echo-d value) otherwise start over
    seq = cmd == response  ? seq + 1 : 0;
} while (seq < count_of (cmd_sequence ));
5.4. Bootrom APIs
Whilst some ROM space is dedicated to the implementation of the boot sequence and USB/UART boot interfaces, the
bootrom also contains public functions that provide useful RP2350 functionality that may be useful for any code or
runtime running on the device.
A categorised list is available in Section 5.4.6 .
The full alphabetical list is available in Section 5.4.7 .
5.4.1. Locating the API functions
The API functions are normally made available to the user by wrappers in the SDK. However, a lower level method is
provided to locate them (since their locations may change with each bootrom release) for other runtimes, or those who
wish to locate them directly.
Table 453  shows the fixed memory layout of certain words in the bootrom used to locate these functions when using
the Arm architecture. Table 454  shows the additional entries for use when using the RISC-V architecture.
Table 453. Bootrom
contents at fixed (well
known) addresses for
Arm codeAddress Contents Description
0x00000000 32-bit pointer Initial boot stack pointer
0x00000004 32-bit pointer Pointer to boot reset handler function
0x00000008 32-bit pointer Pointer to boot NMI handler function
0x0000000c 32-bit pointer Pointer to boot Hard fault handler function
RP2350 Datasheet
5.4. Bootrom APIs 376
Address Contents Description
0x00000010 'M', 'u', 0x02 Magic
0x00000013 byte Bootrom version
0x00000014 16-bit pointer Pointer to ROM entry table ( BOOTROM_ROMTABLE_START )
0x00000016 16-bit pointer Pointer to a helper function ( rom_table_lookup_val() )
0x00000018 16-bit pointer Pointer to a helper function ( rom_table_lookup_entry() )
Table 454. Bootrom
contents at fixed (well
known) addresses for
RISC-V codeAddress Contents Description
0x00007df6 16-bit pointer Pointer to ROM entry table ( BOOTROM_ROMTABLE_START )
0x00007df8 16-bit pointer Pointer to a helper function ( rom_table_lookup_val() )
0x00007dfa 16-bit pointer Pointer to a helper function ( rom_table_lookup_entry() )
0x00007dfc 32-bit instruction RISC-V Entry Point
Assuming the three bytes starting at address 0x00000010  are ( 'M', 'u', 0x02), the other fixed location fields can be
assumed to be valid and used to lookup bootrom functionality.
The version byte at offset 0x00000013  is informational, and should not be used to infer the exact location of any
functions. It has the value 2 for A2 silicon.
The following code from the SDK shows how the SDK looks up a bootrom function:
static __force_inline  void *rom_func_lookup_inline (uint32_t  code) {
#ifdef __riscv
    // on RISC-V the code (a jmp) is actually embedded in the table
    rom_table_lookup_fn  rom_table_lookup  =
        (rom_table_lookup_fn ) (uintptr_t )*(uint16_t *)(BOOTROM_TABLE_LOOKUP_ENTRY_OFFSET
        + rom_offset_adjust );
    return rom_table_lookup (code, RT_FLAG_FUNC_RISCV );
#else
    // on Arm the function pointer is stored in the table, so we dereference it
    // via lookup() rather than lookup_entry()
    rom_table_lookup_fn  rom_table_lookup  =
        (rom_table_lookup_fn ) (uintptr_t )*(uint16_t *)(BOOTROM_TABLE_LOOKUP_OFFSET );
    if (pico_processor_state_is_nonsecure ()) {
        return rom_table_lookup (code, RT_FLAG_FUNC_ARM_NONSEC );
    } else {
        return rom_table_lookup (code, RT_FLAG_FUNC_ARM_SEC );
    }
#endif
}
As well as API functions, there are a few data values that can be looked up. The following code demonstrates:
void *rom_data_lookup (uint32_t  code) {
    rom_table_lookup_fn  rom_table_lookup  =
        (rom_table_lookup_fn ) (uintptr_t )*(uint16_t *)(BOOTROM_TABLE_LOOKUP_OFFSET );
    return rom_table_lookup (code, RT_FLAG_DATA );
}
The code parameter correspond to the CODE values in the tables below, and is calculated as follows:
RP2350 Datasheet
5.4. Bootrom APIs 377
uint32_t  rom_table_code (char c1, char c2) {
   return (c2 << 8) | c1;
}
These codes are also available in bootrom.h  in the SDK  as #defines .
5.4.2. API function availability
Some functions are not available under all architectures or security levels. The API listing in Section 5.4.6  uses the
following terms to list the availability of each individual API entry point:
Arm-S
The function is available to Secure Arm code. The majority of functions are available for Arm-S unless they deal
specifically with RISC-V or Non-secure functionality.
RISC-V
The function is available to RISC-V code. Most of the functions that are available under Arm-S are also exposed
under RISC-V unless they deal specifically with Arm security states.
Arm-NS
The function is available to Non-secure Arm code. The function in this case performs additional permission and
argument checks to prevent Secure data from leaking or being corrupted.
Each individual Arm-NS API function must be explicitly enabled by Secure code before use, via set_ns_api_permission() . A
disabled Non-secure API returns BOOTROM_ERROR_NOT_PERMITTED  if disabled by Secure code. All Non-secure APIs are
disabled initially. There is no permission control on Non-secure code calling Secure-only Arm-S functions, but such a call
will crash when it attempts to access Secure-only hardware.
The Arm-NS functions may escalate through a Secure Gateway (SG) instruction to allow Non-secure code to perform
limited operations on nominally Secure-only hardware, such as QSPI direct-mode interface used for flash programming.
The RISC-V functions do not have separate entry points based on privilege level. Both M-mode and U-mode software can
call bootrom APIs, assuming they have execute permissions on ROM addresses in the PMP. However, U-mode calls will
crash if they attempt to access M-mode-only hardware.
5.4.3. API function return codes
Some functions do not support returning any error, and are marked void. The remainder return either 0 ( BOOTROM_OK ) or a
positive value (if data needs to be returned) for success. These bootrom error codes are identical to the error codes
used by the SDK, so they can be used interchangeably. This explains the gaps in the numbering for SDK error codes that
aren’t used by the bootrom.
Name Value Description
value >= 0 The function succeeded and returned the value
BOOTROM_OK 0 The function executed successfully
BOOTROM_ERROR_NOT_PERMITTED -4 The operation was disallowed by a security constraint
BOOTROM_ERROR_INVALID_ARG -5 One or more parameters passed to the function is outside
the range of supported values;
BOOTROM_ERROR_INVALID_ADDRESS and
BOOTROM_ERROR_BAD_ALIGNMENT are more specific
errors.
RP2350 Datasheet
5.4. Bootrom APIs 378
Name Value Description
BOOTROM_ERROR_INVALID_ADDRESS -10 An address argument was out-of-bounds or was
determined to be an address that the caller may not
access.
BOOTROM_ERROR_BAD_ALIGNMENT -11 An address passed to the function was not correctly
aligned.
BOOTROM_ERROR_INVALID_STATE -12 Something happened or failed to happen in the past, and
consequently the request cannot currently be serviced.
BOOTROM_ERROR_BUFFER_TOO_SMALL -13 A user-allocated buffer was too small to hold the result or
working state of the function.
BOOTROM_ERROR_PRECONDITION_NOT_MET -14 The call failed because another bootrom function must be
called first.
BOOTROM_ERROR_MODIFIED_DATA -15 Cached data was determined to be inconsistent with the
full version of the data it was copied from.
BOOTROM_ERROR_INVALID_DATA -16 The contents of a data structure are invalid
BOOTROM_ERROR_NOT_FOUND -17 An attempt was made to access something that does not
exist; or, a search failed.
BOOTROM_ERROR_UNSUPPORTED_MODIFICATION -18 Modification is impossible based on current state. This
might occur, for example, when attempting to clear an
OTP bit.
BOOTROM_ERROR_LOCK_REQUIRED -19 A required lock is not owned. See Section 5.4.4 .
5.4.4. API functions and exclusive access
Various bootrom functions require access to parts of the system which:
•cannot be safely accessed by both cores at once, or
•limit the functionality of other hardware when in use
For example:
•Programming OTP: it is not possible to read from the memory mapped OTP data regions at the same time as
accessing its serial programming interface.
•Use of the SHA-256 block: only one SHA-256 sum can be in progress at a time.
•Using the QSPI direct-mode interface to program the flash causes XIP access to return a bus fault.
It is beyond the purview of the bootrom to implement a locking strategy, as the style and scope of the locking required
is entirely up to how the application itself uses these resources.
Nevertheless, it is important that, say, a Non-secure call to a flash programming API can’t cause a hard fault in other
Secure code running from flash. There must be some way for user software to coordinate with bootrom APIs on such
changes of state. The bootrom implements the mechanism  but not the policy  for mutual exclusion over bootrom API
calls.
The solution the bootrom provides is to use the boot locks (boot RAM registers BOOTLOCK0  through BOOTLOCK7 ) to
inform the bootrom which resources are currently owned by the caller and therefore safe for it to use.
To enable lock checking in bootrom APIs, set boot lock 7 (LOCK_ENABLE ) to the claimed state. When enabled, bootrom
functions which use certain hardware resources (listed below) will check the status of the boot lock assigned to that
resource, and return BOOTROM_ERROR_LOCK_REQUIRED  if that lock is not in the claimed state.
Before calling a bootrom function with locking enabled, you must claim the relevant locks. It may take multiple attempts
RP2350 Datasheet
5.4. Bootrom APIs 379
to claim if the API is concurrently accessed from other contexts. Follow the same steps as the SIO spinlocks ( Section
3.1.4 ) to claim a lock.
The following boot locks are assigned:
•0x0 : LOCK_SHA_256  - if owned, then a bootrom API is allowed to use the SHA-256 block
•0x1 : LOCK_FLASH_OP  - if owned, then a bootrom API is allowed to enter direct mode on the QSPI memory interface
(Section 12.14.5 ) in order to perform low-level flash operations
•0x2 : LOCK_OTP  - if owned, then a bootrom API is allowed to access OTP via the serial interface
•0x7 : LOCK_ENABLE  - if owned, then bootrom API resource ownership checking is enabled. This is off by default, since
the bootrom APIs aim to be usable by default without additional setup.
5.4.5. SDK access to the API
Bootrom functions are exposed in the SDK via the pico_bootrom  library (see pico_bootrom ).
Each bootrom function has a rom_ wrapper function that looks up the bootrom function address and calls it.
The SDK provides a simple implementation of exclusive access via bootrom_acquire_lock_blocking(n)  and
bootrom_release_lock(n) . When enabled, as it is by default ( PICO_BOOTROM_LOCKING_ENABLED=1  is defined) the SDK enables
bootrom locking via LOCK_ENABLE , and these two functions use the other SHA_256/FLASH_OP /OTP boot locks to take ownership
of/release ownership of the corresponding bootrom resource.
The rom_ wrapper functions the SDK call bootrom_acquire_lock_locking  and bootrom_relead_lock  functions around bootrom
calls that have locking requirements.
5.4.6. Categorised list of API functions and ROM data
The terms in parentheses after each function name ( Arm-S, Arm-NS, RISC-V) indicate the architecture and security state
combinations where that API is available:
•Arm-S: Arm processors running in the Secure state
•Arm-NS: Arm processors running in the Non-secure state
•RISC-V: RISC-V processors
See Section 5.4.2  for the full definitions of these terms.
List entries ending with parentheses, such as flash_op() , are callable functions. List entries without parentheses, such
as git_revision , are pointers to ROM data locations.
5.4.6.1. Low-level Flash access
These low-level (Secure-only) flash access functions are similar to the ones on RP2040:
•connect_internal_flash()  (Arm-S, RISC-V)
•flash_enter_cmd_xip()  (Arm-S, RISC-V)
•flash_exit_xip()  (Arm-S, RISC-V)
•flash_flush_cache()  (Arm-S, RISC-V)
•flash_range_erase()  (Arm-S, RISC-V)
•flash_range_program()  (Arm-S, RISC-V)
These are new with RP2350:
RP2350 Datasheet
5.4. Bootrom APIs 380
•flash_reset_address_trans()  (Arm-S, RISC-V)
•flash_select_xip_read_mode()  (Arm-S, RISC-V)
5.4.6.2. High-level flash access
The higher level access functions, provide functionality that is safe to expose (with permissions) to Non-secure code as
well.
•flash_op()  (Arm-S, Arm-NS, RISC-V)
•flash_runtime_to_storage_addr()  (Arm-S, Arm-NS, RISC-V)
5.4.6.3. System information
•flash_devinfo16_ptr  (Arm-S, RISC-V)
•get_partition_table_info()  (Arm-S, Arm-NS RISC-V)
•get_sys_info()  (Arm-S, Arm-NS, RISC-V)
•git_revision  (Arm-S, Arm-NS, RISC-V)
5.4.6.4. Partition tables
•get_b_partition()  (Arm-S, RISC-V)
•get_uf2_target_partition()  (Arm-S, RISC-V)
•pick_ab_partition()  (Arm-S, RISC-V)
•partition_table_ptr  (Arm-S`, RISC-V)
•load_partition_table()  (Arm-S, RISC-V)
5.4.6.5. Bootrom memory and state
•set_bootrom_stack()  (RISC-V)
•xip_setup_func_ptr  (Arm-S, RISC-V)
•bootrom_state_reset()  (Arm-S, RISC-V)
5.4.6.6. Executable image management
•chain_image()  (Arm-S, RISC-V)
•(explicit_buy()  (Arm-S, RISC-V)
5.4.6.7. Security
These Secure-only functions control access for Non-secure code:
•set_ns_api_permission()  (Arm-S)
•set_rom_callback()  (Arm-S, RISC-V)
•validate_ns_buffer()  (Arm-S, RISC-V)
RP2350 Datasheet
5.4. Bootrom APIs 381
5.4.6.8. Miscellaneous
These functions are provided to all platforms and security levels, but perform additional checks when called from Non-
secure Arm code:
•reboot()  (Arm-S, Arm-NS, RISC-V)
•otp_access()  (Arm-S, Arm-NS, RISC-V)
5.4.6.9. Non-secure only
•secure_call()  (Arm-NS)
5.4.6.10. Bit manipulation
Unlike RP2040, the bootrom doesn’t contain bit manipulation functions. Processors on RP2350 implement hardware
instructions for these operations which are far faster than the software implementations in the RP2040 bootrom.
5.4.6.11. Memcpy and Memset
Unlike RP2040, the bootrom doesn’t provide memory copy or clearing functions, as your language runtime is expected
to already provide well-performing implementations of these on Cortex-M33 or Hazard3.
The bootrom does contain private implementations of standard C memcpy()  and memset() , for both Arm and RISC-V, but
these are optimised for size rather than performance. They are not exported in the ROM table.
5.4.6.12. Floating point
Unlike RP2040 the bootrom doesn’t contain functions for floating point arithmetic. On Arm there is standard processor
support for single-precision arithmetic via the Cortex-M FPU, and RP2350 provides an Arm coprocessor which
dramatically accelerates double-precision arithmetic (the DCP, Section 3.6.2 ). The SDK defaults to the most performant
hardware or software implementation available.
5.4.7. Alphabetical list of API functions and ROM data
•bootrom_state_reset()  (Arm-S, RISC-V)
•chain_image()  (Arm-S, RISC-V)
•connect_internal_flash()  (Arm-S, RISC-V)
•flash_devinfo16_ptr  (Arm-S, RISC-V)
•flash_enter_cmd_xip()  (Arm-S, RISC-V)
•flash_exit_xip()  (Arm-S, RISC-V)
•flash_flush_cache()  (Arm-S, RISC-V)
•flash_op()  (Arm-S, Arm-NS, RISC-V)
•flash_range_erase()  (Arm-S, RISC-V)
•flash_range_program()  (Arm-S, RISC-V)
•flash_reset_address_trans()  (Arm-S, RISC-V)
•flash_runtime_to_storage_addr()  (Arm-S, Arm-NS, RISC-V)
RP2350 Datasheet
5.4. Bootrom APIs 382
•flash_select_xip_read_mode()  (Arm-S, RISC-V)
•get_b_partition()  (Arm-S, RISC-V)
•get_partition_table_info()  (Arm-S, Arm-NS RISC-V)
•get_sys_info()  (Arm-S, Arm-NS, RISC-V)
•get_uf2_target_partition()  (Arm-S, RISC-V)
•git_revision  (Arm-S, Arm-NS, RISC-V)
•load_partition_table()  (Arm-S, RISC-V)
•otp_access()  (Arm-S, Arm-NS, RISC-V)
•partition_table_ptr  (Arm-S`, RISC-V)
•pick_ab_partition()  (Arm-S, RISC-V)
•reboot()  (Arm-S, Arm-NS, RISC-V)
•secure_call()  (Arm-NS)
•set_bootrom_stack()  (RISC-V)
•set_ns_api_permission()  (Arm-S)
•set_rom_callback()  (Arm-S, RISC-V)
•validate_ns_buffer()  (Arm-S, RISC-V)
•xip_setup_func_ptr  (Arm-S, RISC-V)
5.4.8. API function listings
5.4.8.1. bootrom_state_reset
Code: 'S','R'
Signature: void bootrom_state_reset(uint32_t flags)
Supported architectures: Arm-S, RISC-V
Resets internal bootrom state, based on the following flags:
•0x0001 : STATE_RESET_CURRENT_CORE  - Resets any internal bootrom state for the current core to a known state. This
method should be called prior to calling any other bootrom APIs on the current core, and is called automatically by
the bootrom during normal boot of core 0 or launch of code on core 1.
•0x0002 : STATE_RESET_OTHER_CORE  - Resets any internal bootrom state for the other core into a clean state. This is
generally called by a debugger when resetting the state of one core via code running on the other.
•0x0004 : STATE_RESET_GLOBAL_STATE  - Resets all non core-specific state, including:
◦Disables access to bootrom APIs from Arm-NS (see also set_ns_api_permission() ).
◦Unlocks all boot locks ( Section 5.4.4 ).
◦Clears any Secure code callbacks. (see also set_rom_callback() )
Note that the SDK calls this method on runtime initialisation to put the boot RO into a known state. This allows the
program to function correctly if it is entered via a debugger, or otherwise without taking the usual boot path through the
bootrom, which itself would reset the state.
RP2350 Datasheet
5.4. Bootrom APIs 383
5.4.8.2. chain_image
Code: 'C','I'
Signature: int chain_image(uint8_t *workarea_base, uint32_t workarea_size, int32_t region_base, uint32_t region_size)
Supported architectures: Arm-S, RISC-V. Note on RISC-V this function may require additional stack; see Section 5.4.8.26 .
Returns: BOOTROM_OK  (0) on success, or a negative error code on error.
Searches a memory region for a launchable image, and executes it if possible.
The region_base  and region_size  specify a word-aligned, word-multiple-sized area of RAM, XIP RAM or flash to search.
The first 4 kB of the region must contain the start of a block loop with an IMAGE_DEF . If the new image is launched, the call
does not return otherwise an error is returned.
The region_base  is signed, as a negative value can be passed, which indicates that the (negated back to positive value) is
both  the region_base and the base of the "flash update" region.
This method potentially requires similar complexity to the boot path in terms of picking amongst versions, checking
signatures etc. As a result it requires a user provided memory buffer as a work area. The work area should be word
aligned, and of sufficient size or BOOTROM_ERROR_BAD_ALIGNMENT  / BOOTROM_ERROR_INSUFFICIENT_RESOURCES  will be returned. The
work area size currently required is 3064, so 3 kB is a good choice.
This method is primarily expected to be used when implementing bootloaders.
NOTE
When chaining into an image, the BOOT_FLAGS0 .ROLLBACK_REQUIRED flag will not be set, to prevent invalidating a
bootloader without a rollback version by booting a binary which has one (see Section 5.10.8 ).
5.4.8.3. connect_internal_flash
Code: 'I','F'
Signature: void connect_internal_flash(void)
Supported architectures: Arm-S, RISC-V
Restores all QSPI pad controls to their default state, and connects the QMI peripheral to the QSPI pads.
If a secondary flash chip select GPIO has been configured via OTP FLASH_DEVINFO , or by writing to the runtime copy of
FLASH_DEVINFO  in boot RAM, then this bank 0 GPIO is also initialised and the QMI peripheral is connected. Otherwise, bank
0 IOs are untouched.
5.4.8.4. explicit_buy
Code: 'E','B'
Signature: int explicit_buy(uint8_t *buffer, uint32_t buffer_size)
Supported architectures: Arm-S RISC-V
Returns: BOOTROM_OK  (0) on success, negative error code on error.
Perform an "explicit buy" of an executable launched via an IMAGE_DEF  which was TBYB ( Section 5.1.17 ) flagged. A "flash
update" boot of such an image is a way to have the image execute once, but only become the "current" image if it safely
calls back into the bootrom via this call.
This call may perform the following:
•Erase and rewrite the part of flash containing the TBYB flag in order to clear said flag.
RP2350 Datasheet
5.4. Bootrom APIs 384
•Erase the first sector of the other partition in an A/B partition scenario, if this new IMAGE_DEF  is a version downgrade
(so this image will boot again when not doing a normal boot)
•Update the rollback version in OTP if the chip is secure, and a rollback version is present in the image.
The first of the above requires 4 kB of scratch space, so you should pass a word aligned buffer of at least 4 kB to this
method in this case, or BOOTROM_ERROR_BAD_ALIGNMENT  / BOOTROM_ERROR_INSUFFICIENT_RESOURCES  will be returned.
The device might reboot while updating the rollback version if multiple rollback rows need to be written. This occurs
when the version crosses a multiple of 24 (for example, upgrading from version 23 to 25 requires a reboot, but 23 to 24
or 24 to 25 doesn’t). The application must therefore be prepared to reboot when calling this function if rollback versions
are in use.
5.4.8.5. flash_devinfo16-ptr
Code: 'F','D'
Type: uint16_t *flash_devinfo16_ptr
Pointer to the flash device info used by the flash APIs, for example, for bounds checking against size of flash devices,
and configuring the GPIO used for secondary QSPI chip select.
If BOOT_FLAGS0 .FLASH_DEVINFO_ENABLE is set, this boot RAM location is initialised from FLASH_DEVINFO  at startup,
otherwise it is initialised to:
•Chip select 0 size: 16 MB
•Chip select 1 size: 0 bytes
•No chip select 1 GPIO
•No D8h erase command support
The flash APIs use this boot RAM copy of FLASH_DEVINFO , so flash device info can updated by Secure code at runtime by
writing through this pointer.
5.4.8.6. flash_enter_cmd_xip
Code: 'C','X'
Signature: void flash_enter_cmd_xip(void)
Supported architectures: Arm-S, RISC-V
Compatibility alias for flash_select_xip_read_mode(0, 12); .
Configure the QMI to generate a standard 03h serial read command, with 24 address bits, upon each XIP access. This is
a slow XIP configuration, but is widely supported. CLKDIV is set to 12. The debugger may call this function to ensure
that flash is readable following a program/erase operation.
Note that the same setup is performed by flash_exit_xip() , and the RP2350 flash program/erase functions do not leave
XIP in an inaccessible state, so calls to this function are largely redundant. It is provided for compatibility with RP2040.
5.4.8.7. flash_exit_xip
Code: 'E','X'
Signature: void flash_exit_xip(void)
Supported architectures: Arm-S, RISC-V
Initialise the QMI for serial operations (direct mode), and also initialise a basic XIP mode, where the QMI will perform
03h serial read commands at low speed (CLKDIV=12) in response to XIP reads.
RP2350 Datasheet
5.4. Bootrom APIs 385
Then, issue a sequence to the QSPI device on chip select 0, designed to return it from continuous read mode ("XIP
mode") and/or QPI mode to a state where it will accept serial commands. This is necessary after system reset to
restore the QSPI device to a known state, because resetting RP2350 does not reset attached QSPI devices. It is also
necessary when user code, having already performed some continuous-read-mode or QPI-mode accesses, wishes to
return the QSPI device to a state where it will accept the serial erase and programming commands issued by the
bootrom’s flash access functions.
If a GPIO for the secondary chip select is configured via FLASH_DEVINFO , then the XIP exit sequence is also issued to chip
select 1.
The QSPI device should be accessible for XIP reads after calling this function; the name flash_exit_xip  refers to
returning the QSPI device  from its XIP state to a serial command state.
5.4.8.8. flash_flush_cache
Code: 'F','C'
Signature: void flash_flush_cache(void)
Supported architectures: Arm-S, RISC-V
Flush the entire XIP cache, by issuing an invalidate by set/way maintenance operation to every cache line ( Section
4.4.1 ). This ensures that flash program/erase operations are visible to subsequent cached XIP reads.
Note that this unpins pinned cache lines, which may interfere with cache-as-SRAM use of the XIP cache.
No other operations are performed.
5.4.8.9. flash_op
Code: 'F','O'
Signature: int flash_op(uint32_t flags, uint32_t addr, uint32_t size_bytes, uint8_t *buf)
Supported architectures: Arm-S, Arm-NS, RISC-V
Returns: BOOTROM_OK  (0) on success, negative error code on error.
Perform a flash read, erase, or program operation. Erase operations must be sector-aligned (4096 bytes) and sector-
multiple-sized, and program operations must be page-aligned (256 bytes) and page-multiple-sized; misaligned erase
and program operations will return BOOTROM_ERROR_BAD_ALIGNMENT . The operation — erase, read, program — is selected by
the CFLASH_OP_BITS  bitfield of the flags argument:
flags is comprised of the following values:
Address Translation  (select one)
0x00000000 No address translation; addr arg is the actual flash storage addresses.
0x00000001 Runtime address translation; addr arg is XIP memory address affected by address translation.
Security level  (select one)
0x00000100 Perform the operation using secure  permissions. This is disallowed for a non-secure caller.
0x00000200 Perform the operation using non-secure  permissions.
0x00000300 Perform the operation using boot-loader  permissions. This is disallowed for a non-secure
caller.
Operation  (select one)
0x00000000 Erase size_bytes  bytes of flash, starting at address addr. Both addr and size_bytes  must be a
multiple of 4096 bytes (one flash sector).
RP2350 Datasheet
5.4. Bootrom APIs 386
0x00010000 Program size_bytes  bytes of flash, starting at address addr. Both addr and size_bytes  must be a
multiple of 256 bytes (one flash page).
0x00020000 Read size_bytes  bytes of flash, starting at address addr. There are no alignment restrictions on
addr or size_bytes .
These constants are also available in bootrom_constants.h  in the SDK  as #defines .
addr is the address of the first flash byte to be accessed, ranging from XIP_BASE  to XIP_BASE  + 0x1ffffff  inclusive. This may
be a runtime or storage address. buf contains data to be written to flash, for program operations, and data read back
from flash, for read operations. buf is never written by program operations, and is completely ignored for erase
operations.
The flash operation is bounds-checked against the known flash devices specified by the runtime value of FLASH_DEVINFO ,
stored in boot RAM. This is initialised by the bootrom to the OTP value FLASH_DEVINFO , if
BOOT_FLAGS0 .FLASH_DEVINFO_ENABLE is set; otherwise it is initialised to 16 MB for chip select 0 and 0 bytes for chip
select 1. FLASH_DEVINFO  can be updated at runtime by writing to its location in boot RAM, the pointer to which can be
looked up in the ROM table.
If a resident partition table is in effect, then the flash operation is also checked against the partition permissions. The
Secure version of this function can specify the caller’s effective security level (Secure, Non-secure, bootloader) using
the CFLASH_SECLEVEL_BITS  bitfield of the flags argument, whereas the Non-secure function is always checked against the
Non-secure permissions for the partition. Flash operations which span two partitions are not allowed, and will fail
address validation.
If FLASH_DEVINFO .D8H_ERASE_SUPPORTED is set, erase operations will use a D8h 64 kB block erase command where
possible (without erasing outside the specified region), for faster erase time. Otherwise, only 20h 4 kB sector erase
commands are used.
Optionally, this API can translate addr from flash runtime addresses to flash storage addresses, according to the
translation currently configured by QMI address translation registers, ATRANS0  through ATRANS7 . For example, an
image stored at a +2 MB offset in flash (but mapped at XIP address 0 at runtime), writing to an offset of +1 MB into the
image, will write to a physical flash storage address of 3 MB. Translation is enabled by setting the corresponding bitfield
in the flags argument.
When translation is enabled, flash operations that cross address holes in the XIP runtime address space (created by
non-maximum ATRANSx_SIZE ) will return an error response. This check may tear: the transfer may be partially performed
before encountering an address hole and ultimately returning failure.
When translation is enabled, flash operations are permitted to cross chip select boundaries, provided this does not span
an ATRANS address hole. When translation is disabled, the entire operation must target a single flash chip select (as
determined by bits 24 and upward of the address), else address validation will fail.
A typical call sequence for erasing a flash sector in the runtime address space from Secure code would be:
•connect_internal_flash();
•flash_exit_xip();
•flash_op((CFLASH_OP_VALUE_ERASE << CFLASH_OP_LSB) | (CFLASH_SECLEVEL_VALUE_SECURE << CFLASH_SECLEVEL_LSB) |
(CFLASH_ASPACE_VALUE_RUNTIME << CFLASH_ASPACE_LSB), addr, 4096, NULL);
•flash_flush_cache();
•Copy the XIP setup function from boot RAM to SRAM and execute it, to restore the original XIP mode
◦The bootrom will have written a default setup function which restores the mode/clkdiv parameters found
during flash search; user code can overwrite this with its own custom setup function.
A similar sequence is required for program operations. Read operations can leave the current XIP mode in effect, so
only the flash_op(… ); call is required.
Note that the RP2350 bootrom leaves the flash in a basic XIP state in between program/erase operations. However,
during a program/erase operation, the QMI is in direct mode ( Section 12.14.5 ) and any attempted XIP access will return
RP2350 Datasheet
5.4. Bootrom APIs 387
a bus error response.
5.4.8.10. flash_range_erase
Code: 'R','E'
Signature: void flash_range_erase(uint32_t addr, size_t count, uint32_t block_size, uint8_t block_cmd)
Supported architectures: Arm-S, RISC-V
Erase count bytes, starting at addr (offset from start of flash). Optionally, pass a block erase command (for example, D8h
block erase ), and the size of the block erased by this command — this function will use the larger block erase where
possible, for much higher erase speed. addr must be aligned to a 4096-byte sector, and count must be a multiple of 4096
bytes.
This is a low-level flash API, and no validation of the arguments is performed. See flash_op()  for a higher-level API which
checks alignment, flash bounds and partition permissions, and can transparently apply a runtime-to-storage address
translation.
The QSPI device must be in a serial command state before calling this API, which can be achieved by calling
connect_internal_flash()  followed by flash_exit_xip() . After the erase, the flash cache should be flushed via
flash_flush_cache()  to ensure the modified flash data is visible to cached XIP accesses.
Finally, the original XIP mode should be restored by copying the saved XIP setup function from boot RAM into SRAM,
and executing it: the bootrom provides a default function which restores the flash mode/clkdiv discovered during flash
scanning, and user programs can override this with their own XIP setup function.
For the duration of the erase operation, QMI is in direct mode ( Section 12.14.5 ) and attempting to access XIP from
DMA, the debugger or the other core will return a bus fault. XIP becomes accessible again once the function returns.
5.4.8.11. flash_range_program
Code: 'R','P'
Signature: void flash_range_program(uint32_t addr, const uint8_t *data, size_t count)
Supported architectures: Arm-S, RISC-V
Program data to a range of flash storage addresses starting at addr (offset from the start of flash) and count bytes in
size. addr must be aligned to a 256-byte boundary, and count must be a multiple of 256.
This is a low-level flash API, and no validation of the arguments is performed. See flash_op()  for a higher-level API which
checks alignment, flash bounds and partition permissions, and can transparently apply a runtime-to-storage address
translation.
The QSPI device must be in a serial command state before calling this API — see notes on flash_range_erase() .
5.4.8.12. flash_reset_address_trans
Code: 'R','A'
Signature: void flash_reset_address_trans(void)
Supported architectures: Arm-S, RISC-V
Restore the QMI address translation registers, ATRANS0  through ATRANS7 , to their reset state. This makes the runtime-
to-storage address map an identity map, meaning the mapped and unmapped address are equal, and the entire space is
fully mapped. See Section 12.14.4 .
RP2350 Datasheet
5.4. Bootrom APIs 388
5.4.8.13. flash_runtime_to_storage_addr
Code: 'F','A'
Signature: int flash_runtime_to_storage_addr(uint32_t addr)
Supported architectures: Arm-S, Arm-NS, RISC-V
Returns: A positive value on success (the translated address), or negative error code on error
Applies the address translation currently configured by QMI address translation registers, ATRANS0  through ATRANS7 .
See Section 12.14.4 .
Translating an address outside of the XIP runtime address window, or beyond the bounds of an ATRANSx_SIZE  field,
returns BOOTROM_ERROR_INVALID_ADDRESS , which is not a valid flash storage address. Otherwise, return the storage address
which QMI would access when presented with the runtime address addr. This is effectively a virtual-to-physical address
translation for QMI.
5.4.8.14. flash_select_xip_read_mode
Code: 'X','M'
Signature: void flash_select_xip_read_mode(bootrom_xip_mode_t mode, uint8_t clkdiv)
Supported architectures: Arm-S, RISC-V
Configure QMI for one of a small menu of XIP read modes supported by the bootrom. This mode is configured for both
memory windows (both chip selects), and the clock divisor is also applied to direct mode.
The available modes are:
•0: 03h serial read: serial address, serial data, no wait cycles
•1: 0Bh serial read: serial address, serial data, 8 wait cycles
•2: BBh dual-IO read: dual address, dual data, 4 wait cycles (including MODE bits, which are driven to 0)
•3: EBh quad-IO read: quad address, quad data, 6 wait cycles (including MODE bits, which are driven to 0)
The XIP write command/format are not configured by this function.
When booting from flash, the bootrom tries each of these modes in turn, from 3 down to 0. The first mode that is found
to work is remembered, and a default XIP setup function is written into boot RAM that calls this function 
(flash_select_xip_read_mode ) with the parameters discovered during flash scanning. This can be called at any time to
restore the flash parameters discovered during flash boot.
All XIP modes configured by the bootrom have an 8-bit serial command prefix, so that the flash device can remain in a
serial command state, meaning XIP accesses can be mixed more freely with program/erase serial operations. This has
a performance penalty, so users can perform their own flash setup after flash boot  using continuous read mode or QPI
mode to avoid or alleviate the command prefix cost.
5.4.8.15. get_b_partition
Code: 'G','B'
Signature: int get_b_partition(uint partition_a)
Supported architectures: Arm-S RISC-V
Returns: The index of the B partition of partition A if a partition table is present and loaded, and there is a partition A with
a corresponding B partition; otherwise returns BOOTROM_ERROR_NOT_FOUND .
RP2350 Datasheet
5.4. Bootrom APIs 389
5.4.8.16. get_partition_table_info
Code: 'G','P'
Signature: int get_partition_table_info(uint32_t *out_buffer, uint32_t out_buffer_word_size, uint32_t flags_and_partition)
Supported architectures: Arm-S, Arm-NS, RISC-V
Returns: >= 0 on success (the number of words filled in out_buffer), negative error code on error.
Fills a buffer with information from the partition table. Note that this API is also used to return information over the
PICOBOOT interface.
On success, the buffer is filled, and the number of words filled in the buffer is returned. If the partition table hasn’t been
loaded (for example, from a watchdog or RAM boot), this method returns BOOTROM_ERROR_PRECONDITION_NOT_MET , and you
should load the partition table through load_partition_table()  first.
Not all data from the partition table is kept resident in memory by the bootrom due to size constraints. To protect
against changes being made in flash after the bootrom has loaded the resident portion, the bootrom keeps a hash of
the partition table as of the time it loaded it. If the hash has changed by the time this method is called, then it will return
BOOTROM_ERROR_INVALID_STATE .
The information returned is chosen by the flags_and_partition parameter; the first word in the returned buffer, is the
(sub)set of those flags that the API supports. You should always check this value before interpreting the buffer.
Following the first word, returns words of data for each present flag in order. With the exception of PT_INFO, all the flags
select "per partition" information, so each field is returned in flag order for one partition after the next. The special
SINGLE_PARTITION  flag indicates that data for only a single partition is required. Flags include:
•0x0001 - PT_INFO : information about the partition table as a whole. The second two words for unpartitioned space in
the same form described in Section 5.9.4.2 .
◦Word 0 : partition_count  (low 8 bits), partition_table_present  (bit 8)
◦Word 1 : unpartitioned_space_permissions_and_location
◦Word 2 : unpartitioned_space_permissions_and_flags
•0x8000 - SINGLE_PARTITION  : only return data for a single partition; the partition number is stored in the top 8 bits of
flags_and_partition
Per-partition fields:
•0x0010 - PARTITION_LOCATION_AND_FLAGS  : the core information about a partition. The format of these fields is described
in Section 5.9.4.2 .
◦Word 0 - permissions_and_location
◦Word 1 - permissions_and_flags
•0x0020 - PARTITION_ID  : the optional 64-bit identifier for the partition. If the HAS_ID bit is set in the partition flags, then
the 64 bit ID is returned:
◦Word 0 - first 32 bits
◦Word 1 - second 32 bits
•0x0040 - PARTITION_FAMILY_IDS  : Any additional UF2 family IDs that the partition supports being downloaded into it via
the MSD bootloader beyond the standard ones flagged in the permissions_and_flags  field (see Section 5.9.4.2 ).
•0x0080 - PARTITION_NAME  : The optional name for the partition. If the HAS_NAME  field bit in permissions_and_flags  is not set,
then no data is returned for this partition; otherwise the format is as follows:
◦Byte 0 : 7 bit length of the name (LEN); top bit reserved
◦Byte 1 : first character of name
◦…
RP2350 Datasheet
5.4. Bootrom APIs 390
◦Byte LEN : last character of name
◦… (padded up to the next word boundary)
NOTE
Unpartitioned space is always reported in Word 1 as having a base offset of 0x0 and a size of 0x2000 sectors (32 MB).
The bootrom applies unpartitioned space permissions to any flash storage address that is not covered by a partition.
5.4.8.17. get_sys_info
Code: 'G','S'
Signature: int get_sys_info(uint32_t *out_buffer, uint32_t out_buffer_word_size, uint32_t flags)
Supported architectures: Arm-S, Arm-NS, RISC-V
Returns: A positive value on success (the number of words filled in out_buffer), negative error code on error.
Fills a buffer with various system information. Note that this API is also used to return information over the PICOBOOT
interface.
The information returned is chosen by the flags parameter; the first word in the returned buffer, is the (sub)set of those
flags that the API supports. You should always check this value before interpreting the buffer.
Following the first word, returns words of data for each present flag in order:
•0x0001 : CHIP_INFO  - unique identifier for the chip (3 words)
◦Word 0 : Value of the CHIP_INFO_PACKAGE_SEL  register
◦Word 1 : RP2350 device id low
◦Word 2 : RP2350 device id high
•0x0002 : CRITICAL  (1 word)
◦Word 0 : Value of the OTP CRITICAL  register, containing critical boot flags read out on last OTP reset event
•0x0004 : CPU_INFO  (1 word)
◦Word 0 : Current CPU architecture
▪0 - Arm
▪1 - RISC-V
•0x0008 : FLASH_DEV_INFO  (1 word)
◦Word 0 : Flash device info in the format of OTP FLASH_DEVINFO
•0x0010 : BOOT_RANDOM  - a 128-bit random number generated on each boot (4 words)
◦Word 0 : Per boot random number 0
◦Word 1 : Per boot random number 1
◦Word 2 : Per boot random number 2
◦Word 3 : Per boot random number 3
•0x0020 : NONCE - not supported
•0x0040 : BOOT_INFO  (4 words)
◦Word 0 : 0xttppbbdd
▪tt - recent boot TBYB and update info (updated on regular non BOOTSEL boots)
RP2350 Datasheet
5.4. Bootrom APIs 391
▪pp - recent boot partition (updated on regular not BOOTSEL boots)
▪bb - boot type of the most recent boot
▪dd - recent boot diagnostic "partition"
◦Word 1 : Recent boot diagnostic. Diagnostic information from a recent boot (with information from the
partition (or slot) indicated by dd above. "partition" numbers here are:
▪0-15 : a partition number
▪-1 : none
▪-2 : slot 0
▪-3 : slot 1
▪-4 : image (the diagnostic came from the launch of a RAM image, OTP boot image or user chain_image() 
call).
◦Word 2 : Last reboot param 0
◦Word 3 : Last reboot param 1
"Boot Diagnostic" information is intended to help identify the cause of a failed boot, or booting into an unexpected
binary. This information can be retrieved via PICOBOOT after a watchdog reboot, however it will not survive a reset via
the RUN pin or POWMAN reset.
There is only one word of diagnostic information. What it records is based on the pp selection above, which is itself set
as a parameter when rebooting programmatically into a normal boot.
To get diagnostic info, pp must refer to a slot or an "A" partition; image diagnostics are automatically selected on boot
from OTP or RAM image, or when chain_image()  is called.)
The diagnostic word thus contains data for either slot 0 and slot 1, or the "A" partition (and its "B" partition if it has one).
The low half word of the diagnostic word contains information from slot 0 or partition A; the high half word contains
information from slot 1 or partition B.
The format of each half-word is as follows (using the word region  to refer to slot or partition)
•0x0001 : REGION_SEARCHED  - The region was searched for a block loop.
•0x0002 : INVALID_BLOCK_LOOP  - A block loop was found but it was invalid
•0x0004 : VALID_BLOCK_LOOP  - A valid block loop was found (Blocks from a loop wholly contained within the region, and
the blocks have the correct structure. Each block consists of items whose sizes sum to the size of the block)
•0x0008 : VALID_IMAGE_DEF  - A valid IMAGE_DEF  was found in the region. A valid IMAGE_DEF  must parse correctly and must
be executable.
•0x0010 : HAS_PARTITION_TABLE  - Whether a partition table is present. This partition table must have a correct structure
formed if VALID_BLOCK_LOOP  is set. If the partition table turns out to be invalid, then INVALID_BLOCK_LOOP  is set too (thus
both VALID_BLOCK_LOOP  and INVALID_BLOCK_LOOP  will both be set).
•0x0020 : CONSIDERED - There was a choice of partition/slot and this one was considered. The first slot/partition is
chosen based on a number of factors. If the first choice fails verification, then the other choice will be considered.
◦the version of the PARTITION_TABLE /IMAGE_DEF  present in the slot/partition respectively.
◦whether the slot/partition is the "update region" as per a FLASH_UPDATE  reboot.
◦whether an IMAGE_DEF  is marked as "explicit buy"
•0x0040 : CHOSEN - This slot/partition was chosen (or was the only choice)
•0x0080 : PARTITION_TABLE_MATCHING_KEY_FOR_VERIFY  - if a signature is required for the PARTITION_TABLE  (via OTP setting),
then whether the PARTITION_TABLE  is signed with a key matching one of the four stored in OTP
•0x0100 : PARTITION_TABLE_HASH_FOR_VERIFY  - set if a hash value check could be performed. In the case a signature is
required, this value is identical to PARTITION_TABLE_MATCHING_KEY_FOR_VERIFY
RP2350 Datasheet
5.4. Bootrom APIs 392
•0x0200 : PARTITION_TABLE_VERIFIED_OK  - whether the PARTITION_TABLE  passed verification (signature/hash if
present/required)
•0x0400 : IMAGE_DEF_MATCHING_KEY_FOR_VERIFY  - if a signature is required for the IMAGE_DEF  due to secure boot, then
whether the IMAGE_DEF  is signed with a key matching one of the four stored in OTP.
•0x0800 : IMAGE_DEF_HASH_FOR_VERIFY  - set if a hash value check could be performed. In the case a signature is required,
this value is identical to IMAGE_DEF_MATCHING_KEY_FOR_VERIFY
•0x1000 : IMAGE_DEF_VERIFIED_OK  - whether the PARTITION_TABLE  passed verification (signature/hash if present/required)
and any LOAD_MAP  is valid
•0x2000 : LOAD_MAP_ENTRIES_LOADED  - whether any code was copied into RAM due to a LOAD_MAP
•0x4000 : IMAGE_LAUNCHED  - whether an IMAGE_DEF  from this region was launched
•0x8000 : IMAGE_CONDITION_FAILURE  - whether the IMAGE_DEF  failed final checks before launching; these checks include:
◦verification failed (if it hasn’t been verified earlier in the CONSIDERED  phase).
◦a problem occurred setting up any rolling window.
◦the rollback version could not be set in OTP (if required in Secure mode)
◦the image was marked as Non-secure
◦the image was marked as "explicit buy", and this was a flash boot, but then region was not the "flash update"
region
◦the image has the wrong architecture, but architecture auto-switch is disabled (or the correct architecture is
disabled)
NOTE
The non-sensical combination of BOOT_DIAGNOSTIC_INVALID_BLOCK_LOOP  and BOOT_DIAGNOSTIC_VALID_BLOCK_LOOP  both being
set is used to flag a PARTITION_TABLE  which passed the initial verification (and hash/sig), but was later discovered to
have invalid contents when it was fully parsed.
To get a full picture of a failed boot involving slots and multiple partitions, the device can be rebooted multiple times to
gather the information.
5.4.8.18. get_uf2_target_partition
Code: 'G','U'
Signature: int get_uf2_target_partition(uint8_t *workarea_base, uint32_t workarea_size, uint32_t family_id,
resident_partition_t *partition_out)
Supported architectures: Arm-S RISC-V. Note on RISC-V this function requires additional stack; see Section 5.4.8.26 .
Returns: >= 0 on success (the target partition index), or a negative error code on error.
This method performs the same operation to decide on a taget partition for a UF2 family ID as when a UF2 is dragged
onto the USB drive in BOOTSEL mode.
This method potentially requires similar complexity to the boot path in terms of picking amongst versions, checking
signatures etc. As a result it requires a user provided memory buffer as a work area. The work area should byte word-
aligned and of sufficient size or BOOTROM_ERROR_INSUFFICIENT_RESOURCES  will be returned. The work area size currently
required is 3064, so 3K is a good choice.
If the partition table hasn’t been loaded (for example, from a watchdog or RAM boot), then this method returns
BOOTROM_ERROR_PRECONDITION_NOT_MET , and you should load the partition table via load_partition_table()  first.
RP2350 Datasheet
5.4. Bootrom APIs 393
5.4.8.19. git_revision
Code: 'G','R'
Type: const uint32_t git_revision
The 8 most significant hex digits of the bootrom git revision. Uniquely identifies this version of the bootrom.
NOTE
This is the git revision built at chip tapeout; the git hash in the public repository is different due to squashed history,
even though the contents are identical. The contents can be verified by building the public bootrom source and
comparing the resulting binary with one binary dumped from the chip.
5.4.8.20. load_partition_table
Code: 'L','P'
Signature: int load_partition_table(uint8_t *workarea_base, uint32_t workarea_size, bool force_reload)
Supported architectures: Arm-S, RISC-V. Note on RISC-V this function requires additional stack; see Section 5.4.8.26 .
Returns: BOOTROM_OK  (0) on success, or a negative error code on error.
Loads the current partition table from flash, if present.
This method potentially requires similar complexity to the boot path in terms of picking amongst versions, checking
signatures etc. As a result it requires a user provided memory buffer as a work area. The work area should byte word-
aligned and of sufficient size or BOOTROM_ERROR_INSUFFICIENT_RESOURCES  will be returned. The work area size currently
required is 3064, so 3K is a good choice.
If force_reload  is false, then this method will return BOOTROM_OK  immediately if the bootrom is loaded, otherwise it will
reload the partition table if it has been loaded already, allowing for the partition table to be updated in a running
program.
5.4.8.21. otp_access
Code: 'O','A'
Signature: int otp_access(uint8_t *buf, uint32_t buf_len, uint32_t row_and_flags)
Supported architectures: Arm-S, Arm-NS, RISC-V
Returns: BOOTROM_OK  (0) on success, or a negative error code on error.
Writes data from a buffer into OTP, or reads data from OTP into a buffer.
•0x0000ffff  - ROW_NUMBER : 16 low bits are row number (0-4095)
•0x00010000  - IS_WRITE : if set, do a write (not a read)
•0x00020000  - IS_ECC: if this bit is set, each value in the buffer is 2 bytes and ECC is used when read/writing from 24 bit
value in OTP. If this bit is not set, each value in the buffer is 4 bytes, the low 24-bits of which are written to or read
from OTP.
The buffer must be aligned to 2 bytes or 4 bytes according to the IS_ECC flag.
This method will read and write rows until the first row it encounters that fails a key or permission check at which it will
return BOOTROM_ERROR_NOT_PERMITTED .
Writing will also stop at the first row where an attempt is made to set an OTP bit from a 1 to a 0, and
BOOTROM_ERROR_UNSUPPORTED_MODIFICATION  will be returned.
If all rows are read/written successfully, then BOOTROM_OK  will be returned.
RP2350 Datasheet
5.4. Bootrom APIs 394
5.4.8.22. partition_table_ptr
Code: 'P','T'
Type: resident_partition_table **partition_table_ptr
A pointer to the pointer to the resident partition table info. The resident partition table is the subset of the full partition
table that is kept in memory, and used for flash permissions.
The public part of the resident partition table info is of the form:
Word Bytes Value
0 1 partition_count  (0-16)
1 partition_count_with_permissions  (0-16). Set this to > partition_count  when adding extra
permission regions at runtime (do not modify the original partitions)
1 loaded  (0x01 if a partition table has been loaded from flash)
1 0x00 (pad)
1 1 unpartitioned_space_permissions_and_flags
2-3 Partition 0
1 permissions_and_location  for partition 0
1 permissions_and_flags  for partition 0
4-5 Partition 1
1 permissions_and_location  for partition 1
1 permissions_and_flags  for partition 1
… … …
32-33 Partition 15
1 permissions_and_location  for partition 15
1 permissions_and_flags  for partition 15
Details of the fields permissions_and_location  and permissions_and_flags  can be found in Section 5.9.4 .
5.4.8.23. pick_ab_partition
Code: 'A','B'
Signature: int pick_ab_partition(uint8_t *workarea_base, uint32_t workarea_size, uint partition_a_num)
Supported architectures: Arm-S, RISC-V. Note on RISC-V this function requires additional stack; see Section 5.4.8.26 .
Returns: >= 0 on success (the partition index), or a negative error code on error.
Determines which of the partitions has the "better" IMAGE_DEF . In the case of executable images, this is the one that would
be booted
This method potentially requires similar complexity to the boot path in terms of picking amongst versions, checking
signatures etc. As a result it requires a user provided memory buffer as a work area. The work area should bye word
aligned, and of sufficient size or BOOTROM_ERROR_INSUFFICIENT_RESOURCES  will be returned. The work area size currently
required is 3064, so 3K is a good choice.
The passed partition number can be any valid partition number other than the "B" partition of an A/B pair.
This method returns a negative error code, or the partition number of the picked partition if ( partition_a_num  or the
number of its "B" partition if any).
RP2350 Datasheet
5.4. Bootrom APIs 395
NOTE
This method does not look at owner partitions, only the A partition passed and its corresponding B partition.
5.4.8.24. reboot
Code: 'R','B'
Signature: int reboot(uint32_t flags, uint32_t delay_ms, uint32_t p0, uint32_t p1)
Supported architectures: Arm-S, Arm-NS, RISC-V
Returns: BOOTROM_OK  (or doesn’t return) on success, a negative error code on error.
Resets the RP2350 and uses the watchdog facility to restart.
The delay_ms  is the millisecond delay before the reboot occurs. Note: by default this method is asynchronous (unless
NO_RETURN_ON_SUCCESS  is set - see below), so the method will return and the reboot will happen this many milliseconds
later.
The flags  field contains one of the following values:
•0x0000 : REBOOT_TYPE_NORMAL  - reboot into the normal boot path.
◦p0 - the boot diagnostic "partition" (low 8 bits only)
•0x0002 : REBOOT_TYPE_BOOTSEL  - reboot into BOOTSEL mode.
◦p0 - a set of flags:
▪0x01 : DISABLE_MSD_INTERFACE  - Disable the BOOTSEL USB drive (see Section 5.5 )
▪0x02 : DISABLE_PICOBOOT_INTERFACE  - Disable the PICOBOOT interface (see Section 5.6 ).
▪0x10 : GPIO_PIN_ACTIVE_LOW  - The GPIO in p1 is active low.
▪0x20 : GPIO_PIN_ENABLED  - Enable the activity indicator on the specified GPIO.
◦p1 - the GPIO number to use as an activity indicator (enabled by flag in p0) for the BOOTSEL USB drive.
•0x0003 : REBOOT_TYPE_RAM_IMAGE  - reboot into an image in RAM. The region of RAM or XIP RAM is searched for an
image to run. This is the type of reboot used when a RAM UF2 is dragged onto the BOOTSEL USB drive.
◦p0 - the region start address (word-aligned).
◦p1 - the region size (word-aligned).
•0x0004 : REBOOT_TYPE_FLASH_UPDATE  - variant of REBOOT_TYPE_NORMAL  to use when flash has been updated. This is the type
of reboot used after dragging a flash UF2 onto the BOOTSEL USB drive.
◦p0 - the address of the start of the region of flash that was updated. If this address matches the start address
of a partition or slot, then that partition or slot is treated preferentially during boot (when there is a choice).
This type of boot facilitates TBYB ( Section 5.1.17 ) and version downgrades.
•0x000d : REBOOT_TYPE_PC_SP  - reboot to a specific PC and SP. Note: this is not allowed in the Arm-NS variant.
◦p0 - the initial program counter (PC) to start executing at. This must have the lowest bit set for Arm and clear
for RISC-V
◦p1 - the initial stack pointer (SP).
All of the above, can have optional flags ORed in:
•0x0010 : REBOOT_TO_ARM  - switch both cores to the Arm architecture (rather than leaving them as is). The call will fail
with BOOTROM_ERROR_INVALID_STATE  if the Arm architecture is not supported.
•0x0020 : REBOOT_TO_RISCV  - switch both cores to the RISC-V architecture (rather than leaving them as is). The call will
fail with BOOTROM_ERROR_INVALID_STATE  if the RISC-V architecture is not supported.
RP2350 Datasheet
5.4. Bootrom APIs 396
•0x0100 : NO_RETURN_ON_SUCCESS  - the watchdog hardware is asynchronous. Setting this bit forces this method not to
return if the reboot is successfully initiated.
NOTE
The p0 and p1 parameters are generally written to watchdog scratch registers 2 & 3, and are interpreted post-reboot
by the boot path code. The exception is REBOOT_TYPE_NORMAL  where this API handles the p0 value before rebooting; the
boot path itself does not accept any parameters for REBOOT_TYPE_NORMAL .
5.4.8.25. secure_call
Code: 'S','C'
Signature: int secure_call(… )
Supported architectures: Arm-NS
Returns: >= 0 on success, a negative error code on error.
Call a Secure method from Non-secure code, passing the method to be called in the register r4 (other arguments
passed as normal).
This method provides the ability to decouple the Non-secure code from the Secure code, allowing the former to call
methods in the latter without needing to know the location of the methods.
This call will always return BOOTROM_ERROR_INVALID_STATE  unless Secure Arm code has provided a handler function via
set_rom_callback() ; if there is a handler function, this method will return the return code that the handler returns, with
the convention that BOOTROM_ERROR_INVALID_ARG  if the "function selector" (in r4) is not supported.
Certain well-known "function selectors" will be pre-defined to facilitate interaction between Secure and Non-secure SDK
code, or indeed with other environments (for example, logging to secure UART/USB CDC, launch of core 1 from NS
code, watchdog reboot from NS code back into NS code, etc.)
To avoid conflicts the following bit patterns are used for "function selectors":
•0b0xxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  is a "well known" function selector; don’t use for your own methods
•0b10xx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  is a "unique" function selector intended to be unlikely to clash with
others'. The lower 30 bits should be chosen at random
•0b11xx xxxx xxxx xxxx xxxx xxxx xxxx xxxx  is a "private" function selector intended for use by tightly coupled NS and
S code
5.4.8.26. set_bootrom_stack
Code: 'S','S'
Signature: int set_bootrom_stack(uint32_t base_size[2])
Supported architectures: RISC-V
Returns: BOOTROM_OK  (0) on success, a negative error code on error.
Most bootrom functions are written just once, in Arm code, to save space. As a result these functions are emulated
when running under the RISC-V architecture. This is largely transparent to the user, however the stack used by the Arm
emulation is separate from the calling user’s stack, and is stored in boot RAM and is of quite limited size. When using
certain of the more complex APIs or if nesting bootrom calls from within IRQs, you may need to provide a larger stack.
This method allows the caller to specify a region of RAM to use as the stack for the current core  by passing a pointer to
two values: the word aligned base address, and the size in bytes (multiple of 4).
The method fills in the previous base/size values into the passed array before returning.
RP2350 Datasheet
5.4. Bootrom APIs 397
5.4.8.27. set_ns_api_permission
Code: 'S','P'
Signature: int set_ns_api_permission(uint ns_api_num, bool allowed)
Supported architectures: Arm-S
Returns: BOOTROM_OK  (0) on success, a negative error code on error.
Allow or disallow the specific NS API; all NS APIs default to disabled.
ns_api_num  is one of the following, configuring Arm-NS access to the given API. When an NS API is disabled, calling it will
return BOOTROM_ERROR_NOT_PERMITTED .
•0x0: get_sys_info
•0x1: flash_op
•0x2: flash_runtime_to_storage_addr
•0x3: get_partition_table_info
•0x4: secure_call
•0x5: otp_access
•0x6: reboot
•0x7: get_b_partition
NOTE
All permissions default to disallowed after a reset (see also bootrom_state_reset() ).
5.4.8.28. set_rom_callback
Code: 'R','C'
Signature: int set_rom_callback(uint callback_number, int (*callback)(… ))
Supported architectures: Arm-S, RISC-V
Returns: >= 0 (the old callback pointer) on success, a negative error code on error.
The only currently supported callback_number  is 0 which sets the callback used for the secure_call  API.
A callback pointer of 0 deletes the callback function, a positive callback pointer (all valid function pointers are on
RP2350) sets the callback function, but a negative callback pointer can be passed to get the old value without setting a
new value.
If successful, returns >=0 (the existing value of the function pointer on entry to the function).
5.4.8.29. validate_ns_buffer
Code: 'V','B'
Signature: void *validate_ns_buffer(const void *addr, uint32_t size, uint32_t write, uint32_t *ok)
Supported architectures: Arm-S
Returns: addr on success, or a negative error code on error. On RP2350 A3 and newer there are additional out-of-band
return values, detailed below.
Utility method that can be used by Secure Arm code to validate a buffer passed to it from Non-secure code.
RP2350 Datasheet
5.4. Bootrom APIs 398
Both the write parameter and the (out) result parameter ok are RCP booleans, so 0xa500a500  for true, and 0x00c300c3  for
false. This enables hardening of this function, and indeed the write parameter must be one of these values or the RCP
will halt the system.
For success, the entire buffer must fit in range XIP_BASE  → SRAM_END , and must be accessible by the Non-secure caller
according to SAU + NS MPU (privileged or not based on current processor IPSR and NS CONTROL flag). Buffers in USB
RAM are also allowed if access is granted to NS via ACCESSCTRL.
On RP2350 A3 and newer, additional out-of-band information is returned from this function to aid calling from assembly
code:
•The RCP boolean value returned in the location pointed to by ok is now also returned in processor register r1 (a
valid ok pointer value or 0 must still be passed).
•The passed size is returned in register r3.
•The N flag is set based on the register r1 value, so you can immediately branch with bpl for failure.
The A3 bootrom uses a call pattern similar to that shown below to help harden the code against hardware attacks,
which might cause skipping of instructions:
// at this point, r0, r2, r3 already hold arguments for buffer, write, and *ok
1:    movs r1, #0           // set r1 to invalid RCP_VALUE zero and set N=0
2:    mov r1, ra            // set r1 to size value (stored in another register a)
3:    bl validate_ns_buffer  // call the validate function
4:    bpl buffer_invalid     // N==0 is deemed to be false (invalid)
5:    rcp_btrue  r1          // negative value shoule be 0xa500a500
buffer_valid :
6:    movs rb, ra           // reload size for use
7:    rcp_iequal  r3, rb     // check r3 has the correct size
      // r0 holds 'buffer' on success; this can be used as a check too if desired
8:    // do some secure code with `buffer` and `size`
      ...
buffer_invalid :
      // r0 holds BOOTROM_ERROR_INVALID_ADDRESS
      ...
5.4.8.30. xip_setup_func_ptr
Code: 'X','F'
Type: void *(xip_setup_func_ptr)(void)'
5.5. USB mass storage interface
The bootrom provides a standard USB bootloader that makes a writeable drive available for copying code to the RP2350
using UF2 files (see Section 5.5.2 ).
A suitable UF2 file copied to the drive is downloaded and written to flash or RAM, and the device is automatically
rebooted, making it trivial to download and run code on the RP2350 using only a USB connection.
5.5.1. The RP2350 drive
RP2350 appears as a standard 128MB flash drive named RP2350 formatted as a single partition with FAT16. There are
only ever two actual files visible on the drive specified.
RP2350 Datasheet
5.5. USB mass storage interface 399
•INFO_UF2.TXT  contains a string description of the UF2 bootloader and version.
•INDEX.HTM  redirects to information about the RP2350 device.
The default INDEX.HTM  for RP2350 A2 is https://raspberrypi.com/device/RP2?version=5A09D5312E22 . The version
parameter is changed for other RP2350 revisions; the first 6 characters are from the git hash of the chip, and the next 6
characters are from the git hash of the bootrom. The contents of these files and the name of the drive may be
customised. For more information, see Section 5.7 .
Any type of files may be written to the USB drive from the host; however, in general these aren’t stored, and only appear 
to be so because of caching on the host side.
When a suitable UF2 file is written to the device, the special contents are recognised and data is written to specified
locations in RAM or flash.
Where flash-targeted UF2s are written on RP2350 is determined by the family id  of the UF2 contents and the partition
table.
If there’s no partition table, then UF2s are stored at the address they specify; otherwise they (with the exception of the
special ABSOLUTE  family id) are stored into a single partition, with UF2 flash address 0x10000000  mapping to the start of
the partition.
It’s possible, based on the partition table or family id, that the UF2 isn’t downloadable anywhere in flash, in which case,
it’s ignored. Further detail can be discovered via GET_INFO - UF2_STATUS . On the completed download of an entire
valid UF2 file, RP2350 automatically reboots to run the newly downloaded code.
Invalid UF2 files might not write at all or only write partially to RP2350 before failing. Not all operating systems notify
you of disk write errors after a failed write. You can use picotool verify  to verify that a UF2 file wrote correctly to
RP2350.
5.5.2. UF2 format details
This section describes the constraints on a UF2 file to be valid for download.
TIP
To generate UF2 files, you can use the picootol uf2 convert  functionality in picotool .
All data destined for the device must be in UF2 blocks with:
•A familyID  present, with a value in the reserved range 0xe48bff58  through 0xe48bff5b  or a user family ID configured in
a partition table (see table in Section 5.5.3 ).
•A payload_size  of 256.
All data must be destined for (and fit entirely within) the following memory ranges (depending on the type of binary
being downloaded which is determined by the address of the first UF2 block encountered):
•A regular flash image
◦0x10000000 -0x12000000  flash:  All blocks must be targeted at 256 byte alignments. Writes beyond the end of
physical flash will wrap back to the beginning of flash.
•A RAM only  image
◦0x20000000 -0x20082000  main RAM:  Blocks can be positioned with byte alignment.
◦0x13ffc000 -0x14000000  XIP RAM:  (since flash isn’t being targeted, the flash cache is available for use as RAM
with same properties as main RAM ).
RP2350 Datasheet
5.5. USB mass storage interface 400
NOTE
Traditionally UF2 has only been used to write to flash, but this is more a limitation of using the metadata-free
.BIN file as the source to generate the UF2 file. RP2350 takes full advantage of the inherent flexibility of UF2 to
support the full range of binaries in the richer .ELF format produced by the build to be used as the source for the
UF2 file.
•The numBlocks  must specify a total size of the binary that fits in the regions specified above
•A change of numBlocks  or the binary type (determined by UF2 block target address) will discard the current transfer
in progress.
•A change in the familyID  will discard the current transfer in progress.
•All device destined data must be in blocks without the UF2_FLAG_NOT_MAIN_FLASH  marking which relates to content to
be ignored rather than flash vs RAM.
NOTE
When targeting flash, the UF2 block target addresses are interpreted to be in the content of a flash binary that starts
at 0x10000000 . The UF2 image may be downloaded into a partition that starts somewhere else in flash, so the actual
storage address is uf2_image_target_base + uf2_block_target_addr - 0x10000000 .
The flash is always erased a 4 kB sector at a time, so including data for only a subset of the 256-byte pages within a
sector in a flash-binary UF2 will leave the remaining 256-byte pages of the sector erased but undefined.
A binary is considered "downloaded" when each of the numBlocks  blocks has been seen at least once in the course of a
single valid transfer. The data for a block is only written the first time in case of the host resending duplicate blocks.
After a UF2 is completely downloaded, the RP2350 reboots, ostensibly to run the new binary. Since RP2350 supports
downloading a variety of executable and non-executable UF2s into partitions, the partition contains a flag which can be
used to turn off this reboot behaviour on a case by case basis.
NOTE
When rebooting after a flash download, a flash update boot  is performed. As a result, the newly written partition is
preferred when considered in an A/B choice, but it doesn’t boot if another bootable image is found in an earlier
partition. When rebooting after a RAM download, then the image search starts at the lowest address of a
downloaded block (with main RAM considered lower than flash cache if both are present, and the search only
spanning one of either main RAM or the flash cache)
It is possible for host software to temporarily disable UF2 writes via the PICOBOOT interface to prevent interference
with operations being performed via that interface (see below), in which case any UF2 file write in progress will be
aborted.
NOTE
If a problem is encountered downloading the UF2, then it will appear as if nothing has happened  since the device will
not reboot. The picotool  command uf2 info  can be used to determine the status of the last download in this case
(see also GET_INFO - UF2_STATUS ).
5.5.3. UF2 targeting rules
When the first block of a UF2 is downloaded, a choice is made where to store the UF2 in flash based on the family ID  of
the UF2. This choice is performed by the same code as the get_uf2_target_partition()  API (see Section 5.4.8.18 ).
The following family IDs are defined by the bootrom. However, the user can use their own for more specific targeting:
RP2350 Datasheet
5.5. USB mass storage interface 401
Table 455. Table of
standard UF2 family
IDs understood by the
RP2350 bootromName Value Description
absolute 0xe48bff57 Special family ID for content intended to be written directly to flash, ignoring
partitions.
rp2040 0xe48bff56 RP2040 executable image.
data 0xe48bff58 Generic catch-all for data UF2s.
rp2350_arm_s 0xe48bff59 RP2350 Arm Secure image (one intended to be booted by the bootrom).
rp2350_riscv 0xe48bff5a RP2350 RISC-V image.
rp2350_arm_ns 0xe48bff5b RP2350 Arm Non-secure image. Not directly bootable by the bootrom.
However, Secure user code is likely to want to be able to locate binaries of this
type.
NOTE
The only information available to the algorithm that makes the choice of where to store the UF2, is the UF2 family ID;
the algorithm can’t look inside at the UF2 contents as UF2 data sectors may appear at the device in any order.
A UF2 with the absolute  family ID is downloaded without regard to partition boundaries. A partition table (if present) or
OTP configuration can define whether absolute  family ID downloads are allowed, and download to the start of flash. The
default factory settings allow for absolute  family ID downloads
If there is a partition table present, any other family IDs download to a single partition; if there is no partition table
present then the data, rp2350-arm-s  (if Arm architecture is enabled) and rp2350-riscv  (if RISC-V architecture is enabled)
family IDs are allowed by default, and the UF2 is always downloaded to the start of flash.
If a partition table is present, then up to four passes are made over the partition table (from first to last partition
encountered) until a matching partition is found; Each pass has different selection criteria:
1.Look for an (unowned) A partition, ignoring those marked NOT_BOOTABLE  for the current CPU architecture
Use of the NOT_BOOTABLE_  flags allows you to have separate boot partitions for each CPU architecture (Arm or RISC-
V); were you not to use NOT_BOOTABLE_  flags in this scenario, and say the first encountered partition has an Arm
IMAGE_DEF , then, when booting under the RISC-V architecture with auto architecture switching enabled, the bootrom
would just switch back into the Arm architecture to boot the Arm binary. Marking the first partition as
NOT_BOOTABLE_RISCV  in the partition table solves this problem.
The correct CPU architecture refers to a match between the architecture of the UF2 (determined by family ID of
rp2350_arm_s  or rp2350_riscv ) and the current CPU architecture.
This pass allows the user to drop either Arm or RISC-V UF2s, and have them stored as you’d want for the
NOT_BOOTABLE_  flag scenario.
2.If auto architecture switching is enabled and the other architecture is available, look for an (unowned) A partition,
ignoring those marked NOT_BOOTABLE  for that CPU architecture.
This pass is designed to match the boot use case of booting images from the other architecture as a fallback. If
there is a partition that would be booted as a result auto architecture switching then this a reasonable place to
store this UF2 for the alternative architecture.
3.Look for any unowned A partition that accepts the family ID
This pass provides a way to target any UF2s to a partitions based on family ID, but assumes that you’d prefer a
UF2 to go into a matching top-level partition vs an owned partition.
4.Finally, look for any A partition that accepts the family ID
This pass implicitly only looks at owned partitions, since unowned partitions would have been matched in the
previous pass.
If none of the passes find a match, the UF2 contents aren’t then downloaded. The picotool  command uf2 info  can be
RP2350 Datasheet
5.5. USB mass storage interface 402
used to determine the status of the last download in this case (see also GET_INFO - UF2_STATUS ).
5.5.3.1. A/B partitions and ownership
Each of the above passes refers to finding an A partition. Any partition that isn’t a B partition is an A partition; an unpaired
partition is classed as an A partition.
If the found A partition doesn’t have a B partition paired with it, then the A partition is the UF2 target partition.
If however, the A partition has a B partition, then a further choice must be made as to which of the A/B partitions should
be targeted.
1.If the A partition is unowned, then the partition choice is made based on any current valid IMAGE_DEF  in those
partitions. The valid partition with the higher version number isn’t chosen; in the case of executable IMAGE_DEF s, this
is the opposite of what would happen during boot; this makes sense as you want to drop the UF2 on the partition
which isn’t currently booting.
2.If the A partition is marked owned, then the contents of the A partition and B partition are assumed not to contain
IMAGE_DEF s which can be used to make a version based choice. Therefore, the owner of the A partition ( Aowner ) and its
B partition ( Bowner ) are used to make the choice
It is however dependent on the use case whether you would want a UF2 that is destined for partition A / partition B
to go into partition A when partition Aowner  has an IMAGE_DEF  with the higher version (would boot if the IMAGE_DEF  was
executable) or when Bowner  has an IMAGE_DEF  with the higher version. By default, the bootrom picks partition A when
partition Aowner  has the higher versioned IMAGE_DEF , however this can be changed by setting the
UF2_DOWNLOAD_AB_NON_BOOTABLE_OWNER_AFFINITY  flag in partition A.
5.5.3.2. Multiple UF2 families
It is possible to include sectors targeting different family IDs in the same UF2 file. The intention in the UF2 specification
is to allow one file to be shipped for multiple different devices, but the expectation is that each device only accepts one
UF2 family ID.
Similarly on RP2350, it is only supported to download a UF2 file containing multiple family IDs if only one  of those family
IDs is acceptable for download to the device according to the above rules.
5.6. USB PICOBOOT interface
The PICOBOOT interface is a low level USB protocol for interacting with the RP2350 while it is in BOOTSEL mode. This
interface may be used concurrently with the USB Mass Storage Interface.
It provides for flexible reading from and writing to RAM or flash, rebooting, executing code on the device and a handful
of other management functions.
Constants and structures related to the interface can be found in the SDK header picoboot.h  in the SDK
5.6.1. Identifying the device
A RP2350 device can recognised by the Vendor ID and Product ID in its device descriptor (shown in Table 456 ), unless
different values have been set in OTP (see Section 5.7 )
Table 456. RP2350
Boot Device
DescriptorField Value
bLength 18
bDescriptorType 1
RP2350 Datasheet
5.6. USB PICOBOOT interface 403
Field Value
bcdUSB 2.10
bDeviceClass 0
bDeviceSubClass 0
bDeviceProtocol 0
bMaxPacketSize0 64
idVendor 0x2e8a - this value may be overridden in OTP
idProduct 0x000f - this value may be overridden in OTP
bcdDevice 1.00 - this value may be overridden in OTP
iManufacturer 1
iProduct 2
iSerial 3
bNumConfigurations 1
5.6.2. Identifying the interface
The PICOBOOT interface is recognised by the vendor-specific Interface Class, the zero Interface Sub Class, and
Interface Protocol (shown in Table 457 ).
Don’t rely on the interface number, because that is dependent on whether the device is currently exposing the Mass
Storage Interface. The device might not be currently exposing the PICOBOOT interface at all, so you mustn’t assume it’s
present.
Table 457. PICOBOOT
Interface DescriptorField Value
bLength 9
bDescriptorType 4
bInterfaceNumber varies
bAlternateSetting 0
bNumEndpoints 2
bInterfaceClass 0xff (vendor specific)
bInterfaceSubClass 0
bInterfaceProtocol 0
iInterface 0
5.6.3. Identifying the endpoints
The PICOBOOT interface provides a single BULK_OUT  and a single BULK_IN endpoint. These can be identified by their
direction and type. You mustn’t rely on endpoint numbers.
RP2350 Datasheet
5.6. USB PICOBOOT interface 404
5.6.4. PICOBOOT Commands
The two bulk endpoints are used for sending commands and retrieved successful command results. All commands are
exactly 32 bytes (see Table 458 ) and sent to the BULK_OUT  endpoint.
Table 458. PICOBOOT
Command DefinitionOffset Name Description
0x00 dMagic The value 0x431fd10b
0x04 dToken A user provided token to identify this request by
0x08 bCmdId The ID of the command. Note that the top bit indicates data transfer direction
(0x80 = IN )
0x09 bCmdSize Number of bytes of valid data in the args field
0x0a reserved 0x0000
0x0c dTransferLength The number of bytes the host expects to send or receive over the bulk channel
0x10 args 16 bytes of command-specific data padded with zeros
If a command sent is invalid or not recognised, the bulk endpoints will be stalled. Further information will be available
via the GET_COMMAND_STATUS  request (see Section 5.6.5.2 ).
Following the initial 32 byte packet, if dTransferLength  is non-zero, then that many bytes are transferred over the bulk pipe
and the command is completed with an empty packet in the opposite direction. If dTransferLength  is zero then command
success is indicated by an empty IN packet.
The following commands are supported (note common fields dMagic, dToken, and reserved  are omitted for clarity)
5.6.4.1. EXCLUSIVE_ACCESS ( 0x01)
Claim or release exclusive access for writing to the RP2350 over USB (versus the Mass Storage Interface)
Table 459. PICOBOOT
EXCLUSIVE_ACCESS
command structureOffset Name Value / Description
0x08 bCmdId 0x01 (EXCLUSIVE_ACCESS )
0x09 bCmdSize 0x01
0x0c dTransferLength 0x00000000
0x10 bExclusive NOT_EXCLUSIVE  (0) No restriction on USB Mass Storage operation
EXCLUSIVE  (1) Disable USB Mass Storage writes (the host should
see them as write protect failures, but in any case
any active UF2 download will be aborted)
EXCLUSIVE_AND_EJECT  (2) Lock the USB Mass Storage Interface out by
marking the drive media as not present (ejecting
the drive)
5.6.4.2. REBOOT ( 0x02)
Not supported on RP2350.
Use Section 5.6.4.10  instead.
RP2350 Datasheet
5.6. USB PICOBOOT interface 405
5.6.4.3. FLASH_ERASE ( 0x03)
Erases a contiguous range of flash sectors.
Table 460. PICOBOOT
FLASH_ERASE
command structureOffset Name Value / Description
0x08 bCmdId 0x03 (FLASH_ERASE )
0x09 bCmdSize 0x08
0x0c dTransferLength 0x00000000
0x10 dAddr The address in flash to erase, starting at this location. This must be sector
(4 kB) aligned
0x14 dSize The number of bytes to erase. This must an exact multiple number of sectors
(4 kB)
5.6.4.4. READ ( 0x84)
Read a contiguous memory (flash or RAM or ROM) range from the RP2350
Table 461. PICOBOOT
Read memory
command (flash, RAM,
ROM) structureOffset Name Value / Description
0x08 bCmdId 0x84 (READ)
0x09 bCmdSize 0x08
0x0c dTransferLength Must be the same as dSize
0x10 dAddr The address to read from. May be in flash or RAM or ROM
0x14 dSize The number of bytes to read
5.6.4.5. WRITE ( 0x05)
Writes a contiguous memory range of memory (flash or RAM) on the RP2350.
Table 462. PICOBOOT
Write memory
command (flash,
RAM) structureOffset Name Value / Description
0x08 bCmdId 0x05 (WRITE)
0x09 bCmdSize 0x08
0x0c dTransferLength Must be the same as dSize
0x10 dAddr The address to write from. May be in flash or RAM, however must be page
(256 byte) aligned if in flash. Flash must be erased first or the results are
undefined.
0x14 dSize The number of bytes to write. If writing to flash and the size isn’t an exact
multiple of pages (256 bytes) then the last page is zero-filled to the end.
5.6.4.6. EXIT_XIP ( 0x06)
A no-op provided for compatibility with RP2040. An XIP exit sequence ( flash_exit_xip() ) is issued once before entering
the USB bootloader, which returns the external QSPI device from whatever XIP state it was in to a serial command state,
and the external QSPI device then remains in this state until reboot.
RP2350 Datasheet
5.6. USB PICOBOOT interface 406
Table 463. PICOBOOT
EXIT_XIP command
structureOffset Name Value / Description
0x08 bCmdId 0x06 (EXIT_XIP )
0x09 bCmdSize 0x00
0x0c dTransferLength 0x00000000
5.6.4.7. ENTER_XIP ( 0x07)
A no-op provided for compatibility with RP2040. Note that, unlike RP2040, the low-level bootrom flash operations do not
leave the QSPI interface in a state where XIP is inaccessible, therefore there is no need to reinitialise the interface each
time. XIP setup is performed once before entering the USB bootloader, using an 03h command with a fixed clock divisor
of 6.
Table 464. PICOBOOT
Enter Execute in place
(XIP) commandOffset Name Value / Description
0x08 bCmdId 0x07 (ENTER_XIP )
0x09 bCmdSize 0x00
0x0c dTransferLength 0x00000000
5.6.4.8. EXEC ( 0x08)
Not supported on RP2350.
5.6.4.9. VECTORIZE_FLASH ( 0x09)
Not supported on RP2350.
5.6.4.10. REBOOT2 ( 0x0a)
Reboots the RP2350 out of BOOTSEL mode. Note that BOOTSEL mode may be re-entered if no valid bootable image is
found.
The parameters flags , delay_ms , p0, p1 are the same as for api_reboot()
Table 465. PICOBOOT
REBOOT2 command
structureOffset Name Value / Description
0x08 bCmdId 0x0a (REBOOT2)
0x09 bCmdSize 0x10
0x0c dTransferLength 0x00000000
0x10 dAddr flags
0x14 dSize delay_ms
0x18 dSize p0
0x1c dSize p1
5.6.4.11. GET_INFO ( 0x8b)
Generic conduit for retrieving information from the device.
RP2350 Datasheet
5.6. USB PICOBOOT interface 407
The transfer length indicates the maximum number of bytes to be retrieved. The fist word returned indicates the number
of significant words of data that follow. A full "transfer length" is always returned, padding with zeroes as necessary.
"Word 0" , below, refers to the first word of the actual response (the word after the count word).
Table 466. PICOBOOT
GET_INFO command
structureOffset Name Value / Description
0x08 bCmdId 0x0b (GET_INFO )
0x09 bCmdSize 0x10
0x0c dTransferLength the size of data to be received. Note this must be a multiple of 4, and less than
256
RP2350 Datasheet
5.6. USB PICOBOOT interface 408
Offset Name Value / Description
0x10 bType the type of information being retrieved:
•0x1 - INFO_SYS  : Retrieves information from get_sys_info() ; the flag
parameter for that function comes from dParam0 .
•0x2 - PARTITION  : Retrieves information from get_partition_table_info() ; the
flags_and_partition  parameter for that function comes from dParam0 .
•0x03 - UF2_TARGET_PARTITION  : Retrieves the partition that a given UF2
family_id would be downloaded into (if it were dragged on the USB drive
in BOOTSEL mode). The family id is passed in dParam0 .
◦Word 0 : Target partition number:
▪0-15 : the partition number the family would be downloaded to
▪0xff : if the family would be downloaded at an absolute
location
▪-1 : if there is nowhere to download the family
◦Word 1 : Target partition Section 5.9.4.2  if the partition number is
not -1
◦Word 2 : Target partition Section 5.9.4.2  if the partition number is
not -1
•0x04 - UF2_STATUS  : Retrieves information about the current/recent UF2
download
◦Word 0 - 0xnnrr00af
▪'n' - no reboot flag; if 0x01, there is no reboot when the UF2
download completes
▪'r' - if 0x01, the UF2 being download is a RAM UF2
▪'a' - UF2 download abort reason flags
▪0x1 EXCLUSIVELY_LOCKED
▪0x2 BAD_ADDRESS
▪0x4 WRITE_ERROR
▪0x8 REBOOT_FAILURE  // if the UF2 targeted a disabled
architecture
▪'f' - UF2 download status flags
▪0x1 IGNORED_FAMILY
◦Word 1 - the current family id
◦Word 2 - the number of 256 byte blocks successfully downloaded
◦Word 3 - the total number of 256 byte blocks in the UF2 to download
5.6.4.12. OTP_READ ( 0x8c)
Reads data out of OTP. (see also otp_access()  which provides the data). Data returned is subject to the "BL" OTP
permissions, which define bootloader OTP access permissions.
RP2350 Datasheet
5.6. USB PICOBOOT interface 409
Table 467. PICOBOOT
OTP_READ command
structureOffset Name Value / Description
0x08 bCmdId 0x8c (OTP_READ )
0x09 bCmdSize 0x05
0x0c dTransferLength
 
0x10 wRow the first row number to read
0x12 wRowCount the number of rows to read
0x14 bEcc •0 - if reading raw rows (32 bits are returned per row, the top 8 of which
are zero)
•1 - if reading rows as ECC rows (16 bits per row are returned)
5.6.4.13. OTP_WRITE ( 0x0d)
Reads data out of OTP. (see also otp_access()  which performs the operation). Writing is subject to the "BL" OTP
permissions, which define bootloader OTP access permissions.
Table 468. PICOBOOT
OTP_WRITE command
structureOffset Name Value / Description
0x08 bCmdId 0x0d (OTP_WRITE )
0x09 bCmdSize 0x05
0x0c dTransferLength
 
0x10 wRow the first row number to read
0x12 wRowCount the number of rows to read
0x14 bEcc •0 - if writing raw rows (32 bits are provided per row, the top 8 of which
are ignored)
•1 - if writing ECC rows (16 bits are provided per row, and are written with
error correcting information to the OTP)
5.6.5. Control requests
The following requests are sent to the interface via the default control pipe.
5.6.5.1. INTERFACE_RESET ( 0x41)
The host sends this control request to reset the PICOBOOT interface. This command:
•Clears the HALT condition (if set) on each of the bulk endpoints
•Aborts any in-process PICOBOOT or Mass Storage transfer and any flash write (this method is the only way to kill a
stuck flash transfer).
•Clears the previous command result
•Removes EXCLUSIVE_ACCESS  and remounts the Mass Storage drive if it was ejected due to exclusivity.
RP2350 Datasheet
5.6. USB PICOBOOT interface 410
Table 469. PICOBOOT
Reset PICOBOOT
interface controlbmRequestType bRequest wValue wIndex wLength Data
01000001b 01000001b 0000h Interface 0000h none
This command responds with an empty packet on success.
5.6.5.2. GET_COMMAND_STATUS ( 0x42)
Retrieve the status of the last command (which may be a command still in progress). Successful completion of a
PICOBOOT Protocol Command is acknowledged over the bulk pipe, however if the operation is still in progress or has
failed (stalling the bulk pipe), then this method can be used to determine the operation’s status.
Table 470. PICOBOOT
Get last command
status controlbmRequestType bRequest wValue wIndex wLength Data
11000001b 01000010b 0000h Interface 0000h none
The command responds with the following 16 byte response
Table 471. PICOBOOT
Get last command
status control
responseOffset Name Description
0x00 dToken The user token specified with the command
RP2350 Datasheet
5.6. USB PICOBOOT interface 411
Offset Name Description
0x04 dStatusCode OK (0) The command completed successfully (or is in still in
progress)
UNKNOWN_CMD  (1) The ID of the command was unrecognised
INVALID_CMD_LENGTH  (2) The length of the command request was incorrect
INVALID_TRANSFER_LENGTH  (3) The data transfer length was incorrect given the
command
INVALID_ADDRESS  (4) The address specified was invalid for the command type;
this means that the address didn’t match the type (flash or
RAM) that the command was expecting
BAD_ALIGNMENT  (5) The address specified was incorrectly aligned according
to the requirements of the command
INTERLEAVED_WRITE  (6) A Mass Storage Interface UF2 write has interfered with the
current operation. The command was abandoned with
unknown status. This doesn’t happen if you have exclusive
access.
REBOOTING  (7) The device is in the process of rebooting, so the command
has been ignored.
UNKNOWN_ERROR  (8) Some non-specific error occurred.
INVALID_STATE  (9) Something happened or failed to happen in the past, and
consequently the request can’t (currently) be serviced.
NOT_PERMITTED  (10) Permission violation, such as write to read-only flash
partition.
INVALID_ARG  (11) Argument is outside of range of supported values.
BUFFER_TOO_SMALL  (12) The provided buffer was too small to hold the result.
PRECONDITION_NOT_MET  (13) The operation failed because another bootrom function
must be called first.
MODIFIED_DATA  (14) Cached data was determined to be inconsistent with the
full version of the data it was calculated from.
INVALID_DATA  (15) A data structure failed to validate.
NOT_FOUND  (16) Attempted to access something that doesn’t exist; or a
search failed.
UNSUPPORTED_MODIFICATION  (17) Write is impossible based on previous writes, such as
attempting to clear an OTP bit.
0x08 bCmdId The ID of the command
0x09 bInProgress 1 if the command is still in
progress0 otherwise
0x0a reserved (6 zero bytes)
5.7. USB white-labelling
To brand RP2350-based products, customers may replace identifying information exposed by USB interfaces. We call
this white-labelling , and you can accomplish it in RP2350 by specifying values in OTP.
RP2350 Datasheet
5.7. USB white-labelling 412
1.Write the OTP location of the white-label data structure via USB_WHITE_LABEL_ADDR  (see that register description
for the data structure contents).
2.Initialise the fields you wish to override in the white-label data structure and mark them valid.
3.Set USB_BOOT_FLAGS .WHITE_LABEL_ADDR_VALID to mark the white-labelling as valid.
The following fields can be modified:
5.7.1. USB device descriptor
The USB device descriptor includes the following 16-bit values:
•VID (default 0x2e8a)
•PID (default 0x000f)
•BCD_DEVICE  (default 0x0100)
•LANG_ID (default 0x0409)
5.7.2. USB device strings
•MANUFACTURER  (default "Raspberry Pi", max-length 30 UTF-16 or ASCII chars)
•PRODUCT (default "RP2350 Boot", max-length 30 UTF-16 or ASCII chars)
•SERIAL_NUMBER  (default uppercase hex string of the device_id ; first 4 rows of OTP, max-length 30 UTF-16 or ASCII
chars)
5.7.3. USB configuration descriptor
The USB Configuration Description isn’t strictly white-labelling, but is still helpful for users:
•ATTRIBUTES_MAX_POWER_VALUES  (default 0xfa80, meaning bMaxPower  of 0xfa and bmAttributes=0x80 )
5.7.4. MSD drive
•VOLUME_LABEL  (default "RP2350", max-length 11 ASCII chars)
5.7.5. UF2 INDEX.HTM  file
This is of the form:
<html>
    <head>
        <meta http-equiv= "refresh"  content= "0;URL='*REDIRECT_URL*'" />
    </head>
    <body>Redirecting to <a href='`*REDIRECT_URL*' >`*REDIRECT_NAME* </a></body>
</html>
•REDIRECT_URL  (default "https://raspberrypi.com/device/RP2?version=5A09D5312E22", note the 12 hex digits are the
first 6 of the SYSINFO_GITREF_RP2350  and the first 6 of the bootrom gitref, max-length 127 ASCII chars)
•REDIRECT_NAME  (default "raspberrypi.com", max-length 127 ASCII chars)
RP2350 Datasheet
5.7. USB white-labelling 413
5.7.6. UF2 INFO_UF2.TXT file
This is of the form:
UF2 Bootloader v1.0
Model: MODEL
Board-ID: BOARD_ID
•MODEL (default "Raspberry Pi RP2350", max-length 127 ASCII chars)
•BOARD_ID  (default "RP2350", max-length 127 ASCII chars)
5.7.7. SCSI Inquiry
Returned via the SCSI Inquiry command:
•VENDOR (default "RPI", max-length 8 ASCII chars)
•PRODUCT (default "RP2350", max-length 16 ASCII chars)
•VERSION (default "1", max-length 4 ASCII chars)
5.7.8. Volume label simple example
Newer versions of picotool  can load white-label data from a JSON file using the picotool otp white-label -s <start row>
<JSON filename>  command. An example JSON file to set the volume label to "SPOON" would be:
{
    "volume" : {
        "label": "SPOON"
    }
}
The <start row>  is the OTP row where the white-label structure will be written - for example 0x400.
The full set of white-label fields which can be written using a JSON file are shown below. The manufacturer , product and
serial_number  fields support Unicode characters, if you need special characters or emoji in your product name, but this
will take up twice as much room per character in the OTP for that field.
{
    "device" : {
        "vid": "0x2e8b" ,
        "pid": "0x000e" ,
        "bcd": 2.15,
        "lang_id" : "0x0c09" ,
        "manufacturer" : "Test's Pis" ,
        "product" : "Test RP2350?" ,
        "serial_number" : "notnecessarilyanumber" ,
        "max_power" : "0x20",
        "attributes" : "0xe0"
    },
    "scsi": {
        "vendor" : "TestPi" ,
        "product" : "MyPi",
        "version" : "v897"
    },
RP2350 Datasheet
5.7. USB white-labelling 414
    "volume" : {
        "label": "TestPi Boot" ,
        "redirect_url" : "https://datasheets.raspberrypi.com/rp2350/rp2350-datasheet.pdf" ,
        "redirect_name" : "The datasheet" ,
        "model": "My Test Pi" ,
        "board_id" : "TPI-RP2350"
    }
}
5.7.9. Volume label in-depth example
The following example demonstrates how to manually change the volume label using picotool  to the value "SPOON":
1.First, define the row of white label structure to be 0x400:
$ picotool otp set -e OTP_DATA_USB_WHITE_LABEL_ADDR 0x400
2.Next, because the volume label is located at index 0x8 within OTP_DATA_USB_WHITE_LABEL_ADDR , write to 0x408. Define the
location of the volume label string to be offset from OTP_DATA_USB_WHITE_LABEL_ADDR  by 0x30. For this example,
"SPOON" has 5 characters, so we write 0x3005 to 0x408:
$ picotool otp set -e 0x408 0x3005
3.Then, write the "S" and "P" characters:
$ picotool otp set -e 0x430 0x5053
4.Then, write the "O" and "O" characters:
$ picotool otp set -e 0x431 0x4f4f
5.Then, write the "N" character:
$ picotool otp set -e 0x432 0x4e
6.Finally, enable the valid override to use the new values (bit 8 marks the VOLUME_LABEL  override as valid, and bit 22
marks the OTP_DATA_USB_WHITE_LABEL_ADDR  override as valid):
$ picotool otp set -r OTP_DATA_USB_BOOT_FLAGS 0x400100
7.To put your changes into effect, reboot the device:
$ picotool reboot -u
RP2350 Datasheet
5.7. USB white-labelling 415
5.8. UART boot
UART boot is a minimal interface for bootstrapping a flashless RP2350 from a simple host, such as another
microcontroller. It is available by default on a blank device, so it allows RP2350 to be deployed into the field on multi-
device boards without loading firmware or programming OTP bits in advance.
To select UART boot, drive QSPI CSn low (BOOTSEL mode) and drive QSPI SD1 high. The bootrom checks these signals
shortly after device reset is released. UART TX appears on QSPI SD2, and UART RX appears on QSPI SD3.
The UART mode is 8n1: one start bit, eight data bits, no parity, one stop bit. Data within each UART frame is sent and
received LSB-first. The baud rate is fixed at 1 Mbaud.
5.8.1. Baud rate and clock requirements
The nominal baud rate for UART boot is 1 Mbaud, divided from a nominal 48 MHz system clock frequency. UART boot
uses the USB PLL to derive the system clock and UART baud clock, so you must either provide a crystal or drive a stable
clock into the crystal oscillator XIN pad. The host baud rate must match the RP2350 baud rate within 3%.
By default the crystal is assumed to be 12 MHz, but the BOOTSEL_PLL_CFG  and BOOTSEL_XOSC_CFG  OTP locations
override this to achieve a nominal 48 MHz system clock from any supported crystal. The same OTP configuration is
used for both USB and UART boot.
TIP
You may drive a somewhat faster or slower clock into XIN without any OTP configuration, if you scale your UART
baud rate appropriately. The permissible range is 7.5 to 16 MHz on XIN, limited by the PLL VCO frequency range.
5.8.2. UART boot shell protocol
After the bootrom samples QSPI CSn and SD1, there will be a delay of several milliseconds as the bootrom goes through
some necessary steps such as switching from the ring oscillator to the PLL, and erasing SRAM before releasing it to the
Non-secure UART bootloader.
The UART bootloader signals it is ready to begin by printing the ASCII splash string RP2350. In bytes, this is 0x52, 0x50, 0x32,
0x33, 0x35, 0x30.
Before sending any commands, you must send a special knock sequence to unlock the interface. This is a measure to
avoid transient effects due to noise on GPIOs and ensure the host and device are initially well-synchronised. The
sequence is: 0x56, 0xff, 0x8b, 0xe4. This is the RP2040 UF2 family ID, chosen as a well-known magic number. Any
sequence of bytes ending with this four-byte sequence is detected.
A UART boot shell command is always in the host-to-device direction (RP2350 receives), and consists of a single
command byte, optionally followed by a 32-byte write payload. RP2350 responds with an optional 32-byte read payload
followed by an echo of the command byte. You should wait for the command echo before sending the next command.
The supported commands are:
Command
(ASCII)Command
(hex)Description
n 0x6e No-op. Do nothing, and report back when you’ve done it. Used to ping the interface when
recovering lost synchronisation. Echoes the command byte, 'n'.
w 0x77 Write a 32-byte payload to the current value of the read/write pointer. Increment the address
pointer by 32. Echoes the command byte, 'w', once all 32 bytes are written to memory.
r 0x72 Read a 32-byte payload from the current value of the read/write pointer. Increment the
address pointer by 32. Echoes the command byte, 'r', after transmitting the 32-byte read
payload.
RP2350 Datasheet
5.8. UART boot 416
Command
(ASCII)Command
(hex)Description
c 0x63 Clear the read/write pointer. The pointer resets to the first location in SRAM 0x20000000 , and
you can begin a new read or write sequence from there. Echoes the command byte, 'c'.
x 0x78 Execute the payload that has been written to memory. Echoes the command byte, 'x', and
then reboots, passing a RAM boot search window spanning all of main SRAM. If a valid binary
was successfully written into SRAM before sending this command, it will execute.
Unrecognised commands are echoed with no other effect. More commands may be added in future versions.
5.8.3. UART boot programming flow
1.Reset or power down the RP2350 device.
2.Drive CSn low to select BOOTSEL, and SD1 high to select UART.
3.Release the reset or power up the device.
4.Wait for the splash string to be transmitted on QSPI SD2 (TX).
5.Transmit the knock sequence 0x56, 0xff, 0x8b, 0xe4 on QSPI SD3 (RX)
6.Send a 'n' nop command to ensure the interface is awake; if there is no reply, send the knock sequence again.
7.Send 'w' commands until your entire write payload transfers.
8.(Optional) Send a 'c' clear command to reset the address pointer, and then send 'r' read commands to read back
and verify the payload.
9.Send an 'x' execute command to attempt to run the payload.
There is no feedback from UART boot after echoing the final 'x' command. At this point the device reboots to attempt a
RAM image boot on the data loaded by the Non-secure UART bootloader. If the RAM image boot fails, the bootrom falls
through to the next boot source, continuing the normal boot flow. Maintaining CSn driven low and SD1 driven high will
cause the bootrom to fall through back to UART boot a second time, re-sending the UART splash screen: this indicates
the bootrom failed to recognise the UART boot binary.
5.8.4. Recovering from a stuck interface
Noise on the GPIOs may cause the UART boot shell to stop replying to commands, for example because it thinks the
host is part way through a write payload, and the host thinks that it is not. To resynchronise to the start of the next
command:
1.Wait 1 ms for the link to quiesce
2.Send 33 'n' NOP commands (size of longest command)
3.Wait 1 ms and flush your receive data
4.Send 1 'n' NOP command and confirm the device responds with an echoed NOP
If the interface fails to recover, reboot the device and try again. Failure may be caused by:
•Noise on GPIOs (particularly over long traces or wires)
•Incorrect baud rate matching
•An unstable frequency reference on XOSC XIN
•Mismatch of voltage levels (for example a QSPI_IOVDD of 1.8 V on RP2350, and a 3.3 V IO voltage on the host)
RP2350 Datasheet
5.8. UART boot 417
5.8.5. Requirements for UART boot binaries
A UART boot binary is a normal RAM binary. It must have a valid IMAGE_DEF  in order for the boot path to recognise it as a
bootable binary. The search window for the IMAGE_DEF  is the whole of SRAM, but it’s recommended to place it close to
the beginning, because the bootrom searches linearly forward for the beginning of the IMAGE_DEF .
The maximum size for a UART boot binary is the entirety of main SRAM: 520 kB, or 532 480 bytes.
UART boot only supports loading to the start of SRAM, so your binary must be linked to run at address 0x20000000 .
Sparse loading is unsupported. Your program must load as a single flat binary image.
All security requirements relating to RAM image boot apply to UART boot too. If secure boot is enabled, your binary
must be signed. Likewise, if OTP anti-rollback versioning is in effect, your binary’s rollback version must be no lower
than the version number stored in OTP.
5.9. Metadata block details
5.9.1. Blocks and block loops
Blocks consist of a fixed 32-bit header, one or more items , a 32-bit relative offset to the next block, and a fixed 32-bit
footer. All multi-byte values within a block are little-endian. Blocks must start on a word-aligned boundary, and the total
size is always an exact number of words (a multiple of four bytes).
The final item in a block must be of type PICOBIN_BLOCK_ITEM_LAST , which encodes the total word count of the block’s
items.
The 32-bit relative link forms a linked list of blocks. To be valid, this linked list must eventually link back to the first block
in the list, forming a closed block loop ; failure to close the loop results in the entire linked list being ignored. The loop
rule is used to avoid treating orphaned blocks from partially overwritten images being treated as valid.
Due to RAM restrictions in the boot path, size of blocks is limited to 640 bytes for PARTITION_TABLE s and 384 bytes for
IMAGE_DEF s. Blocks larger than this are ignored.
The format of a simple block with two items is shown:
Item Word Bytes Value
HEADER 0 4 0xffffded3
ITEM 0 1 1 size_flag:1  (0 means 1-byte size, 1 means 2-byte size), item_type:7
1 s0 % 256
1 s0 / 256  if size_flag  == 1 or type-specific data for blocks that are never > 256
words
1 Type-specific data
… … …
ITEM 1 1 + s0 1 size_flag:1  (0 means 1-byte size, 1 means 2-byte size), item_type:7
1 s1 % 256
1 s1 / 256  if size_flag  == 1 or type-specific data for blocks that are never > 256
words
1 Type-specific data
… … …
RP2350 Datasheet
5.9. Metadata block details 418
Item Word Bytes Value
LAST_ITEM 1 + s0 + s1 1 0xff (size_flag  == 1, item type  == BLOCK_ITEM_LAST )
2 s1 + s2 (other items' size)
1 0x00 (pad)
LINK 2 + s0 + s1 4 Relative position in bytes of next block HEADER relative to this block’s HEADER. this
forms a loop, so a single block loop has 0 here.
FOOTER 3 + s0 + s1 4 0xab123579
IMAGE_DEF  and PARTITION_TABLE  blocks are recognised by their first item being an IMAGE_DEF  or PARTITION_TABLE  item.
Constants describing blocks can be found in the SDK in picobin.h  in the SDK .
5.9.2. Common block items
The following items might appear in a IMAGE_DEF  or a PARTITION_TABLE  block.
5.9.2.1. VERSION item
A major/minor version number for the binary, 32 bits total, plus optionally a 16-bit rollback version and a list of OTP
rows which can be read to determine the (thermometer-coded) minimum major rollback version which this device will
allow to be installed. The major and minor are always present, whereas the rollback version and OTP row list are
generally only included if rollback protection is required.
NOTE
The rollback version and OTP row list are only valid for IMAGE_DEF s, and are ignored on a RP2350 that hasn’t been
secured.
If the number of OTP row entries is zero, there is no rollback version for this block.
Word Bytes Value
0 1 0x48 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_1BS_VERSION )
1 2 + ((num_otp_row_entries != 0) + num_row_entries + 1) / 2
1 0x00 (pad)
1 num_otp_row_entries
1 2 Minor Version
2 Major Version
(2) (2) Rollback version (if num_otp_entries  != 0)
(2) First 16-bit OTP Row index (if num_otp_entries  != 0`)
… … Remaining 16-OTP Row indexes (padded with a zero to make a word boundary if necessary)
Each OTP row entry indicates the row number (1 through 4095 inclusive) of the first in a group of 3 OTP rows. The three
OTP rows are each read as a 24 bit raw value, combined via a bitwise majority vote, and then the index of the most-
significant 1 bit determines the version number. So, a single group of three rows can encode rollback versions from 0 to
23 inclusive, or, when all 24 bits are set, an indeterminate version of at least 24. Each additional OTP row index indicates
a further group of 3 rows that increases the maximum version by 24.
There is no requirement for different OTP row entries to be contiguous in OTP. They should not overlap, though the
RP2350 Datasheet
5.9. Metadata block details 419
bootrom doesn’t need to check this (the boot signing tool may).
NOTE
For this entry to be considered valid, the number of available bits in the indicated OTP rows must be strictly greater
than  the rollback version. This means that it is always possible to determine that the device’s minimum rollback
version is greater than the rollback version indicated in this block, even if we don’t know the full list of OTP rows
used by later major versions.
The major/minor version are used to disambiguate which is newer out of two binaries with the same major rollback
version. For example, to select which A/B image to boot from. when no major rollback version is specified, A/B
comparisons will treat the missing major version as zero, but no rollback check will be performed.
5.9.2.2. HASH_DEF item
Optional item with information about what how to hash:
Word Bytes Value
0 1 0x47 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_1BS_HASH_DEF )
1 0x03 (size_lo )
1 0x00 (pad)
1 0x01 (PICOBIN_HASH_SHA-256 )
1 2 Number of words of block hashed (not including HEADER word at the start of the block)
2 0x0000 (pad)
block_words_hashed  must include this item if using this item for a signature.
The most recent LOAD_MAP  item (see Section 5.9.3.2 ) that defines what  to hash.
5.9.2.3. HASH_VALUE item
Optional item containing a hash value that can be used by the bootrom to verify the hash of an image or partition table
when not using signatures.
Word Bytes Value
0 1 0x09 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_HASH_VALUE )
1 0x01 + n  where n is the number of hash words included (1-8)
2 0x0000 (pad)
1 4 Hash Value (lowest significant 32 bits)
… … …
n 4 Hash Value (highest significant 32 bits)
RP2350 Datasheet
5.9. Metadata block details 420
TIP
Whilst a SHA-256 hash is 8 words, you can include fewer (down to 1 word) to save space if you like, and only that
many words will be compared against the full 8-word hash at runtime.
This HASH_VALUE  item is paired with the most recent HASH_DEF  item ( Section 5.9.2.2 ) which defines what is being hashed.
5.9.2.4. SIGNATURE item
Optional item containing cryptographic signature that can be used by the bootrom to signature check the hashed
contents of an image or partition table.
Word Bytes Value
0 1 0x4b (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_SIGNATURE )
1 0x21 (Block size in words)
1 0x00 (pad)
1 0x01 (PICOBIN_SIGNATURE_SECP256K1 )
1 4 Public Key (lowest significant 32 bits)
… … …
16 4 Public Key (highest significant 32 bits)
17 4 Signature of hash (lowest significant 32 bits)
… … …
32 4 Signature of hash (highest significant 32 bits)
This SIGNATURE  item is paired with the most recent HASH_DEF  item ( Section 5.9.2.2 ) which defines what the hash value
whose signature is checked.
5.9.3. Image definition items
5.9.3.1. IMAGE_DEF item
The IMAGE_DEF  item must be the first item within an Image Definition:
Word Bytes Value
0 1 0x42 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_1BS_IMAGE_TYPE )
1 0x01 (Block size in words)
2 image_type_flags
The flags are defined in the SDK in picobin.h  in the SDK , but are summarised here:
Bits Field Values
0-3 Image Type 0 IMAGE_TYPE_INVALID
1 IMAGE_TYPE_EXE : Image is executable
2 IMAGE_TYPE_DATA : Image is valid, but is not intended to be executed
3 reserved
RP2350 Datasheet
5.9. Metadata block details 421
Bits Field Values
The remaining bits are specific to the Image Type Values are only currently defined for the EXE Image Type:
4-5 EXE Security 0 EXE_SECURITY_UNSPECIFIED
1 EXE_SECURITY_NS : Image runs in Non-secure mode
2 EXE_SECURITY_S : Image runs in Secure mode
3 reserved
6-7 reserved 0
8-10 EXE CPU 0 EXE_CPU_ARM : Image is for the Arm architecture
1 EXE_CPU_RISCV : Image is for the RISC-V architecture
2-7 reserved
11 reserved 0
12-14 EXE CHIP 0 EXE_CHIP_RP2040
1 EXE_CHIP_RP2350
2-7 reserved
15 EXE TBYB 0 not set
1 EXE_TBYB : Image is flagged for "Try Before You Buy"
5.9.3.2. LOAD_MAP item
Optional item with a similar representation to the ELF program header. This is used both to define the content to hash,
and also to "load" data before image execution. For example, a secure flash binary can be loaded into RAM prior to both
signature check and execution.
The load map is a collection of runtime address, physical address, size and flags.
1.For a "packaged" binary, the information tells the bootrom where to load the code/data.
2.For a hashed or signed binary, the runtime addresses and size indicate code/data that must be included in the
hash to be verified or signature checked.
NOTE
If the runtime_address is in equal to the storage_address, then data is never copied, it is just hashed in place.
Explanation of terms:
physical address
Where the data is stored in the logical address space of the image. For instance, the start of a flash image, even if
stored in a partition, could have a physical address of 0x10000000 . The closest ELF concept is LMA.
runtime address
The address of the data at runtime. The closest ELF concept is VMA.
storage address
an absolute location where the data is stored in flash. Not necessarily the same as physical address for flash when
partitions are in use.
RP2350 uses physical addresses in the LOAD_MAP , not storage addresses, since this data is written by a tool working on
the ELF which will not necessarily know where the binary will finally be stored in flash.
This serves several purposes:
RP2350 Datasheet
5.9. Metadata block details 422
Word Bytes Value
0 1 0x06 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_LOAD_MAP )
2 1 + num_entries * 3  (Block size in words)
1 absolute:1 , num_entries:7
1-3 Load Map Entry 0
4 •if absolute  == 0
storage_start_address_rel  (storage start address relative to the address of this
LOAD_MAP item)
•if absolute  == 1
storage_start_address  (absolute storage start address)
Note: If this value is 0x00000000  irrespective of the value of the absolute  flag, then the runtime
address range is filled with zeros. In this case, the 32 bit size itself is hashed rather than size
zero bytes.
4 runtime_start_address  (absolute runtime start address)
4 •if absolute  == 0
size (of memory range in bytes)
•if absolute  == 1
storage_end_address  (absolute storage end address)
(4-6) (Load Map Entry 1)
… …
All addresses must be word aligned, and sizes a multiple of 4. In RP2350 A3 and earlier, the bootrom allowed sizes
which weren’t multiples of 4 in some cases, but may not have functioned correctly.
5.9.3.2.1. XIP pinning via LOAD_MAP
Normally, when entering a binary, the XIP cache is un-pinned and flushed. This makes sense both for entering a flash
binary, and for security purposes.
If, however, you have a non-flash binary with code or data in the XIP RAM address space, then you need to add a special
LOAD_MAP  entry to indicate to the bootrom that the XIP contents should be pinned.
Any load-map entry (with storage_address  == runtime_address ) and a valid size of greater than zero will suffice, as for
example in this simple load map:
Word Bytes Value
0 1 0x06 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_LOAD_MAP )
2 0x04 (Block size in words)
1 0x81 (absolute  == 1, num_entries  == 1)
1-3 Load Map Entry 0
4 XIP_SRAM_BASE  (storage_start_address )
4 XIP_SRAM_BASE  (runtime_start_address )
4 0x04 (size in bytes)
RP2350 Datasheet
5.9. Metadata block details 423
5.9.3.3. VECTOR_TABLE item
Optional Arm only item for that specifies the location of the initial Arm vector table. The entry_point/initial_sp will be
taken from here if present (unless there is also an ENTRY_POINT  Item). If there is no ENTRY_POINT  or VECTOR_TABLE  Item, then
the Arm vector table is assumed to be at the start of the image.
Word Bytes Value
0 1 0x03 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_1BS_VECTOR_TABLE )
1 0x02 (Block size in words)
2 0x0000 (pad)
1 4 Vector table (runtime) address
NOTE
The VECTOR_TABLE  Item is ignored on RISC-V.
5.9.3.4. ENTRY_POINT item
Optional item with info on initial PC, SP, and optionally the SP limit
Word Bytes Value
0 1 0x44 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_1BS_ENTRY_POINT )
1 0x03 or 0x04 (Block size in words)
2 0x0000 (pad)
1 4 Inital PC (runtime) address (aka entry point)
2 4 Initial SP address (aka stack pointer)
(3) 4 Optional SP limit address (aka stack limit)
5.9.3.5. ROLLING_WINDOW_DELTA item
Optional item that allow for binaries that aren’t intended to be run at 0x10000000 . Note that this delta is in addition to the
roll resulting from the binary being stored in a partition in flash.
Word Bytes Value
0 1 0x05 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_1BS_ROLLING_WINDOW_DELTA )
1 0x02 (Block size in words)
2 0x0000 (pad)
1 4 signed 32 bit delta
The delta is the number of bytes into the image that 0x10000000  should be mapped.
If positive, the delta must be a multiple of 4 kB, and allows for "skipping over" other data before the start of the binary. If
negative, the delta must be a multiple of 4 MB, and allows for running flash binaries linked to run at 0x10400000 , 0x01080000
and 0x010c0000  as well as the standard 0x10000000
RP2350 Datasheet
5.9. Metadata block details 424
NOTE
The ROLLING_WINDOW_DELTA  Item is ignored for non-flash binaries.
5.9.4. Partition table items
Partition tables allows dividing the 32 MB flash region (2 × 16 MB) into partitions. Permissions and other partition
attributes may be specified for each partition, along with permissions for the un-partitioned space.
The permission specify read/write access for Secure code, Non-secure code, and "NSBoot" which refers to the boot
loader (and PICOBOOT)
NOTE
These permissions are only advisory to Secure code, however they are respected by flash_op() , the PICOBOOT flash
access commands, and UF2 downloads.
5.9.4.1. PARTITION_TABLE item
Word Bytes Value
0 1 0x44 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_PARTITION_TABLE )
2 Block size in words
1 singleton_flag:1 , pad:3  , partition_count:4
1 4 unpartitioned_space_permissions_and_flags
Partition 0
2 4 permissions_and_location  for partition 0
3 4 permissions_and_flags  for partition 0
if _partition_0_has_id :
3 4 partition_0_ID_lo
4 4 partition_0_ID_hi
one word per additional family ID (can be none):
x 4 partition_0_family ID_0
x + 1 4 partition_0_family ID_1
… …
if _partition_0_has_name :
y 1 reserved:1  (0), name_len_bytes:7
1 partition_0_name_byte_0
1 partition_0_name_byte_1
1 partition_0_name_byte_2
RP2350 Datasheet
5.9. Metadata block details 425
Word Bytes Value
y+1 1 partition_0_name_byte_3
1 partition_0_name_byte_4
1 partition_0_name_byte_5
1 partition_0_name_byte_6
… … …
? partition_0_name_byte_n_minus_x  to partition_0_name_byte_n_minus_2
1 partition_0_name_byte_n_minus_1
? (padding zero bytes to reach word alignment)
(Partition 1)
… … …
5.9.4.2. Partition location, permissions, and flags
Two common words are stored in the partition table for both un-partitioned space and each partition. These common
words describe the size/location, along with access permissions and various flags.
The permission fields are repeated in both words, hence the two words are permissions_and_location  and
permissions_and_flags .
Table 472. Permission
Fields. 'P' means the
field applies to
partitions, 'U' means
the field applies to un-
partitioned space,
however the word
"partition" is always
used in the descriptionMask AppliesTo Description
0x04000000u 'P' 'U'PERMISSION_S_R_BITS
If set, the partition is readable by Secure code. See Section 5.1.3
0x08000000u 'P' 'U'PERMISSION_S_W_BITS
If set, the partition is writable by Secure code. See Section 5.1.3
0x10000000u 'P' 'U'PERMISSION_NS_R_BITS
If set, the partition is readable by Non-secure code. See Section 5.1.3
0x20000000u 'P' 'U'PERMISSION_NS_W_BITS
If set, the partition is writable by Non-secure code. See Section 5.1.3
0x40000000u 'P' 'U'PERMISSION_NSBOOT_R_BITS
If set, the partition is readable by NSBOOT (boot loader) Secure code. See Section 5.1.3
0x80000000u 'P' 'U'PERMISSION_NSBOOT_W_BITS
If set, the partition is writable by NSBOOT (boot loader) Secure code. See Section 5.1.3
Table 473. Location
Fields. 'P' means the
field applies to
partitions, 'U' means
the field applies to un-
partitioned space,
however the word
"partition" is always
used in the descriptionMask AppliesTo Description
0x00001fffu 'P' 'U'LOCATION_FIRST_SECTOR_BITS
The sector number (0-4095) of the first sector in the partition (a sector is 4 kB)
0x03ffe000u 'P' 'U'LOCATION_LAST_SECTOR_BITS
The sector number (0-4095) of the last sector in the partition (a sector is 4 kB)
RP2350 Datasheet
5.9. Metadata block details 426
Table 474. Flags
Fields. 'P' means the
field applies to
partitions, 'U' means
the field applies to un-
partitioned space,
however the word
"partition" is always
used in the descriptionMask AppliesTo Description
0x00000001u 'P' FLAGS_HAS_ID_BITS
If set, the partition has a 64 bit identifier
0x00000006u 'P' FLAGS_LINK_TYPE_BITS
The type of link stored in the partition:
•0x0 - None
•0x1 - A_PARTITION  : This is a "B" partition, and The LINK_VALUE  field stores the partition
number of the corresponding "A" partition
•0x2 - OWNER : This is an "A" partition, and the LINK_VALUE  field stores the partition number of
the owning partition (which should also be an "A" partition).
0x00000078u 'P' FLAGS_LINK_VALUE_BITS
If LINK_TYPE  is non zero, then this field holds the partition number of the linked partition.
0x00000180u 'P' FLAGS_ACCEPTS_NUM_EXTRA_FAMILIES_BITS
0-3 the number of extra non-standard UF2 family ids the partition accepts.
0x00000200u 'P' FLAGS_NOT_BOOTABLE_ARM_BITS
If set then this partition is marked non-bootable on Arm, and will be ignored during Arm boot.
Setting this for non Arm bootable partitions can improve boot performance.
0x00000400u 'P' FLAGS_NOT_BOOTABLE_RISCV_BITS
If set then this partition is marked non-bootable on RISC-V, and will be ignored during RISC-V
boot. Setting this for non RISC-V bootable partitions can improve boot performance.
0x00000800u 'P' FLAGS_UF2_DOWNLOAD_AB_NON_BOOTABLE_OWNER_AFFINITY
0x00001000u 'P' FLAGS_HAS_NAME_BITS
If set, the partition has a name.
0x00002000u 'P' 'U'FLAGS_UF2_DOWNLOAD_NO_REBOOT_BITS
If set, the RP2350 will not reboot after dragging a UF2 into this partition.
0x00004000u 'P' 'U'FLAGS_ACCEPTS_DEFAULT_FAMILY_RP2040_BITS
If set, a UF2 with the RP2040  family id 0xe48bff56  may be downloaded into this partition.
0x00008000u 'U' FLAGS_ACCEPTS_DEFAULT_FAMILY_ABSOLUTE_BITS
If set for un-partitioned spaced, a UF2 with the ABSOLUTE  family id 0xe48bff57  may be
downloaded onto the RP2350 and will be written at the addresses specified in the UF2 without
regard to partition locations. Partition-defined flash access permissions are still respected
(the UF2 download will fail if it needs to write over a read-only region of flash).
0x00010000u 'P' 'U'FLAGS_ACCEPTS_DEFAULT_FAMILY_DATA_BITS
If set, a UF2 with the DATA family id 0xe48bff58  may be downloaded into this partition.
0x00020000u 'P' 'U'FLAGS_ACCEPTS_DEFAULT_FAMILY_RP2350_ARM_S_BITS
If set, a UF2 with the RP2350_ARM_S  family id 0xe48bff59  may be downloaded into this partition.
0x00040000u 'P' 'U'FLAGS_ACCEPTS_DEFAULT_FAMILY_RP2350_RISCV_BITS
If set, a UF2 with the RP2350_RISC_V  family id 0xe48bff5a  may be downloaded into this partition.
RP2350 Datasheet
5.9. Metadata block details 427
Mask AppliesTo Description
0x00080000u 'P' 'U'FLAGS_ACCEPTS_DEFAULT_FAMILY_RP2350_ARM_NS_BITS
If set, a UF2 with the RP2350_ARM_NS  family id 0xe48bff5b  may be downloaded into this partition.
0x03f00000u 'P' 'U'reserved; should be 0
5.9.5. Minimum viable image metadata
A minimum amount of metadata (a valid IMAGE_DEF  block) must be embedded in any binary for the bootrom to recognise
it as a valid program image, as opposed to, for example, blank flash contents or a disconnected flash device. This must
appear within the first 4 kB of a flash image, or anywhere in a RAM or OTP image.
Unlike RP2040, there is no requirement for flash binaries to have a checksummed "boot2" flash setup function at flash
address 0. The RP2350 bootrom performs a simple best-effort XIP setup during flash scanning, and a flash-resident
program can continue executing in this state, or can choose to reconfigure the QSPI interface at a later time for best
performance.
5.9.5.1. Minimum Arm IMAGE_DEF
Assuming CRIT1 .SECURE_BOOT_ENABLE is clear, the minimum valid IMAGE_DEF  is the following 20-byte sequence:
Word LE Value Bytes Description
0 0xffffded3 4 PICOBIN_BLOCK_MARKER_START
1 0x10210142 1 0x42(item_type == PICOBIN_BLOCK_ITEM_1BS_IMAGE_TYPE )
1 0x01 (Item is 1 word in size)
2 0x1021
(PICOBIN_IMAGE_TYPE_IMAGE_TYPE_AS_BITS(EXE)  |
PICOBIN_IMAGE_TYPE_EXE_SECURITY_AS_BITS(S)  |
PICOBIN_IMAGE_TYPE_EXE_CPU_AS_BITS(Arm)  |
PICOBIN_IMAGE_TYPE_EXE_CHIP_AS_BITS(RP23500) )
2 0x000001ff 1 0xff(size_type  == 1, item_type_  == PICOBIN_BLOCK_ITEM_2BS_LAST )
2 0x0001 (size)
1 0x00 (pad)
3 0x00000000 4 Relative pointer to next block in block loop - 0x00000000  means link to self (a loop
containing just this block)
4 0xab123579 4 PICOBIN_BLOCK_MARKER_END
The LE Value  column indicates a 32-bit little-endian value that should appear verbatim in your program image.
Since the above block does not specify an explicit entry point, the bootrom will assume the binary starts with a Cortex-M
vector table, and enter via the reset handler and initial stack pointer specified in that table (offsets +4 and +0 bytes into
the table). An explicit vector table pointer can be provided by a PICOBIN_BLOCK_ITEM_1BS_VECTOR_TABLE  item, or the entry
point can be specified directly by a PICOBIN_BLOCK_ITEM_1BS_ENTRY_POINT  item.
5.9.5.2. Minimum RISC-V IMAGE_DEF
The minimum valid IMAGE_DEF  is the following 20-byte sequence:
RP2350 Datasheet
5.9. Metadata block details 428
Word LE Value Bytes Description
0 0xffffded3 4 PICOBIN_BLOCK_MARKER_START
1 0x11010142 1 0x42(item_type == PICOBIN_BLOCK_ITEM_1BS_IMAGE_TYPE )
1 0x01 (Item is 1 word in size)
2 0x1101
(PICOBIN_IMAGE_TYPE_IMAGE_TYPE_AS_BITS(EXE)  |
PICOBIN_IMAGE_TYPE_EXE_CPU_AS_BITS(RISCV)  |
PICOBIN_IMAGE_TYPE_EXE_CHIP_AS_BITS(RP23500) )
2 0x000001ff 1 0xff(size_type  == 1, item_type_  == PICOBIN_BLOCK_ITEM_2BS_LAST )
2 0x0001 (size)
1 0x00 (pad)
3 0x00000000 4 Relative pointer to next block in block loop - 0x00000000  means link to self (a loop
containing just this block)
4 0xab123579 4 PICOBIN_BLOCK_MARKER_END
The LE Value  column indicates a 32-bit little-endian value that should appear verbatim in your program image.
Since the above block does not specify an explicit entry point, the bootrom will enter the binary at its lowest address,
which is the default behaviour on RISC-V. This default entry point can be overridden by a
PICOBIN_BLOCK_ITEM_1BS_ENTRY_POINT  item. Note that PICOBIN_BLOCK_ITEM_1BS_VECTOR_TABLE  is not valid on RISC-V, as unlike
Cortex-M the RISC-V vector table does not define the program entry point.
5.10. Example boot scenarios
This section describes the setup and configuration steps for various different boot scenarios.
5.10.1. Secure boot
To enable secure boot on RP2350, you must:
1.Set the SHA-256 hashes of the boot keys you will be using in BOOTKEY0_0  onwards
2.Set bits in BOOT_FLAGS1 .KEY_VALID for the keys you will be using
3.Optionally set bits in BOOT_FLAGS1 .KEY_INVALID for all unused keys — this is recommended to prevent a
malicious actor installing their own boot keys at a later date
4.Set CRIT1 .SECURE_BOOT_ENABLE to turn on secure boot.
NOTE
These steps are the minimum for enabling secure boot support in the bootrom . See Section 10.5  for additional steps
you must take to fully secure your device, such as disabling hardware debug.
All of the above can be achieved with picotool . For example, when signing using picotool seal  you can add an OTP JSON
output file, to which it will add the relevant OTP field values to enable secure boot ( BOOTKEY0_0 ,
BOOT_FLAGS1 .KEY_VALID and CRIT1 .SECURE_BOOT_ENABLE):
RP2350 Datasheet
5.10. Example boot scenarios 429
$ picotool seal --sign unsigned.elf signed.elf private.pem /path/to/otp.json
To configure the SDK to output this OTP JSON file when signing, add the following command to your CMakeLists.txt :
pico_set_otp_key_output_file (target_name /path/to/otp.json )
You can then issue the following command to write this OTP JSON file to the device, thus enabling secure boot:
$ picotool otp load /path/to/otp.json
Once secure boot is enabled, the bootrom verifies signatures of images from all supported media: flash, OTP, and
images preloaded into SRAM via the UART and USB bootloaders. At this point you lose the ability to run unsigned
images; during development you may find it more convenient to leave secure boot disabled. The next section describes
the generation of signed images  to run on a secure-boot-enabled device.
5.10.2. Signed images
TIP
This section refers to the concepts of block loops  and image definitions  (and the associated IMAGE_DEF  data
structure) described in Section 5.1 . You should read the bootrom concepts section before this one.
An example of an image (and its block loop) produced by the SDK is shown below.
RP2350 Datasheet
5.10. Example boot scenarios 430
Block LoopIMAGE_DEF Item
IGNORED ItemVector table
DataInitial Metadata Block (must be in first 4kB)
Empty Block(placed at the end by default to catch overwrite at the end of the binary)Code
The first block must be within the first 4 kB of the image, and is an IMAGE_DEF  block describing the image. This block is
linking to an empty block at the end of the image, that is included in the block loop to help detect partially written
binaries. If the end of the image is missing or overwritten, then the block loop not be properly closed and will be
considered invalid.
picotool  can be used to sign a binary, in which case it modifies the image as follows:
RP2350 Datasheet
5.10. Example boot scenarios 431
IMAGE_DEF ItemIGNORED Item
LOAD_MAP Item
HASH_DEF Item
SIGNATURE Item
HASH_VALUE ItemBlock LoopLOAD_MAPentry covers this regionorIMAGE_DEF Item(this will be superceded by later IMAGE_DEF in the block loop)Vector table
Data
Signature BlockInitial Metadata Block (must be in first 4kB)
Code
Note that the marker block at the end of the image has been replaced with a new IMAGE_DEF  block including the first
block’s information along with additional new information. The new information includes the signature (or hash value if
hashing only), along with a LOAD_MAP  entry indicating the regions of the image that are signed or hashed.
At runtime, the bootrom will pick the last valid IMAGE_DEF  in the block loop as the one to boot.
Signing requires a SHA-256 hash of the data specified in the LOAD_MAP , along with the words of the block specified by the
HASH_VALUE  Item (which must include the first word of the SIGNATURE Item). This hash is then signed with an ECDSA
secp256k1 private key, to produce the 64 byte signature stored in the SIGNATURE Item.
For secure boot, it is recommended to use packaged SRAM binaries instead of flash binaries, as the signature check is
only performed during boot, so a malicious actor with physical access could replace the data on the external flash after
the signature check to run unsigned code.
To sign and/or hash a binary in the SDK, you can add the following functions to your CMakeLists.txt file:
pico_sign_binary (target_name /path/to/keyfile.pem )
pico_hash_binary (target_name )
This will invoke the picotool seal  command to sign and/or hash your binary when you call pico_add_extra_outputs . You
can manually invoke picotool seal  to sign and/or hash a binary using:
$ picotool seal --sign --hash unsigned.elf signed.elf private.pem
RP2350 Datasheet
5.10. Example boot scenarios 432
5.10.3. Packaged binaries
A packaged binary is an SRAM/XIP RAM-only binary that has been post-processed for storage in flash. To create a
packaged SRAM binary, you can take a binary compiled to run in SRAM ( no_flash  binary in the SDK) and add a relative
LOAD_MAP  Item into the IMAGE_DEF  block, with the runtime address(es) in SRAM. The subsequent binary can then be run
normally from RAM, or stored in flash to be loaded into RAM by the bootrom. This LOAD_MAP  item will be added to all
binaries when using picotool seal .
To package binaries in the SDK, add the following to your CMakeLists.txt file. This will target the UF2 file to the start of
flash when dragged and dropped, and will invoke picotool seal  to add an appropriate LOAD_MAP .
pico_package_uf2_output (target_name 0x10000000 )
Alternatively, you can use an absolute LOAD_MAP , with the storage_address in flash and the runtime_address in SRAM.
However, these binaries can only run after storing in flash and can’t be booted directly in SRAM for debugging.
For example, if you have a binary compiled to run at 0x20000000  of length 0x8000, and a metadata block at the end of the
binary containing the LOAD_MAP  as the second Item (after the IMAGE_DEF , which means the LOAD_MAP  is 8 bytes into the
block), then the relative LOAD_MAP  would be:
Word Bytes Value
0 1 0x06 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_LOAD_MAP )
2 0x04 (Block size in words)
1 0x01 (absolute  == 0, num_entries  == 1)
1-3 Load Map Entry 0
4 -0x8008 = 0xFFFF7FF8  (storage_start_address_rel )
4 0x20000000  (runtime_start_address )
4 0x8000 (size in bytes)
The absolute LOAD_MAP  would be:
Word Bytes Value
0 1 0x06 (size_flag  == 0, item_type  == PICOBIN_BLOCK_ITEM_LOAD_MAP )
2 0x04 (Block size in words)
1 0x81 (absolute  == 1, num_entries  == 1)
1-3 Load Map Entry 0
4 0x10000000  (storage_start_address )
4 0x20000000  (runtime_start_address )
4 0x20008000  (runtime_end_address )
5.10.4. A/B booting
This is a common boot scenario, to be able to update the software without overwriting it. A simple partition layout
would be:
RP2350 Datasheet
5.10. Example boot scenarios 433
Partition 0
  Accepts UF2 Families: rp2350-arm-s, rp2350-riscv
Partition 1
  Accepts UF2 Families: rp2350-arm-s, rp2350-riscv
  Link Type: "A"
  Link Value: 0
This is a partition table with 2 partitions, where partition 0 is the A partition of partition 1 (which is thus the B partition).
NOTE
To avoid confusion, it is a recommended best practice to have the same permissions for both partitions, and for
both partitions to accept the same UF2 families. The bootrom will only look at the UF2 families from the A partition
when deciding if a given A/B pair accepts a particular family, and will not allow download to partition A even if it is
writable if partition B isn’t.
When dragging a UF2 to the device, it will target whichever partition is not currently booting. The bootrom will then
perform a FLASH_UPDATE  boot into the new binary (see Section 5.1.16 )
NOTE
When starting with blank A/B partitions, the first download actually goes into partition B.
To create the partition table above with picotool partition create , the following json could be used:
{
  "version" : [1, 0],
  "unpartitioned" : {
    "families" : ["absolute" ],
    "permissions" : {
      "secure" : "rw",
      "nonsecure" : "rw",
      "bootloader" : "rw"
    }
  },
  "partitions" : [
    {
      "name": "Example A" ,
      "id": 0,
      "size": "2044K",
      "families" : ["rp2350-arm-s" , "rp2350-riscv" ],
      "permissions" : {
        "secure" : "rw",
        "nonsecure" : "rw",
        "bootloader" : "rw"
      }
    },
    {
      "name": "Example B" ,
      "id": 1,
      "size": "2044K",
      "families" : ["rp2350-arm-s" , "rp2350-riscv" ],
      "permissions" : {
        "secure" : "rw",
        "nonsecure" : "rw",
        "bootloader" : "rw"
      },
      "link": ["a", 0]
RP2350 Datasheet
5.10. Example boot scenarios 434
    }
  ]
}
This can then be installed onto the device using picotool load , or UF2 drag and drop if you output the partition table as a
UF2 file.
5.10.5. A/B booting with owned partitions
The concept of owned partitions  applies when:
•you require separate data partitions (which generally won’t contain a block loop ), but
•you would like these to be associated with a specific boot partition in an A/B pair
An example partition table for this scenario would be:
Partition 0
  Accepts Families: rp2350-arm-s, rp2350-riscv
Partition 1
  Accepts Families: rp2350-arm-s, rp2350-riscv
  Link Type: "A"
  Link Value: 0
Partition 2
  Accepts Families: data
  Link Type: "Owner"
  Link Value: 0
  ignored_during_arm_boot: true
  ignored_during_riscv_boot: true
Partition 3
  Accepts Families: data
  Link Type: "A"
  Link Value: 2
  ignored_during_arm_boot: true
  ignored_during_riscv_boot: true
This is a partition table with 4 partitions. As before, partition 0 is the A partition of partition 1 (which is thus a B
partition). Additionally, partition 2 is the A partition of partition 3 (which is thus a B partition). Finally, partition 0 is the
"owner" partition of partition 2.
As a result partitions 2 and 3 "belong to" partitions 0 and 1.
When downloading a UF2 into an owned partition, the bootloader will select which partition out of 2/3 it goes to target
based on which partition out of 0/1 is currently booting. For example, if partition 1 is currently booting (due to having a
higher version than partition 0), then any UF2 downloads with the data family ID will target partition 3.
TIP
There is a flag in each partition that you can use to swap the "affinity", for example, to have the data family ID target
partition 2 instead of partition 3 in the scenario above.
RP2350 Datasheet
5.10. Example boot scenarios 435
NOTE
Only the get_uf2_target_partition()  bootrom function considers owner partitions. The pick_ab_partition()  function
always pick solely based on the A/B partition it is passed, in other words if passed partition 2, it would not look at
partitions 0 and 1.
To create this partition table using picotool partition create , the following JSON could be used:
{
  "version" : [1, 0],
  "unpartitioned" : {
    "families" : ["absolute" ],
    "permissions" : {
      "secure" : "rw",
      "nonsecure" : "rw",
      "bootloader" : "rw"
    }
  },
  "partitions" : [
    {
      "name": "Example A" ,
      "id": 0,
      "size": 128k,
      "families" : ["rp2350-arm-s" , "rp2350-riscv" ],
      "permissions" : {
        "secure" : "rw",
        "nonsecure" : "rw",
        "bootloader" : "rw"
      }
    },
    {
      "name": "Example B" ,
      "id": 1,
      "size": 128k,
      "families" : ["rp2350-arm-s" , "rp2350-riscv" ],
      "permissions" : {
        "secure" : "rw",
        "nonsecure" : "rw",
        "bootloader" : "rw"
      },
      "link": ["a", 0]
    },
    {
      "name": "Example a" ,
      "id": 2,
      "size": 20k,
      "families" : ["data"],
      "permissions" : {
        "secure" : "rw",
        "nonsecure" : "rw",
        "bootloader" : "rw"
      },
      "link": ["owner", 0],
      "ignored_during_arm_boot" : true,
      "ignored_during_riscv_boot" : true
    },
    {
      "name": "Example b" ,
      "id": 3,
      "size": 20k,
      "families" : ["data"],
RP2350 Datasheet
5.10. Example boot scenarios 436
      "permissions" : {
        "secure" : "rw",
        "nonsecure" : "rw",
        "bootloader" : "rw"
      },
      "link": ["a", 2],
      "ignored_during_arm_boot" : true,
      "ignored_during_riscv_boot" : true
    }
  ]
}
This can then be installed onto the device using picotool load , or UF2 drag and drop if you output the partition table as a
UF2 file.
5.10.6. Custom bootloader
In this scenario, a bootloader is run before booting into an image. This could perform additional validation, or set up
peripherals for use by the image. For this to work, the block loop must contain both an IMAGE_DEF  for the bootloader and
a PARTITION_TABLE  to define the flash layout.
In this example, we want to have A / B versions of the bootloader, so we use both slot 0 and slot 1. See Section 5.1.15 
for more details of this, as you may well need to increase the size of slot 0 in order to fit the bootloader.
WARNING
Making a slot size change is not reversible, so feel free to leave out slot 1 if you try this in practice.
An example flash layout might resemble the following:
 Slot 0 (0x00000000-0x00008000)
  Bootloader Image 0
  Partition Table 0
 Slot 1 (0x00008000-0x00010000)
  Bootloader Image 1
  Partition Table 1
 Partition 0 (0x00010000-0x00020000)
  Binary A
 Partition 1 (0x00020000-0x00030000)
  Link Type: "A"
  Link Value: 0
  Binary B
The block loop with both IMAGE_DEF  and PARTITION_TABLE  might look like this (after signing in this case):
RP2350 Datasheet
5.10. Example boot scenarios 437
IMAGE_DEF ItemIGNORED Item
LOAD_MAP Item
HASH_DEF Item
SIGNATURE Item
HASH_VALUE ItemBlock LoopLOAD_MAPentry covers this regionorIMAGE_DEF Item(this will be superceded by later IMAGE_DEF in the block loop)Vector table
Data
Partition Table
Signature BlockInitial Metadata Block (must be in first 4kB)
Code
Note the 3 blocks in the block loop:
1.Original block in first 4 kB (contents doesn’t matter, as it will be superseded by the later IMAGE_DEF )
2.PARTITION_TABLE  at end of binary
3.Signed IMAGE_DEF
NOTE
It is possible to sign both the PARTITION_TABLE  and the IMAGE_DEF  separately, however for the fastest boot speed, the
bootrom also allows you to use a "covering" LOAD_MAP  in the IMAGE_DEF . As long as the LOAD_MAP  defined area to be
hashed/signed includes the entirety of the PARTITION_TABLE  block, the "covering" signature is used to validate the
PARTITION_TABLE  too.
For the bootloader to find and launch a new image, it may wish to utilise various bootrom methods:
•get_partition_table_info()  to get the full partition information.
•or get_partition_table_info()  with SINGLE_PARTITION , the chosen partition number, and PARTITION_LOCATION_AND_FLAGS , to
get the address of a single partition
RP2350 Datasheet
5.10. Example boot scenarios 438
uint32_t  partition_info [3];
get_partition_table_info (partition_info , 3, PT_INFO_PARTITION_LOCATION_AND_FLAGS
    | PT_INFO_SINGLE_PARTITION  | (boot_partition  << 24));
uint16_t  first_sector_number  = (partition_info [1]
    & PICOBIN_PARTITION_LOCATION_FIRST_SECTOR_BITS )
    >> PICOBIN_PARTITION_LOCATION_FIRST_SECTOR_LSB ;
uint16_t  last_sector_number  = (partition_info [1]
    & PICOBIN_PARTITION_LOCATION_LAST_SECTOR_BITS )
    >> PICOBIN_PARTITION_LOCATION_LAST_SECTOR_LSB ;
uint32_t  data_start_addr  = first_sector_number  * 0x1000;
uint32_t  data_end_addr  = (last_sector_number  + 1) * 0x1000;
uint32_t  data_size  = data_end_addr  - data_start_addr ;
•get_sys_info()  with BOOT_INFO , to get the flash_update_boot_window_base  if any:
 uint32_t  sys_info [5];
 get_sys_info (sys_info , 5*4, SYS_INFO_BOOT_INFO );
 uint32_t  flash_update_boot_window_base  = sys_info [3];
•pick_ab_partition()  to pick the boot partition between A/B partitions if desired:
uint8_t boot_partition  = pick_ab_partition (workarea , 0xC00, 0,
flash_update_boot_window_base );
•or get_b_partition()  to find the other partition directly.
•chain_image()  with data_start_addr  and data_size , to boot a chosen image:
// note a negative 3rd parameter indicates to chain_image that the image is being chanined as
// part of a "flash update" boot, so TBYB and/or version downgrade may be in play
chain_image ( workarea ,
             0xc00,
            (XIP_BASE  + data_start_addr ) * (info.boot_type  == BOOT_TYPE_FLASH_UPDATE  ? -1 :
1),
            data_size
);
NOTE
The workarea  used must not overlap the image being chained into, so beware SRAM or packaged binaries. If the
binary overlaps the workarea , the results are undefined, but hardly likely to be good.
5.10.7. OTP bootloader
This is similar to the custom bootloader scenario, but it will be stored in the OTP and will run in SRAM.
One possible use case could place decryption code into OTP which decrypts an executable image from a flash partition
into RAM.
The entire bootloader will need to fit in the OTP rows from 0x0C0 to 0xF48 to avoid interfering with other reserved OTP
functionality, giving a maximum size of 7440 bytes (2 bytes per ECC row). If some boot keys and OTP keys are unused,
this region can extend slightly on either end.
RP2350 Datasheet
5.10. Example boot scenarios 439
The OTP bootloader itself should be stored in ECC format, starting from the row set in OTPBOOT_SRC  with size set in
OTPBOOT_LEN . When booting, it will be loaded into the address specified in OTPBOOT_DST0  and OTPBOOT_DST1 ,
which must be in the main SRAM. The bootloader must fulfil the same criteria as a standard image: it must include an
IMAGE_DEF , which must be signed if secure boot is enabled.
Once the OTP bootloader has been written to OTP, and the OTPBOOT_SRC , OTPBOOT_LEN , OTPBOOT_DST0  and
OTPBOOT_DST1  set, OTP booting can be enabled by setting BOOT_FLAGS0 .ENABLE_OTP_BOOT. If the OTP image fails
the bootrom’s launch checks, then, by default, boot continues along the normal flash boot path. You can prevent this by
setting BOOT_FLAGS0 .DISABLE_FLASH_BOOT.
WARNING
Take extreme care when writing an OTP bootloader. Once the ECC rows are written, they cannot  be modified.
5.10.8. Rollback versions and bootloaders
WARNING
Ignoring the advice in this section could render your device unable to boot.
For bootloaders that need to chain into executable images with rollback versions on a secured RP2350, you must  use
separate OTP rows for:
•The bootloader rollback version
•The chained executable image’s rollback version
Otherwise, bumping the version of the chained executable image renders the OTP bootloader and your device unable to
boot.
You must also make sure that both  the bootloader and the executable image have non-zero rollback versions, as the
OTP flags relating to requiring rollback versions are global. Failure to do so will render your device unable to boot.
We recommend using the DEFAULT_BOOT_VERSION0  and DEFAULT_BOOT_VERSION1  rows for the binary’s rollback
version, and selecting some other unused rows in the OTP for the bootloader’s rollback version.
RP2350 Datasheet
5.10. Example boot scenarios 440
Chapter 6. Power
6.1. Power supplies
RP2350 requires five separate power supplies. However, in most applications, several of these can be combined and
connected to a single power source. Typical applications only require a single 3.3 V supply. See Figure 19 .
The power supplies and a number of potential power supply schemes are described in the following sections. Detailed
power supply parameters are provided in Section 14.9.5 .
6.1.1. Digital IO supply ( IOVDD)
IOVDD provides the IO supply for the chip’s GPIO, and should be powered at a nominal voltage between 1.8 V and 3.3 V.
The supply voltage sets the external signal level for the digital IO, and should be chosen based on the level required, see
Section 14.9  for details. All GPIOs share the same power supply and operate at the same signal level.
If the digital IO is powered at a nominal 1.8 V, the IO input thresholds should be adjusted by setting the
VOLTAGE_SELECT  register to 1. VOLTAGE_SELECT  is set to 0 by default, which results in input thresholds that are valid
for a nominal IO voltage between 2.5 V and 3.3 V. See Chapter 9  for details.
CAUTION
Powering the IOVDD at 1.8 V with input thresholds set for a 2.5 V to 3.3 V supply is a safe operating mode, but will
result in input thresholds that do not meet specification. Powering the IO at voltages greater than 1.8 V with input
thresholds set for a 1.8 V supply may result in damage to the chip.
6.1.2. QSPI IO supply ( QSPI_IOVDD )
QSPI_IOVDD  provides the IO supply for the chip’s QSPI interface, and should be powered at a nominal voltage between
1.8 V and 3.3 V. The supply voltage sets the external signal level for the QSPI interface, and should be chosen based on
the level required, see Section 14.9  for details. In most applications the QSPI interface will be connected to an external
flash device, which will determine the required signal level.
If the QSPI interface is powered at a nominal 1.8 V, the IO input thresholds should be adjusted by setting the
VOLTAGE_SELECT  register to 1. VOLTAGE_SELECT  is set to 0 by default, which results in input thresholds that are valid
for a nominal IO voltage between 2.5 V and 3.3 V. See Chapter 9  for details.
CAUTION
Powering the IOVDD at 1.8 V with input thresholds set for a 2.5 V to 3.3 V supply is a safe operating mode, but will
result in input thresholds that do not meet specification. Powering the IO at voltages greater than 1.8 V with input
thresholds set for a 1.8 V supply may result in damage to the chip.
6.1.3. Digital core supply ( DVDD)
The chip’s core digital logic is powered by DVDD, which should be at a nominal 1.1 V. A dedicated on-chip core voltage
regulator allows DVDD to be generated from a 2.7 V to 5.5 V input supply. See Section 6.3  for details. Alternatively, DVDD
can be supplied directly from an off-chip power source.
If the on-chip core voltage regulator is used, the two DVDD pins closest to the regulator should be decoupled with a 100nF
capacitor close to the pins. The DVDD pin furthest from the regulator should be decoupled with a 4.7μF capacitor close to
RP2350 Datasheet
6.1. Power supplies 441
the pin.
6.1.4. USB PHY and OTP supply ( USB_OTP_VDD )
USB_OTP_VDD  supplies the chip’s USB PHY and OTP memory, and should be powered at a nominal 3.3 V. To reduce the
number of external power supplies, USB_OTP_VDD  can use the same power source as the core voltage regulator analogue
supply ( VREG_AVDD ), or digital IO supply ( IOVDD), assuming IOVDD is also powered at 3.3 V. This supply must always be
provided, even in applications where the USB PHY is never used.
USB_OTP_VDD  should be decoupled with a 100nF capacitor close to the chip’s USB_OTP_VDD  pin.
6.1.5. ADC supply ( ADC_AVDD )
ADC_AVDD  supplies the chip’s Analogue to Digital Converter (ADC). It can be powered at a nominal voltage between 1.8 V
and 3.3 V, but the performance of the ADC will be compromised at voltages below 2.97 V. To reduce the number of
external power supplies, ADC_AVDD  can use the same power source as the core voltage regulator analogue supply
(VREG_AVDD ) or digital IO supply ( IOVDD).
NOTE
It is safe to supply ADC_AVDD  at a higher or lower voltage than IOVDD, e.g. to power the ADC at 3.3 V, for optimum
performance, while supporting 1.8 V signal levels on the digital IO. But the voltage on the ADC analogue inputs must
not exceed IOVDD, e.g. if IOVDD is powered at 1.8 V, the voltage on the ADC inputs should be limited to 1.8 V. Voltages
greater than IOVDD will result in leakage currents through the ESD protection diodes. See Section 14.9  for details.
ADC_AVDD  should be decoupled with a 100nF capacitor close to the chip’s ADC_AVDD  pin.
6.1.6. Core voltage regulator input supply ( VREG_VIN )
VREG_VIN  is the input supply for the on-chip core voltage regulator, and should be in the range 2.7 V to 5.5 V. To reduce
the number of external power supplies, VREG_VIN  can use the same power source as the voltage regulator analogue
supply ( VREG_AVDD ), or digital IO supply ( IOVDD). Though care should be taken to minimise the noise on VREG_AVDD .
A 4.7μF capacitor should be connected between VREG_VIN  and ground close to the chip’s VREG_VIN  pin.
For more details on the on-chip voltage regulator see Section 6.3 .
6.1.7. On-chip voltage regulator analogue supply ( VREG_AVDD )
VREG_AVDD  supplies the on chip voltage regulator’s analogue control circuits, and should be powered at a nominal 3.3 V.
To reduce the number of external power supplies, VREG_AVDD  can use the same power source as the voltage regulator
input supply ( VREG_VIN ), or the digital IO supply ( IOVDD). Though care should be taken to minimise the noise on VREG_AVDD .
A passive low pass filter may be required, see Section 6.3.7  for details.
NOTE
VREG_AVDD  also powers the chip’s power-on reset and brownout detection blocks, so it must be powered even if the
on-chip voltage regulator is not used.
RP2350 Datasheet
6.1. Power supplies 442
6.1.8. Power supply sequencing
With the exception of the two voltage regulator supplies ( VREG_VIN  and VREG_AVDD ), which should be powered up together,
RP2350’s power supplies may be powered up or down in any order. However, small transient currents may flow in the
ADC supply ( ADC_AVDD ) if it is powered up before, or powered down after, the digital core supply (DVDD). This will not
damage the chip, but can be avoided by powering up DVDD before or at the same time as ADC_AVDD , and powering down
DVDD after or at the same time as ADC_AVDD . In the most common power supply scheme, where the chip is powered from
a single 3.3 V supply, DVDD will be powered up shortly after ADC_AVDD  due to the startup time of the on-chip voltage
regulator. This is acceptable behaviour.
6.2. Power management
RP2350 retains the power control features of RP2040, but extends them by splitting the chip’s digital core into a number
of power domains, which can be selectively powered off. This allows significant power saving in applications where the
chip is not continuously active. This section describes the core power domains and how they are controlled. The legacy
RP2040 power control features still offer useful power savings, and are described in Section 6.5 .
Power domains, and transitions between power states, are controlled by a Power manager. The Power manager runs
from either an internal low power oscillator lposc, or the reference clock clk_ref. The device may be configured to power
down under software control and can wakeup on a GPIO or timer event. Configuration of the power manager is via the
POWMAN registers in Section 6.4  .
6.2.1. Core power domains
RP2350’s core logic is divided into five power domains. With some restrictions, these domains can be selectively
powered off to reduce the chip’s power consumption. The five domains are:
•AON  - Always On - a small amount of logic that is always powered on when chip’s core supply ( DVDD) is available
•SWCORE  - Switched Core - the remaining core logic functions, including processors, bus fabric, peripherals, etc.
•XIP - XIP cache SRAM and Boot RAM
•SRAM0  - SRAM Power Domain 0 - the lower half of the large SRAM banks
•SRAM1  - SRAM Power Domain 1 - the upper half of the large SRAM banks, and the scratch SRAMs
Logic in the AON domain controls the power state of the other power domains, which can be powered on or off
independently. The only exception is the XIP domain, which must always be powered when the SWCORE domain is
powered. SRAMs that are powered on retain their contents when the switched core is powered off.
Figure 18  gives an overview of the core power domains.
RP2350 Datasheet
6.2. Power management 443
DVDD Always on Power Domain
Switched Core Power Domain
XIP Power DomainBoot SRAM (1 instances of 1kB)XIP Cache SRAM (2 instances of 16kB)
SRAM Power Domain 0SRAM Banks 0–3 (4 instances of 64kB)
SRAM Power Domain 1SRAM Banks 4–7 (4 instances of 64kB)SRAM Banks 8–9 (2 instances of 4kB)AON
SWCORE
1kB
16kB
4kB64kB
64kBFigure 18. core power
domains
6.2.2. Power states
RP2350 can operate in a number of power states, depending on which domains are powered on or off. Power states
have names in the form Pc.m  where:
•c indicates the state of the switched core (SWCORE) domain: 0 = on / 1 = off
•m is a 3 bit binary representation of the memory power domains, in the order XIP, SRAM0, SRAM1
P0.m states, where the switched core is powered on, are Normal Operating  states. P1.m states, where the switched core is
powered off, are Low Power  states
Table 475  shows the available power states.
Table 475. supported
power statesPower State Description AON SWCORE XIP SRAM0 SRAM1
P0.0 Normal Operation on on on on on
P0.1 Normal Operation (SRAM1 off) on on on on off
P0.2 Normal Operation (SRAM0 off) on on on off on
P0.3 Normal Operation (SRAM0 & SRAM1 off) on on on off off
P1.0 Low Power on off on on on
P1.1 Low Power (SRAM1 off) on off on on off
P1.2 Low Power (SRAM0 off) on off on off on
RP2350 Datasheet
6.2. Power management 444
Power State Description AON SWCORE XIP SRAM0 SRAM1
P1.3 Low Power (SRAM0 & SRAM1 off) on off on off off
P1.4 Low Power (XIP off) on off off on on
P1.5 Low Power (XIP & SRAM1 off) on off off on off
P1.6 Low Power (XIP & SRAM0 off) on off off off on
P1.7 Low Power (XIP & SRAM0 & SRAM1 off) on off off off off
OFF Not Powered off off off off off
In the OFF state, the chip has no external power and all domains are unpowered. The chip moves from OFF to P0.0
automatically as soon as external power is applied.
To determine the current power state, read the STATE .CURRENT field. CURRENT is a 4 bit field representing the power
state of the switched core and memory power domains.
6.2.3. Power state transitions
Transitions between power states can be initiated by software, hardware, or via the chip’s debug subsystem. After
initiation, transitions are managed by autonomous power sequencers in the chip’s AON power domain. The power
sequencers can be configured, in a limited way, via the SEQ_CFG  register. The sequencers can also be observed and
controlled, again in a limited way, via the RP-AP registers in the chip’s debug subsystem. These registers are described
in Section 3.5.10 .
Valid power state transitions are as follows:
•all transitions from one P0.m state (switched core powered on) to another P0.m state (switched core powered on), if
they increase or decrease the number of SRAM domains that are powered on
•all transitions from a P0.m state (switched core powered on) to a P1.m state (switched core powered off), except
transitions that would result in a powered off SRAM domain becoming powered on
•all transitions from a P1.m state (switched core powered off) to a P0.m state (switched core powered on), except
transitions that would result in a powered on SRAM domain becoming powered off
Transitions from one P1.m state (switched core powered off) to another P1.m state (switched core powered off) are not
supported, and will be prevented by the hardware.
Valid transitions are shown in the table below.
Table 476. valid power
state transitionsFrom To
P0.0 P0.1 P0.2 P0.3 P1.0 P1.1 P1.2 P1.3 P1.4 P1.5 P1.6 P1.7
P0.1 P0.0 P0.3 P1.1 P1.3 P1.5 P1.7
P0.2 P0.0 P0.3 P1.2 P1.3 P1.6 P1.7
P0.3 P0.0 P0.1 P0.2 P1.3 P1.7
P1.0 P0.0
P1.1 P0.0 P0.1
P1.2 P0.0 P0.2
P1.3 P0.0 P0.1 P0.2 P0.3
P1.4 P0.0
P1.5 P0.0 P0.1
RP2350 Datasheet
6.2. Power management 445
From To
P1.6 P0.0 P0.2
P1.7 P0.0 P0.1 P0.2 P0.3
6.2.3.1. Transitions from Normal Operating (P0.m) states
Transitions from a Normal Operating ( P0.m) state to either a Low Power ( P1.m) state, or another Normal Operating ( P0.m)
state, are initiated by writing to the STATE .REQ field. REQ is a 4-bit field representing the requested power state of the
switched core and memory power domains. The STATE .WAITING field will be set immediately, followed by the the
STATE .CHANGING field, after the actual state change starts. If a transition to a Low Power ( P1.m) state is requested,
WAITING will remain set until the processors have gone into a low power state (via __wfi()). In the WAITING state, writing to
the STATE .REQ field can change or cancel the initial request. The requested state can’t be changed when in the CHANGING 
state.
A request to move to an unsupported state, or a state that would result in an invalid transition, causes the
STATE .BAD_SW_REQ field to be set.
If a hardware power up request is received while in the WAITING state, the transition requested via STATE .REQ will be
halted and the power up request completed. The STATE .PWRUP_WHILE_WAITING and STATE .REQ_IGNORED fields will
be set.
On writing to STATE .REQ:
•If there is a pending power up request, STATE .REQ_IGNORED is set and no further action is taken
•If the requested state is invalid, STATE .BAD_SW_REQ is set and no further action is taken
•If the switched core is being powered off, STATE .WAITING is set until both processors enter __wfi(). After which
STATE .CHANGING will be set, but no processors will be powered up to read the flag at this time
◦If there is a power up request while in STATE .WAITING, STATE .PWRUP_WHILE_WAITING is set, which can
also raise an interrupt to bring the processors out of __wfi(). No further action is taken
◦You can get out of the WAITING state by writing a new request to STATE .REQ before both processors have gone
into __wfi()
•Any state request that isn’t powering down the switched core, such as powering up or down SRAM domain 0 or 1
starts immediately. Software should wait until STATE .CHANGING has cleared to know the power down sequence.
After the STATE .CHANGING flag is cleared STATE .CURRENT is updated.
•If powering up, software should also wait for STATE .CHANGING to make sure everything is powered up before
continuing. In practice this is handled by the RP2350 bootrom.
Invalid state transitions are:
•any combination of power up and power down requests
•any request which would result in power down of XIP/bootRAM and power up of SWCORE
If XIP, boot RAM, sram0, or sram1 remain powered while SWCORE is powered off, the sram will automatically switch to
a low power state. Stored data will be retained.
Before transitioning to a switched-core power down state ( P1.m), software needs to configure:
•the GPIO wakeup conditions if required
•the wakeup alarm if required
•the return state of the SRAM0 & SRAM1 domains
RP2350 Datasheet
6.2. Power management 446
6.2.3.2. Transitions from Low Power (P1.m) states
Transitions from P1.m  to P0.m  states are initiated by GPIO events or the timer alarm.
There are up to 5 wakeup sources:
•up to 4 GPIO wakeups (level high/low or falling edge/rising edge)
•1 alarm wakeup
GPIO wakeups are configured by the PWRUP0 -PWRUP3  registers. The wakeups are not enabled until the power
sequencer completes the power down operation.
The alarm wakeup is configured by writing to the ALARM_TIME_15TO0 -ALARM_TIME_63TO48  registers. The alarm
wakeup has a resolution of 1ms. Once set, the alarm wakeup is armed by writing a 1 to both  TIMER .PWRUP_ON_ALARM
and TIMER .ALARM_ENAB. If the alarm fires during the power down sequence, a power up sequence will start when the
power down sequence completes.
The LAST_SWCORE_PWRUP  register indicates which event caused the most recent power up.
6.2.3.3. Debugger-initiated power state transitions
The debugger can be used to trigger a power up sequence via the CSYSPWRUPREQ  output from the SW-DP CTRL/STAT  register.
This powers all domains (i.e. returns to state P0.0) and also inhibits any further software initiated power state
transitions.
When CSYSPWRUPREQ  is asserted, the power sequencer will:
•complete any power state transitions that are in progress
•return to power state P0.0
•assert CSYSPWRUPACK  to signal completion to the debug host
If CSYSPWRUPREQ  is de-asserted then software initiated power transitions will be able to resume. The user can detect when
a software requested transition is ignored because of CSYSPWRUPREQ  using the following hints:
•Getting a STATE .REQ_IGNORED after a write to STATE .REQ
•CURRENT_PWRUP_REQ  will have bit 5 (coresight) set
•Either:
◦Get the debugger to de-assert CSYSPWRUPREQ  or
◦Mask out CSYSPWRUPREQ  by setting DBG_PWRCFG .IGNORE
NOTE
DBG_PWRCFG .IGNOREis useful to test going to sleep with a debugger attached or ignoring CSYSPWRUPREQ . A debugger
will likely leave CSYSPWRUPREQ  set when disconnecting. It would be impossible to go to sleep after this without
DBG_PWRCFG .IGNORE.
6.2.3.4. Power-mode-aware GPIO control
The power manager sequencer is able to switch the state of two GPIO outputs on entry to and exit from a P1.m state, i.e.
one where the switched core is powered down. This allows external devices to be power-aware. The GPIOs switch to
indicate the low power state after  the core is powered down and switch to indicate the high power state before  the core
is powered up. This ensures the high power state of the external components always overlaps the high power state of
the core. The GPIOs are configured by the EXT_CTRL0  and EXT_CTRL1  registers.
RP2350 Datasheet
6.2. Power management 447
6.2.3.5. Isolation
When powering down SWCORE, the pad control and data signals are latched and isolated from the IO logic. This avoids
transitions on pads which could potentially corrupt external components. On SWCORE power up, the isolation is not
released automatically. The user releases the isolation by clearing the ISO field of the pad control register (for example
GPIO0 .ISO) after the IO logic has been configured.
6.3. Core voltage regulator
RP2350 provides an on-chip voltage regulator for its digital core supply ( DVDD). The regulator requires a 2.7 V to 5.5 V
input supply ( VREG_VIN ), allowing DVDD to be generated directly from a single lithium ion cell, or a USB power supply. A
separate, nominally 3.3 V, low noise supply ( VREG_AVDD ) is required for the regulator’s analogue control circuits. The
regulator supports both switching and linear modes of regulation, allowing efficient operation at both high and low
loads.
To allow the chip to start up, the regulator is enabled by default, and will power up as soon as its supplies are available.
The regulator starts in switching mode, with a nominal 1.1 V output, but its operating mode and output voltage can be
changed once the chip is out of reset. The output voltage can be set in the range 0.55 V to 3.30 V, and the regulator can
supply up to 200mA.
Although intended for the chip’s digital core supply ( DVDD), the regulator can be used for other purposes if DVDD is
powered directly from an external power supply.
6.3.1. Operating modes
The regulator has the following three modes of operation.
6.3.1.1. Normal mode
In normal mode, the regulator operates in a switching mode, and can supply up to 200mA. Normal mode is used for P0.x
power states, when the chip’s switched core is powered on. The regulator must be in normal mode before  the core
supply current is allowed to exceed 1mA. The regulator starts up in normal mode when its input supplies are first
applied.
6.3.1.2. Low-power mode
In low-power mode, the regulator operates in a linear mode, and can only supply up to 1mA. Low-power mode can be
used for P1.x power states, where the chip’s switched core is powered off. The core supply current must be less than
1mA before  the regulator is moved to low-power mode. The regulator’s output voltage is limited to 1.3 V in low-power
mode.
CAUTION
In low-power mode, the output of the regulator is directly connected to DVDD. It isn’t possible to disconnect the
regulator from DVDD in this mode. Don’t put the regulator into low-power mode if DVDD is being powered from an
external supply.
6.3.1.3. High-impedance mode
In high-impedance mode, the regulator is disabled, its power consumption is minimised, and its outputs are set to a
high-impedance state. This mode should only be used if the digital core supply (DVDD) is provided by an external
RP2350 Datasheet
6.3. Core voltage regulator 448
regulator. If the on-chip regulator is supplying DVDD, entering high-impedance mode causes a reset event, returning the
on-chip regulator to Normal mode.
6.3.2. Software control
WARNING
The regulator can’t be relocked after it’s been unlocked. Avoid accidental writes to the VREG register.
The regulator can be directly controlled by software, but must first be unlocked by writing a 1 to the UNLOCK field in the
VREG_CTRL  register. Once unlocked, the regulator can be controlled via the VREG  register.
The regulator’s operating mode defaults to Normal, at initial power up or after a reset event, but can be switched to high
impedance by writing a 1 to the VREG  register’s HIZ field. The regulator’s output voltage can be set by writing to the
register’s VSEL field, see the VREG  register description for details on available settings. To prevent accidental over-
voltage, the output voltage is limited to 1.3 V unless the DISABLE_VOLTAGE_LIMIT  field in the VREG_CTRL  is set. The output
voltage defaults to 1.1 V at initial power-on or after a reset event.
The UPDATE_IN_PROGRESS  field in the VREG  register is set while the regulator’s operating mode or output voltage are being
updated. When UPDATE_IN_PROGRESS  is set, writes to the register are ignored.
It isn’t possible to place the regulator in low-power mode under software control because the load current will exceed
1mA when software is running.
CAUTION
The regulator’s output voltage can be varied between 0.55 V and 3.3 V, but RP2350 might not operate reliably with
its digital core supply ( DVDD) at a voltage other than 1.1 V.
6.3.3. Power Manager control
The regulator’s operating mode and output voltage can also be controlled by the Power Manager. Power Manager
control is typically used when the chip enters or exits a low-power ( P1.x) state, when software might not be running.
In addition to normal and high-impedance modes, Power Manager control allows the regulator to be placed in low-
power mode. By default, the regulator switches to low-power mode when entering a low-power ( P1.x) state, and returns
to Normal mode when returning to a normal ( P0.x) state.
The operating mode and output voltage in the low-power state are set by the values in the VREG_LP_ENTRY  register.
And the operating mode and output voltage to be used when the chip has returned to a normal state are set by values in
the VREG_LP_EXIT  register. The registers contain an additional MODE field that allows low-power mode to be selected.
The values in the registers must be written by software before  requesting a transition to a low-power state because
software won’t be running during or after the transition. The actual transitions to and from the low-power state are
handled by the Power Manager. Once the chip has returned to a normal state, software can be run and the regulator
controlled directly. The values in the VREG  register reflect the regulator’s current operating mode and output voltage
once the chip has returned to a normal state.
RP2350 Datasheet
6.3. Core voltage regulator 449
CAUTION
Low-power mode should only be used when the regulator is providing the chip’s digital core supply ( DVDD) because
the regulator’s low-power output is connected to DVDD on chip.
6.3.4. Status
To determine the status of the regulator, read the VREG_STS  register, which contains two fields:
•VOUT_OK indicates whether the voltage regulator’s output is being correctly regulated. At power-on, VOUT_OK remains
low until the regulator has started up and the output voltage reaches the VOUT_OK assertion threshold ( VOUT_OKTH.ASSERT ).
It then remains high until the voltage drops below the VOUT_OK de-assertion threshold ( VOUT_OKTH.DEASSERT ), remaining low
until the output voltage is above the assertion threshold again. VOUT_OKTH.ASSERT  is nominally 90% of the selected output
voltage, 0.99 V if the selected output voltage is 1.1 V, and VOUT_OKTH.DEASSERT  is nominally 87% of the selected output
voltage, 0.957 V if the selected output voltage is 1.1 V. See Section 14.9.6  for details.
•STARTUP is high when the regulator is starting up, and remains high until the regulator’s operating mode or output
voltage are changed, either by software or the Power Manager
Adjusting the output voltage to a higher voltage will cause VOUT_OK to go low until the assertion threshold for the higher
voltage is reached. VOUT_OK will also go low if the regulator is placed in high-impedance mode.
6.3.5. Current limit
The voltage regulator includes a current limit to prevent the load current exceeding the maximum rated value. The
output voltage won’t be regulated and will drop below the selected value when the current limit is active. See Section
14.9.6  for details.
6.3.6. Over temperature protection
The voltage regulator will terminate regulation and disable its power transistors, if the transistor junction temperature
rises above a threshold set by the HT_TH field in the VREG_CTRL  register. The regulator will restart regulation when the
transistor junction temperature drops to approximately 20°C below the temperature threshold.
6.3.7. Application circuit
The regulator requires two external power supplies, the input supply ( VREG_VIN ), and a separate low noise supply for its
analogue control circuits ( VREG_AVDD ). VREG_VIN  must be in the range 2.7 V to 5.5 V, and VREG_AVDD  must be in the range
3.135 V to 3.63 V.
If VREG_VIN  is limited to the range 3.135 V to 3.63 V, a single combined supply can be used for both VREG_VIN  and
VREG_AVDD . This approach is shown in Figure 19 . Take care to minimise noise on VREG_AVDD .
RP2350 Datasheet
6.3. Core voltage regulator 450
3.135V to 3.63V supply
4.7µFGND100nFGND100nFGND4.7µF
GND
4.7µF33Ω
GND4.7µF3.3µHDVDDDVDDDVDDVREG_PGNDVREG_LX
VREG_AVDDVREG_VINVREG_FBFigure 19. Core
voltage regulator with
combined supplies
Alternatively, to support input voltages above 3.63 V, VREG_VIN  and VREG_AVDD  can be powered separately. This is shown in
Figure 20 .
DVDDDVDD DVDD2.7V to 5.5V supply
3.135V to 3.63V supply
4.7µF
GND100nF
GND100nF
GND4.7µF
GND4.7µF 3.3µH VREG_PGNDVREG_LX
VREG_AVDDVREG_VINVREG_FBFigure 20. Core
voltage regulator with
separate supplies
If the digital core supply (DVDD) is powered from an external 1.1V supply, the on-chip regulator can be disabled and the
application circuit simplified. Power must still be provided on the regulator’s analogue supply ( VREG_AVDD ) and input
supply ( VREG_VIN ) to power the chip’s power-on reset and brown-out detection blocks. But the inductor can be omitted
and only a single input capacitor is required. Connect VREG_FB directly to ground. This is shown in Figure 21 .
RP2350 Datasheet
6.3. Core voltage regulator 451
3.135Vto 3.63V supply
1.1V supply
100nFGND100nFGND100nFGND4.7µF
GND
GNDDVDDDVDDDVDDVREG_PGNDVREG_LX
VREG_AVDDVREG_VINVREG_FBFigure 21. External
core supply with on-
chip regulator
disabled.
The on-chip regulator will still power on as soon as VREG_VIN  and VREG_AVDD  are available, but can be shut down under
software control after the chip is out of reset. This is a safe mode of operation, though the regulator will consume
approximately 400 µA until it’s shut down. The regulator should be shut down by writing a 1 to the VREG register’s HIZ
field.
6.3.8. External components and PCB layout requirements
The most critical part of an RP2350 PCB layout is the core voltage regulator. This should be placed first on any board
design and these guidelines must be strictly followed.
RP2350 Datasheet
6.3. Core voltage regulator 452
Figure 22. Regulator
section of the
Raspberry Pi Pico 2
schematic. The nets
highlighted in bold
show the high
switching current
paths
RP2350 Datasheet
6.3. Core voltage regulator 453
3.3V3.3V
VOUT
GND
GND
VIAVIAVIA
VIAVIARFILTLX
COUT
CINCFILTorientationindicator
RP2350
VREG_PGNDVREG_LX
VREG_AVDDVREG_VINVREG_FBFigure 23. Regulator
section of the
Raspberry Pi Pico 2
PCB layout showing
the high current paths
for each of the
regulator’s switching
phases. The AOTA-
B201610S3R3-101-T 
inductor’s case size is
0806 (2016 metric),
the resistor and
capacitors are 0402
(1005 metric)
Designers should follow the above schematic Figure 22  and layout Figure 23  as closely as possible as this has had the
most verification and is considered our best practice layout. This circuit design is present on the Raspberry Pi Pico 2
and RP2350 reference design (see Hardware design with RP2350 , Minimal Design Example ) and both of these designs
are made available in either Cadence Allegro or Kicad formats respectively. Figure 23  shows the regulator layout on the
top layer of the Raspberry Pi Pico 2 PCB. The bottom layer under the regulator is a ground plane that connects to the
QFN GND central pad.
6.3.8.1. Layout recommendations
•VREG_AVDD  is a noise sensitive signal and must be RC filtered as per Figure 22 .
◦Avoid doing anything that might couple noise into VREG_AVDD .
◦CIN needs its own separate GND via / low impedance path back to the RP2350 GND pad.
•The red and green arrows in Figure 23  show the high current paths for each of the regulator’s switching phases. It
is critical keep the loop area of these current paths as small and low-impedance as possible, while also keeping
them isolated (i.e. only connect to main GND at one point).
◦Follow this layout as closely as possibly.
◦Don’t place any of C IN/LX/COUT  on the opposite side of the PCB.
•Reduce parasitics on the VREG_LX node.
•On the top layer make sure to cut away any extra copper underneath the inductor, cut back copper near the VREG_LX
trace where possible.
RP2350 Datasheet
6.3. Core voltage regulator 454
◦For a multi-layer board (4 or more layers) please cut away any copper immediately underneath L X/VREG_LX
node. For example, Figure 24  illustrates this.
•The GND via placement is critical.
◦There must be a short-as-possible, low impedance GND path back to the Raspberry Pi Pico 2 QFN GND pad
from the high-current GND at one single point (using 2 adjacent vias to reduce the impedance).
◦CFILT  must also have a low impedance and short-as-possible path back to the QFN GND pad (don’t share any
GND vias with the C IN/COUT  high current GND).
•The VREG_FB pin should be fed from the output of C OUT , avoiding routing directly underneath L X.
•COUT  is critical for regulator performance and EMI. It must be placed between VREG_VIN  and VREG_PGND  as close to the
pins as practically possible.
◦In addition to C OUT , for best performance we recommend a second 4.7μF capacitor is used on the V OUT  net,
located on the bottom edge of the package (DVDD pin 23 on the QFN-60). Don’t place this near L X/COUT .
Layer 2Figure 24. Cut-out
beneath LX/VREG_LX
net on layer 2 of 4 (or
more) layer PCBs
6.3.8.2. Component values
•CIN should be at least 4.7μF and have a maximum parasitic resistance of 50mΩ.
•COUT  must be 4.7μF ±20% with a maximum parasitic resistance of 250mΩ and a maximum inductance of 6nH.
•LX must be fully shielded, 3.3μH ±20% and with a maximum DC resistance of 250mΩ. Saturation current should be
at least 1.5A. The inductor must be marked for polarity (see Figure 25 ) and placed on the layout as indicated in
Figure 23 . As discussed below, we recommend the AOTA-B201610S3R3-101-T .
RP2350 Datasheet
6.3. Core voltage regulator 455
6.3.8.3. Regulator sensitivities
The RP2350 regulator has a few sensitivities:
•The VREG_AVDD  supply is noise sensitive.
•Efficiency is quite sensitive to inductance roll-off with inductor current, so an inductor with low roll-off is required
for best operation (generally the higher saturation current the better).
•Even with nominally fully shielded inductors, leakage magnetic field coupling into the loop formed by the output
VREG_LX node through the inductor and output capacitor (C OUT ) seems to affect the regulator control loop and output
voltage. Field orientation (and hence inductor orientation) matters - the inductor has to be the right way around to
make sure the regulator operates properly especially at higher output currents and for higher load transients. This
necessitates an inductor with marked polarity.
To meet the above requirements, Raspberry Pi have worked with Abracon to create a custom 2.0×1.6mm 3.3μH polarity-
marked inductor, part number AOTA-B201610S3R3-101-T  (see Figure 25  and Figure 25 ). These will be available in
general distribution in time, but for now please contact Raspberry Pi to request samples / production volumes.
Raspberry Pi is still working with the regulator IP vendor to fully verify and qualify the regulator and custom inductor.
Magnetic Field DirectionorientationindicatorI(amps) + -Figure 25. AOTA-
B201610S3R3-101-T 
inductor with
orientation marking,
showing current and
magnetic field
directions
RP2350 Datasheet
6.3. Core voltage regulator 456
Drawings not to scaleAll dimensions are in millimetres2.00 ±0.20 0.60 ±0.201.60 ±0.20
1.00 MAX.Top view Bottom view
Side viewFigure 26. Dimensions
of the AOTA-
B201610S3R3-101-T 
inductor
6.3.9. List of registers 
The voltage regulator shares a register address space with other power management subsystems in the always-on
domain. This address space is referred to as POWMAN elsewhere in this document, and a complete list of POWMAN registers is
provided in Section 6.4 . For reference information on POWMAN registers associated with the voltage regulator is repeated
here.
The POWMAN registers start at a base address of 0x40100000  (defined as POWMAN_BASE  in the SDK).
•VREG_CTRL
•VREG_STS
•VREG
•VREG_LP_ENTRY
•VREG_LP_EXIT
6.4. Power management (POWMAN) registers
Password-protected POWMAN registers require a password ( 0x5AFE) to be written to the top 16 bits to enable the write
operation. This protects against accidental writes that could crash the chip untraceably. Writes to protected registers
that don’t include the password are ignored, setting a flag in the BADPASSWD  register. Reads from protected registers
don’t return the password, to protect against erroneous read-modify-write operations.
Protected registers obviously don’t have writeable fields in the top 16 bits, however they may have read-only fields in
that range.
All registers with address offsets up to and including 0x000000ac  are password protected. Therefore, the following
writeable registers are unprotected and have 32-bit write access:
RP2350 Datasheet
6.4. Power management (POWMAN) registers 457
•POWMAN_SCRATCH0  → POWMAN_SCRATCH7
•POWMAN_BOOT0  → POWMAN_BOOT3
•POWMAN_INTR
•POWMAN_INTE
•POWMAN_INTF
Table 477. List of
POWMAN registersOffset Name Info
0x00 BADPASSWD Indicates a bad password has been used
0x04 VREG_CTRL Voltage Regulator Control
0x08 VREG_STS Voltage Regulator Status
0x0c VREG Voltage Regulator Settings
0x10 VREG_LP_ENTRY Voltage Regulator Low Power Entry Settings
0x14 VREG_LP_EXIT Voltage Regulator Low Power Exit Settings
0x18 BOD_CTRL Brown-out Detection Control
0x1c BOD Brown-out Detection Settings
0x20 BOD_LP_ENTRY Brown-out Detection Low Power Entry Settings
0x24 BOD_LP_EXIT Brown-out Detection Low Power Exit Settings
0x28 LPOSC Low power oscillator control register.
0x2c CHIP_RESET Chip reset control and status
0x30 WDSEL Allows a watchdog reset to reset the internal state of powman in
addition to the power-on state machine (PSM).
Note that powman ignores watchdog resets that do not select at
least the CLOCKS stage or earlier stages in the PSM. If using
these bits, it’s recommended to set PSM_WDSEL to all-ones in
addition to the desired bits in this register. Failing to select
CLOCKS or earlier will result in the POWMAN_WDSEL register
having no effect.
0x34 SEQ_CFG For configuration of the power sequencer
Writes are ignored while POWMAN_STATE_CHANGING=1
RP2350 Datasheet
6.4. Power management (POWMAN) registers 458
Offset Name Info
0x38 STATE This register controls the power state of the 4 power domains.
The current power state is indicated in
POWMAN_STATE_CURRENT which is read-only.
To change the state, write to POWMAN_STATE_REQ.
The coding of POWMAN_STATE_CURRENT &
POWMAN_STATE_REQ corresponds to the power states
defined in the datasheet:
bit 3 = SWCORE
bit 2 = XIP cache
bit 1 = SRAM0
bit 0 = SRAM1
0 = powered up
1 = powered down
When POWMAN_STATE_REQ is written, the
POWMAN_STATE_WAITING flag is set while the Power Manager
determines what is required. If an invalid transition is requested
the Power Manager will still register the request in
POWMAN_STATE_REQ but will also set the POWMAN_BAD_REQ
flag. It will then implement the power-up requests and ignore the
power down requests. To do nothing would risk entering an
unrecoverable lock-up state. Invalid requests are: any
combination of power up and power down requests any request
that results in swcore being powered and xip unpowered If the
request is to power down the switched-core domain then
POWMAN_STATE_WAITING stays active until the processors
halt. During this time the POWMAN_STATE_REQ field can be re-
written to change or cancel the request. When the power state
transition begins the POWMAN_STATE_WAITING_flag is cleared,
the POWMAN_STATE_CHANGING flag is set and POWMAN
register writes are ignored until the transition completes.
0x3c POW_FASTDIV
0x40 POW_DELAY power state machine delays
0x44 EXT_CTRL0 Configures a gpio as a power mode aware control output
0x48 EXT_CTRL1 Configures a gpio as a power mode aware control output
0x4c EXT_TIME_REF Select a GPIO to use as a time reference, the source can be used
to drive the low power clock at 32kHz, or to provide a 1ms tick to
the timer, or provide a 1Hz tick to the timer. The tick selection is
controlled by the POWMAN_TIMER register.
0x50 LPOSC_FREQ_KHZ_INT Informs the AON Timer of the integer component of the clock
frequency when running off the LPOSC.
0x54 LPOSC_FREQ_KHZ_FRAC Informs the AON Timer of the fractional component of the clock
frequency when running off the LPOSC.
0x58 XOSC_FREQ_KHZ_INT Informs the AON Timer of the integer component of the clock
frequency when running off the XOSC.
0x5c XOSC_FREQ_KHZ_FRAC Informs the AON Timer of the fractional component of the clock
frequency when running off the XOSC.
0x60 SET_TIME_63TO48
0x64 SET_TIME_47TO32
RP2350 Datasheet
6.4. Power management (POWMAN) registers 459
Offset Name Info
0x68 SET_TIME_31TO16
0x6c SET_TIME_15TO0
0x70 READ_TIME_UPPER
0x74 READ_TIME_LOWER
0x78 ALARM_TIME_63TO48
0x7c ALARM_TIME_47TO32
0x80 ALARM_TIME_31TO16
0x84 ALARM_TIME_15TO0
0x88 TIMER
0x8c PWRUP0 4 GPIO powerup events can be configured to wake the chip up
from a low power state.
The pwrups are level/edge sensitive and can be set to trigger on
a high/rising or low/falling event
The number of gpios available depends on the package option.
An invalid selection will be ignored
source = 0 selects gpio0
.
.
source = 47 selects gpio47
source = 48 selects qspi_ss
source = 49 selects qspi_sd0
source = 50 selects qspi_sd1
source = 51 selects qspi_sd2
source = 52 selects qspi_sd3
source = 53 selects qspi_sclk
level = 0 triggers the pwrup when the source is low
level = 1 triggers the pwrup when the source is high
0x90 PWRUP1 4 GPIO powerup events can be configured to wake the chip up
from a low power state.
The pwrups are level/edge sensitive and can be set to trigger on
a high/rising or low/falling event
The number of gpios available depends on the package option.
An invalid selection will be ignored
source = 0 selects gpio0
.
.
source = 47 selects gpio47
source = 48 selects qspi_ss
source = 49 selects qspi_sd0
source = 50 selects qspi_sd1
source = 51 selects qspi_sd2
source = 52 selects qspi_sd3
source = 53 selects qspi_sclk
level = 0 triggers the pwrup when the source is low
level = 1 triggers the pwrup when the source is high
RP2350 Datasheet
6.4. Power management (POWMAN) registers 460
Offset Name Info
0x94 PWRUP2 4 GPIO powerup events can be configured to wake the chip up
from a low power state.
The pwrups are level/edge sensitive and can be set to trigger on
a high/rising or low/falling event
The number of gpios available depends on the package option.
An invalid selection will be ignored
source = 0 selects gpio0
.
.
source = 47 selects gpio47
source = 48 selects qspi_ss
source = 49 selects qspi_sd0
source = 50 selects qspi_sd1
source = 51 selects qspi_sd2
source = 52 selects qspi_sd3
source = 53 selects qspi_sclk
level = 0 triggers the pwrup when the source is low
level = 1 triggers the pwrup when the source is high
0x98 PWRUP3 4 GPIO powerup events can be configured to wake the chip up
from a low power state.
The pwrups are level/edge sensitive and can be set to trigger on
a high/rising or low/falling event
The number of gpios available depends on the package option.
An invalid selection will be ignored
source = 0 selects gpio0
.
.
source = 47 selects gpio47
source = 48 selects qspi_ss
source = 49 selects qspi_sd0
source = 50 selects qspi_sd1
source = 51 selects qspi_sd2
source = 52 selects qspi_sd3
source = 53 selects qspi_sclk
level = 0 triggers the pwrup when the source is low
level = 1 triggers the pwrup when the source is high
0x9c CURRENT_PWRUP_REQ Indicates current powerup request state
pwrup events can be cleared by removing the enable from the
pwrup register. The alarm pwrup req can be cleared by clearing
timer.alarm_enab
0 = chip reset, for the source of the last reset see
POWMAN_CHIP_RESET
1 = pwrup0
2 = pwrup1
3 = pwrup2
4 = pwrup3
5 = coresight_pwrup
6 = alarm_pwrup
RP2350 Datasheet
6.4. Power management (POWMAN) registers 461
Offset Name Info
0xa0 LAST_SWCORE_PWRUP Indicates which pwrup source triggered the last switched-core
power up
0 = chip reset, for the source of the last reset see
POWMAN_CHIP_RESET
1 = pwrup0
2 = pwrup1
3 = pwrup2
4 = pwrup3
5 = coresight_pwrup
6 = alarm_pwrup
0xa4 DBG_PWRCFG
0xa8 BOOTDIS Tell the bootrom to ignore the BOOT0..3 registers following the
next RSM reset (e.g. the next core power down/up).
If an early boot stage has soft-locked some OTP pages in order
to protect their contents from later stages, there is a risk that
Secure code running at a later stage can unlock the pages by
powering the core up and down.
This register can be used to ensure that the bootloader runs as
normal on the next power up, preventing Secure code at a later
stage from accessing OTP in its unlocked state.
Should be used in conjunction with the OTP BOOTDIS register.
0xac DBGCONFIG
0xb0 SCRATCH0 Scratch register. Information persists in low power mode
0xb4 SCRATCH1 Scratch register. Information persists in low power mode
0xb8 SCRATCH2 Scratch register. Information persists in low power mode
0xbc SCRATCH3 Scratch register. Information persists in low power mode
0xc0 SCRATCH4 Scratch register. Information persists in low power mode
0xc4 SCRATCH5 Scratch register. Information persists in low power mode
0xc8 SCRATCH6 Scratch register. Information persists in low power mode
0xcc SCRATCH7 Scratch register. Information persists in low power mode
0xd0 BOOT0 Scratch register. Information persists in low power mode
0xd4 BOOT1 Scratch register. Information persists in low power mode
0xd8 BOOT2 Scratch register. Information persists in low power mode
0xdc BOOT3 Scratch register. Information persists in low power mode
0xe0 INTR Raw Interrupts
0xe4 INTE Interrupt Enable
0xe8 INTF Interrupt Force
0xec INTS Interrupt status after masking & forcing
POWMAN : BADPASSWD Register
Offset : 0x00
RP2350 Datasheet
6.4. Power management (POWMAN) registers 462
Table 478.
BADPASSWD RegisterBits Description Type Reset
31:1 Reserved. - -
0 Indicates a bad password has been used WC 0x0
POWMAN : VREG_CTRL Register
Offset : 0x04
Description
Voltage Regulator Control
Table 479.
VREG_CTRL RegisterBits Description Type Reset
31:16 Reserved. - -
15 RST_N : returns the regulator to its startup settings
0 - reset
1 - not reset (default)RW 0x1
14 Reserved. - -
13 UNLOCK : unlocks the VREG control interface after power up
0 - Locked (default)
1 - Unlocked
It cannot be relocked when it is unlocked.RW 0x0
12 ISOLATE : isolates the VREG control interface
0 - not isolated (default)
1 - isolatedRW 0x0
11:9 Reserved. - -
8 DISABLE_VOLTAGE_LIMIT : 0=not disabled, 1=enabled RW 0x0
7 Reserved. - -
6:4 HT_TH : high temperature protection threshold
regulator power transistors are disabled when junction temperature exceeds
threshold
000 - 100C
001 - 105C
010 - 110C
011 - 115C
100 - 120C
101 - 125C
110 - 135C
111 - 150CRW 0x5
3:2 Reserved. - -
1:0 RESERVED : write 0 to this field RW 0x0
POWMAN : VREG_STS Register
Offset : 0x08
Description
Voltage Regulator Status
Table 480. VREG_STS
Register
RP2350 Datasheet
6.4. Power management (POWMAN) registers 463
Bits Description Type Reset
31:5 Reserved. - -
4 VOUT_OK : output regulation status
0=not in regulation, 1=in regulationRO 0x0
3:1 Reserved. - -
0 STARTUP : startup status
0=startup complete, 1=starting upRO 0x0
POWMAN : VREG Register
Offset : 0x0c
Description
Voltage Regulator Settings
Table 481. VREG
RegisterBits Description Type Reset
31:16 Reserved. - -
15 UPDATE_IN_PROGRESS : regulator state is being updated
writes to the vreg register will be ignored when this field is setRO 0x0
14:9 Reserved. - -
RP2350 Datasheet
6.4. Power management (POWMAN) registers 464
Bits Description Type Reset
8:4 VSEL : output voltage select
the regulator output voltage is limited to 1.3V unless the voltage limit
is disabled using the disable_voltage_limit field in the vreg_ctrl register
00000 - 0.55V
00001 - 0.60V
00010 - 0.65V
00011 - 0.70V
00100 - 0.75V
00101 - 0.80V
00110 - 0.85V
00111 - 0.90V
01000 - 0.95V
01001 - 1.00V
01010 - 1.05V
01011 - 1.10V (default)
01100 - 1.15V
01101 - 1.20V
01110 - 1.25V
01111 - 1.30V
10000 - 1.35V
10001 - 1.40V
10010 - 1.50V
10011 - 1.60V
10100 - 1.65V
10101 - 1.70V
10110 - 1.80V
10111 - 1.90V
11000 - 2.00V
11001 - 2.35V
11010 - 2.50V
11011 - 2.65V
11100 - 2.80V
11101 - 3.00V
11110 - 3.15V
11111 - 3.30VRW 0x0b
3 Reserved. - -
2 RESERVED : write 0 to this field RW 0x0
1 HIZ: high impedance mode select
0=not in high impedance mode, 1=in high impedance modeRW 0x0
0 Reserved. - -
POWMAN : VREG_LP_ENTRY Register
Offset : 0x10
Description
Voltage Regulator Low Power Entry Settings
Table 482.
VREG_LP_ENTRY
RegisterBits Description Type Reset
31:9 Reserved. - -
RP2350 Datasheet
6.4. Power management (POWMAN) registers 465
Bits Description Type Reset
8:4 VSEL : output voltage select
the regulator output voltage is limited to 1.3V unless the voltage limit
is disabled using the disable_voltage_limit field in the vreg_ctrl register
00000 - 0.55V
00001 - 0.60V
00010 - 0.65V
00011 - 0.70V
00100 - 0.75V
00101 - 0.80V
00110 - 0.85V
00111 - 0.90V
01000 - 0.95V
01001 - 1.00V
01010 - 1.05V
01011 - 1.10V (default)
01100 - 1.15V
01101 - 1.20V
01110 - 1.25V
01111 - 1.30V
10000 - 1.35V
10001 - 1.40V
10010 - 1.50V
10011 - 1.60V
10100 - 1.65V
10101 - 1.70V
10110 - 1.80V
10111 - 1.90V
11000 - 2.00V
11001 - 2.35V
11010 - 2.50V
11011 - 2.65V
11100 - 2.80V
11101 - 3.00V
11110 - 3.15V
11111 - 3.30VRW 0x0b
3 Reserved. - -
2 MODE : selects either normal (switching) mode or low power (linear) mode
low power mode can only be selected for output voltages up to 1.3V
0 = normal mode (switching)
1 = low power mode (linear)RW 0x1
1 HIZ: high impedance mode select
0=not in high impedance mode, 1=in high impedance modeRW 0x0
0 Reserved. - -
POWMAN : VREG_LP_EXIT Register
Offset : 0x14
Description
Voltage Regulator Low Power Exit Settings
RP2350 Datasheet
6.4. Power management (POWMAN) registers 466
Table 483.
VREG_LP_EXIT
RegisterBits Description Type Reset
31:9 Reserved. - -
8:4 VSEL : output voltage select
the regulator output voltage is limited to 1.3V unless the voltage limit
is disabled using the disable_voltage_limit field in the vreg_ctrl register
00000 - 0.55V
00001 - 0.60V
00010 - 0.65V
00011 - 0.70V
00100 - 0.75V
00101 - 0.80V
00110 - 0.85V
00111 - 0.90V
01000 - 0.95V
01001 - 1.00V
01010 - 1.05V
01011 - 1.10V (default)
01100 - 1.15V
01101 - 1.20V
01110 - 1.25V
01111 - 1.30V
10000 - 1.35V
10001 - 1.40V
10010 - 1.50V
10011 - 1.60V
10100 - 1.65V
10101 - 1.70V
10110 - 1.80V
10111 - 1.90V
11000 - 2.00V
11001 - 2.35V
11010 - 2.50V
11011 - 2.65V
11100 - 2.80V
11101 - 3.00V
11110 - 3.15V
11111 - 3.30VRW 0x0b
3 Reserved. - -
2 MODE : selects either normal (switching) mode or low power (linear) mode
low power mode can only be selected for output voltages up to 1.3V
0 = normal mode (switching)
1 = low power mode (linear)RW 0x0
1 HIZ: high impedance mode select
0=not in high impedance mode, 1=in high impedance modeRW 0x0
0 Reserved. - -
POWMAN : BOD_CTRL Register
Offset : 0x18
Description
Brown-out Detection Control
RP2350 Datasheet
6.4. Power management (POWMAN) registers 467
Table 484. BOD_CTRL
RegisterBits Description Type Reset
31:13 Reserved. - -
12 ISOLATE : isolates the brown-out detection control interface
0 - not isolated (default)
1 - isolatedRW 0x0
11:0 Reserved. - -
POWMAN : BOD Register
Offset : 0x1c
Description
Brown-out Detection Settings
Table 485. BOD
RegisterBits Description Type Reset
31:9 Reserved. - -
8:4 VSEL : threshold select
00000 - 0.473V
00001 - 0.516V
00010 - 0.559V
00011 - 0.602V
00100 - 0.645VS
00101 - 0.688V
00110 - 0.731V
00111 - 0.774V
01000 - 0.817V
01001 - 0.860V (default)
01010 - 0.903V
01011 - 0.946V
01100 - 0.989V
01101 - 1.032V
01110 - 1.075V
01111 - 1.118V
10000 - 1.161
10001 - 1.204VRW 0x0b
3:1 Reserved. - -
0 EN: enable brown-out detection
0=not enabled, 1=enabledRW 0x1
POWMAN : BOD_LP_ENTRY Register
Offset : 0x20
Description
Brown-out Detection Low Power Entry Settings
Table 486.
BOD_LP_ENTRY
RegisterBits Description Type Reset
31:9 Reserved. - -
RP2350 Datasheet
6.4. Power management (POWMAN) registers 468
Bits Description Type Reset
8:4 VSEL : threshold select
00000 - 0.473V
00001 - 0.516V
00010 - 0.559V
00011 - 0.602V
00100 - 0.645VS
00101 - 0.688V
00110 - 0.731V
00111 - 0.774V
01000 - 0.817V
01001 - 0.860V (default)
01010 - 0.903V
01011 - 0.946V
01100 - 0.989V
01101 - 1.032V
01110 - 1.075V
01111 - 1.118V
10000 - 1.161
10001 - 1.204VRW 0x0b
3:1 Reserved. - -
0 EN: enable brown-out detection
0=not enabled, 1=enabledRW 0x0
POWMAN : BOD_LP_EXIT Register
Offset : 0x24
Description
Brown-out Detection Low Power Exit Settings
Table 487.
BOD_LP_EXIT RegisterBits Description Type Reset
31:9 Reserved. - -
8:4 VSEL : threshold select
00000 - 0.473V
00001 - 0.516V
00010 - 0.559V
00011 - 0.602V
00100 - 0.645VS
00101 - 0.688V
00110 - 0.731V
00111 - 0.774V
01000 - 0.817V
01001 - 0.860V (default)
01010 - 0.903V
01011 - 0.946V
01100 - 0.989V
01101 - 1.032V
01110 - 1.075V
01111 - 1.118V
10000 - 1.161
10001 - 1.204VRW 0x0b
3:1 Reserved. - -
RP2350 Datasheet
6.4. Power management (POWMAN) registers 469
Bits Description Type Reset
0 EN: enable brown-out detection
0=not enabled, 1=enabledRW 0x1
POWMAN : LPOSC Register
Offset : 0x28
Description
Low power oscillator control register.
Table 488. LPOSC
RegisterBits Description Type Reset
31:10 Reserved. - -
9:4 TRIM : Frequency trim - the trim step is typically 1% of the reset frequency, but
can be up to 3%RW 0x20
3:2 Reserved. - -
1:0 MODE : This feature has been removed RW 0x3
POWMAN : CHIP_RESET Register
Offset : 0x2c
Description
Chip reset control and status
Table 489.
CHIP_RESET RegisterBits Description Type Reset
31:29 Reserved. - -
28 HAD_WATCHDOG_RESET_PSM : Last reset was a watchdog timeout which
was configured to reset the power-on state machine
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag no
timer no
powman no
swcore no
psm yes
and does not change the power stateRO 0x0
27 HAD_HZD_SYS_RESET_REQ : Last reset was a system reset from the hazard
debugger
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag no
timer no
powman no
swcore no
psm yes
and does not change the power stateRO 0x0
RP2350 Datasheet
6.4. Power management (POWMAN) registers 470
Bits Description Type Reset
26 HAD_GLITCH_DETECT : Last reset was due to a power supply glitch
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag no
timer no
powman no
swcore no
psm yes
and does not change the power stateRO 0x0
25 HAD_SWCORE_PD : Last reset was a switched core powerdown
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag no
timer no
powman no
swcore yes
psm yes
then starts the power sequencerRO 0x0
24 HAD_WATCHDOG_RESET_SWCORE : Last reset was a watchdog timeout
which was configured to reset the switched-core
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag no
timer no
powman no
swcore yes
psm yes
then starts the power sequencerRO 0x0
23 HAD_WATCHDOG_RESET_POWMAN : Last reset was a watchdog timeout
which was configured to reset the power manager
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag no
timer yes
powman yes
swcore yes
psm yes
then starts the power sequencerRO 0x0
RP2350 Datasheet
6.4. Power management (POWMAN) registers 471
Bits Description Type Reset
22 HAD_WATCHDOG_RESET_POWMAN_ASYNC : Last reset was a watchdog
timeout which was configured to reset the power manager asynchronously
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag no
timer yes
powman yes
swcore yes
psm yes
then starts the power sequencerRO 0x0
21 HAD_RESCUE : Last reset was a rescue reset from the debugger
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag no, it sets this flag
timer yes
powman yes
swcore yes
psm yes
then starts the power sequencerRO 0x0
20 Reserved. - -
19 HAD_DP_RESET_REQ : Last reset was an reset request from the arm debugger
This resets:
double_tap flag no
DP no
RPAP no
rescue_flag yes
timer yes
powman yes
swcore yes
psm yes
then starts the power sequencerRO 0x0
18 HAD_RUN_LOW : Last reset was from the RUN pin
This resets:
double_tap flag no
DP yes
RPAP yes
rescue_flag yes
timer yes
powman yes
swcore yes
psm yes
then starts the power sequencerRO 0x0
RP2350 Datasheet
6.4. Power management (POWMAN) registers 472
Bits Description Type Reset
17 HAD_BOR : Last reset was from the brown-out detection block
This resets:
double_tap flag yes
DP yes
RPAP yes
rescue_flag yes
timer yes
powman yes
swcore yes
psm yes
then starts the power sequencerRO 0x0
16 HAD_POR : Last reset was from the power-on reset
This resets:
double_tap flag yes
DP yes
RPAP yes
rescue_flag yes
timer yes
powman yes
swcore yes
psm yes
then starts the power sequencerRO 0x0
15:5 Reserved. - -
4 RESCUE_FLAG : This is set by a rescue reset from the RP-AP.
Its purpose is to halt before the bootrom before booting from flash in order to
recover from a boot lock-up.
The debugger can then attach once the bootrom has been halted and flash
some working code that does not lock up.WC 0x0
3:1 Reserved. - -
0 DOUBLE_TAP : This flag is set by double-tapping RUN. It tells bootcode to go
into the bootloader.RW 0x0
POWMAN : WDSEL Register
Offset : 0x30
Description
Allows a watchdog reset to reset the internal state of powman in addition to the power-on state machine (PSM).
Note that powman ignores watchdog resets that do not select at least the CLOCKS stage or earlier stages in the
PSM. If using these bits, it’s recommended to set PSM_WDSEL to all-ones in addition to the desired bits in this
register. Failing to select CLOCKS or earlier will result in the POWMAN_WDSEL register having no effect.
Table 490. WDSEL
RegisterBits Description Type Reset
31:13 Reserved. - -
12 RESET_PSM : If set to 1, a watchdog reset will run the full power-on state
machine (PSM) sequence
From a user perspective it is the same as setting RSM_WDSEL_PROC_COLD
From a hardware debug perspective it has the same effect as a reset from a
glitch detectorRW 0x0
11:9 Reserved. - -
RP2350 Datasheet
6.4. Power management (POWMAN) registers 473
Bits Description Type Reset
8 RESET_SWCORE : If set to 1, a watchdog reset will reset the switched core
power domain and run the full power-on state machine (PSM) sequence
From a user perspective it is the same as setting RSM_WDSEL_PROC_COLD
From a hardware debug perspective it has the same effect as a power-on
reset for the switched core power domainRW 0x0
7:5 Reserved. - -
4 RESET_POWMAN : If set to 1, a watchdog reset will restore powman defaults,
reset the timer, reset the switched core power domain
and run the full power-on state machine (PSM) sequence
This relies on clk_ref running. Use reset_powman_async if that may not be trueRW 0x0
3:1 Reserved. - -
0 RESET_POWMAN_ASYNC : If set to 1, a watchdog reset will restore powman
defaults, reset the timer,
reset the switched core domain and run the full power-on state machine
(PSM) sequence
This does not rely on clk_ref runningRW 0x0
POWMAN : SEQ_CFG Register
Offset : 0x34
Description
For configuration of the power sequencer
Writes are ignored while POWMAN_STATE_CHANGING=1
Table 491. SEQ_CFG
RegisterBits Description Type Reset
31:21 Reserved. - -
20 USING_FAST_POWCK : 0 indicates the POWMAN clock is running from the low
power oscillator (32kHz)
1 indicates the POWMAN clock is running from the reference clock (2-50MHz)RO 0x1
19:18 Reserved. - -
17 USING_BOD_LP : Indicates the brown-out detector (BOD) mode
0 = BOD high power mode which is the default
1 = BOD low power modeRO 0x0
16 USING_VREG_LP : Indicates the voltage regulator (VREG) mode
0 = VREG high power mode which is the default
1 = VREG low power modeRO 0x0
15:13 Reserved. - -
12 USE_FAST_POWCK : selects the reference clock (clk_ref) as the source of the
POWMAN clock when switched-core is powered. The POWMAN clock always
switches to the slow clock (lposc) when switched-core is powered down
because the fast clock stops running.
0 always run the POWMAN clock from the slow clock (lposc)
1 run the POWMAN clock from the fast clock when available
This setting takes effect when a power up sequence is next runRW 0x1
11:9 Reserved. - -
RP2350 Datasheet
6.4. Power management (POWMAN) registers 474
Bits Description Type Reset
8 RUN_LPOSC_IN_LP : Set to 0 to stop the low power osc when the switched-
core is powered down, which is unwise if using it to clock the timer
This setting takes effect when the swcore is next powered downRW 0x1
7 USE_BOD_HP : Set to 0 to prevent automatic switching to bod high power
mode when switched-core is powered up
This setting takes effect when the swcore is next powered upRW 0x1
6 USE_BOD_LP : Set to 0 to prevent automatic switching to bod low power mode
when switched-core is powered down
This setting takes effect when the swcore is next powered downRW 0x1
5 USE_VREG_HP : Set to 0 to prevent automatic switching to vreg high power
mode when switched-core is powered up
This setting takes effect when the swcore is next powered upRW 0x1
4 USE_VREG_LP : Set to 0 to prevent automatic switching to vreg low power
mode when switched-core is powered down
This setting takes effect when the swcore is next powered downRW 0x1
3:2 Reserved. - -
1 HW_PWRUP_SRAM0 : Specifies the power state of SRAM0 when powering up
swcore from a low power state (P1.xxx) to a high power state (P0.0xx).
0=power-up
1=no changeRW 0x0
0 HW_PWRUP_SRAM1 : Specifies the power state of SRAM1 when powering up
swcore from a low power state (P1.xxx) to a high power state (P0.0xx).
0=power-up
1=no changeRW 0x0
POWMAN : STATE Register
Offset : 0x38
Description
This register controls the power state of the 4 power domains.
The current power state is indicated in POWMAN_STATE_CURRENT which is read-only.
To change the state, write to POWMAN_STATE_REQ.
The coding of POWMAN_STATE_CURRENT & POWMAN_STATE_REQ corresponds to the power states
defined in the datasheet:
bit 3 = SWCORE
bit 2 = XIP cache
bit 1 = SRAM0
bit 0 = SRAM1
0 = powered up
1 = powered down
When POWMAN_STATE_REQ is written, the POWMAN_STATE_WAITING flag is set while the Power Manager
determines what is required. If an invalid transition is requested the Power Manager will still register the request in
POWMAN_STATE_REQ but will also set the POWMAN_BAD_REQ flag. It will then implement the power-up requests
and ignore the power down requests. To do nothing would risk entering an unrecoverable lock-up state. Invalid
requests are: any combination of power up and power down requests any request that results in swcore being
powered and xip unpowered If the request is to power down the switched-core domain then
POWMAN_STATE_WAITING stays active until the processors halt. During this time the POWMAN_STATE_REQ field
can be re-written to change or cancel the request. When the power state transition begins the
POWMAN_STATE_WAITING_flag is cleared, the POWMAN_STATE_CHANGING flag is set and POWMAN register
writes are ignored until the transition completes.
RP2350 Datasheet
6.4. Power management (POWMAN) registers 475
Table 492. STATE
RegisterBits Description Type Reset
31:14 Reserved. - -
13 CHANGING : Indicates a power state change is in progress RO 0x0
12 WAITING : Indicates the power manager has received a state change request
and is waiting for other actions to complete before executing itRO 0x0
11 BAD_HW_REQ : Invalid hardware initiated state request, power up requests
actioned, power down requests ignoredRO 0x0
10 BAD_SW_REQ : Invalid software initiated state request ignored RO 0x0
9 PWRUP_WHILE_WAITING : Indicates that a power state change request was
ignored because of a pending power state change requestWC 0x0
8 REQ_IGNORED : Indicates that a software state change request was ignored
because it clashed with an ongoing hardware or debugger requestWC 0x0
7:4 REQ : This is written by software or hardware to request a new power state RW 0x0
3:0 CURRENT : Indicates the current power state RO 0xf
POWMAN : POW_FASTDIV Register
Offset : 0x3c
Table 493.
POW_FASTDIV
RegisterBits Description Type Reset
31:11 Reserved. - -
10:0 divides the POWMAN clock to provide a tick for the delay module and state
machines
when clk_pow is running from the slow clock it is not divided
when clk_pow is running from the fast clock it is divided by tick_divRW 0x040
POWMAN : POW_DELAY Register
Offset : 0x40
Description
power state machine delays
Table 494.
POW_DELAY RegisterBits Description Type Reset
31:16 Reserved. - -
15:8 SRAM_STEP : timing between the sram0 and sram1 power state machine
steps
measured in units of the powman tick period (>=1us), 0 gives a delay of 1 unitRW 0x20
7:4 XIP_STEP : timing between the xip power state machine steps
measured in units of the lposc period, 0 gives a delay of 1 unitRW 0x1
3:0 SWCORE_STEP : timing between the swcore power state machine steps
measured in units of the lposc period, 0 gives a delay of 1 unitRW 0x1
POWMAN : EXT_CTRL0 Register
Offset : 0x44
Description
Configures a gpio as a power mode aware control output
RP2350 Datasheet
6.4. Power management (POWMAN) registers 476
Table 495. EXT_CTRL0
RegisterBits Description Type Reset
31:15 Reserved. - -
14 LP_EXIT_STATE : output level when exiting the low power state RW 0x0
13 LP_ENTRY_STATE : output level when entering the low power state RW 0x0
12 INIT_STATE RW 0x0
11:9 Reserved. - -
8 INIT RW 0x0
7:6 Reserved. - -
5:0 GPIO_SELECT : selects from gpio 0 →30
set to 31 to disable this featureRW 0x3f
POWMAN : EXT_CTRL1 Register
Offset : 0x48
Description
Configures a gpio as a power mode aware control output
Table 496. EXT_CTRL1
RegisterBits Description Type Reset
31:15 Reserved. - -
14 LP_EXIT_STATE : output level when exiting the low power state RW 0x0
13 LP_ENTRY_STATE : output level when entering the low power state RW 0x0
12 INIT_STATE RW 0x0
11:9 Reserved. - -
8 INIT RW 0x0
7:6 Reserved. - -
5:0 GPIO_SELECT : selects from gpio 0 →30
set to 31 to disable this featureRW 0x3f
POWMAN : EXT_TIME_REF Register
Offset : 0x4c
Description
Select a GPIO to use as a time reference, the source can be used to drive the low power clock at 32kHz, or to
provide a 1ms tick to the timer, or provide a 1Hz tick to the timer. The tick selection is controlled by the
POWMAN_TIMER register.
Table 497.
EXT_TIME_REF
RegisterBits Description Type Reset
31:5 Reserved. - -
4 DRIVE_LPCK : Use the selected GPIO to drive the 32kHz low power clock, in
place of LPOSC. This field must only be written when
POWMAN_TIMER_RUN=0RW 0x0
3:2 Reserved. - -
RP2350 Datasheet
6.4. Power management (POWMAN) registers 477
Bits Description Type Reset
1:0 SOURCE_SEL : 0 → gpio12
1 → gpio20
2 → gpio14
3 → gpio22RW 0x0
Enumerated values:
0x0 → GPIO12
0x1 → GPIO20
0x2 → GPIO14
0x3 → GPIO22
POWMAN : LPOSC_FREQ_KHZ_INT Register
Offset : 0x50
Description
Informs the AON Timer of the integer component of the clock frequency when running off the LPOSC.
Table 498.
LPOSC_FREQ_KHZ_IN
T RegisterBits Description Type Reset
31:6 Reserved. - -
5:0 Integer component of the LPOSC or GPIO clock source frequency in kHz.
Default = 32 This field must only be written when POWMAN_TIMER_RUN=0 or
POWMAN_TIMER_USING_XOSC=1RW 0x20
POWMAN : LPOSC_FREQ_KHZ_FRAC Register
Offset : 0x54
Description
Informs the AON Timer of the fractional component of the clock frequency when running off the LPOSC.
Table 499.
LPOSC_FREQ_KHZ_FR
AC RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 Fractional component of the LPOSC or GPIO clock source frequency in kHz.
Default = 0.768 This field must only be written when POWMAN_TIMER_RUN=0
or POWMAN_TIMER_USING_XOSC=1RW 0xc49c
POWMAN : XOSC_FREQ_KHZ_INT Register
Offset : 0x58
Description
Informs the AON Timer of the integer component of the clock frequency when running off the XOSC.
RP2350 Datasheet
6.4. Power management (POWMAN) registers 478
Table 500.
XOSC_FREQ_KHZ_INT
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 Integer component of the XOSC frequency in kHz. Default = 12000 Must be >1
This field must only be written when POWMAN_TIMER_RUN=0 or
POWMAN_TIMER_USING_XOSC=0RW 0x2ee0
POWMAN : XOSC_FREQ_KHZ_FRAC Register
Offset : 0x5c
Description
Informs the AON Timer of the fractional component of the clock frequency when running off the XOSC.
Table 501.
XOSC_FREQ_KHZ_FRA
C RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 Fractional component of the XOSC frequency in kHz. This field must only be
written when POWMAN_TIMER_RUN=0 or POWMAN_TIMER_USING_XOSC=0RW 0x0000
POWMAN : SET_TIME_63TO48 Register
Offset : 0x60
Table 502.
SET_TIME_63TO48
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 For setting the time, do not use for reading the time, use
POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field
must only be written when POWMAN_TIMER_RUN=0RW 0x0000
POWMAN : SET_TIME_47TO32 Register
Offset : 0x64
Table 503.
SET_TIME_47TO32
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 For setting the time, do not use for reading the time, use
POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field
must only be written when POWMAN_TIMER_RUN=0RW 0x0000
POWMAN : SET_TIME_31TO16 Register
Offset : 0x68
Table 504.
SET_TIME_31TO16
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 For setting the time, do not use for reading the time, use
POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field
must only be written when POWMAN_TIMER_RUN=0RW 0x0000
POWMAN : SET_TIME_15TO0 Register
Offset : 0x6c
RP2350 Datasheet
6.4. Power management (POWMAN) registers 479
Table 505.
SET_TIME_15TO0
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 For setting the time, do not use for reading the time, use
POWMAN_READ_TIME_UPPER and POWMAN_READ_TIME_LOWER. This field
must only be written when POWMAN_TIMER_RUN=0RW 0x0000
POWMAN : READ_TIME_UPPER Register
Offset : 0x70
Table 506.
READ_TIME_UPPER
RegisterBits Description Type Reset
31:0 For reading bits 63:32 of the timer. When reading all 64 bits it is possible for
the LOWER count to rollover during the read. It is recommended to read
UPPER, then LOWER, then re-read UPPER and, if it has changed, re-read
LOWER.RO 0x00000000
POWMAN : READ_TIME_LOWER Register
Offset : 0x74
Table 507.
READ_TIME_LOWER
RegisterBits Description Type Reset
31:0 For reading bits 31:0 of the timer. RO 0x00000000
POWMAN : ALARM_TIME_63TO48 Register
Offset : 0x78
Table 508.
ALARM_TIME_63TO48
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 This field must only be written when POWMAN_ALARM_ENAB=0 RW 0x0000
POWMAN : ALARM_TIME_47TO32 Register
Offset : 0x7c
Table 509.
ALARM_TIME_47TO32
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 This field must only be written when POWMAN_ALARM_ENAB=0 RW 0x0000
POWMAN : ALARM_TIME_31TO16 Register
Offset : 0x80
Table 510.
ALARM_TIME_31TO16
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 This field must only be written when POWMAN_ALARM_ENAB=0 RW 0x0000
POWMAN : ALARM_TIME_15TO0 Register
Offset : 0x84
RP2350 Datasheet
6.4. Power management (POWMAN) registers 480
Table 511.
ALARM_TIME_15TO0
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 This field must only be written when POWMAN_ALARM_ENAB=0 RW 0x0000
POWMAN : TIMER Register
Offset : 0x88
Table 512. TIMER
RegisterBits Description Type Reset
31:20 Reserved. - -
19 USING_GPIO_1HZ : Timer is synchronised to a 1hz gpio source RO 0x0
18 USING_GPIO_1KHZ : Timer is running from a 1khz gpio source RO 0x0
17 USING_LPOSC : Timer is running from lposc RO 0x0
16 USING_XOSC : Timer is running from xosc RO 0x0
15:14 Reserved. - -
13 USE_GPIO_1HZ : Selects the gpio source as the reference for the sec counter.
The msec counter will continue to use the lposc or xosc reference.RW 0x0
12:11 Reserved. - -
10 USE_GPIO_1KHZ : switch to gpio as the source of the 1kHz timer tick SC 0x0
9 USE_XOSC : switch to xosc as the source of the 1kHz timer tick SC 0x0
8 USE_LPOSC : Switch to lposc as the source of the 1kHz timer tick SC 0x0
7 Reserved. - -
6 ALARM : Alarm has fired. Write to 1 to clear the alarm. WC 0x0
5 PWRUP_ON_ALARM : Alarm wakes the chip from low power mode RW 0x0
4 ALARM_ENAB : Enables the alarm. The alarm must be disabled while writing
the alarm time.RW 0x0
3 Reserved. - -
2 CLEAR : Clears the timer, does not disable the timer and does not affect the
alarm. This control can be written at any time.SC 0x0
1 RUN : Timer enable. Setting this bit causes the timer to begin counting up from
its current value. Clearing this bit stops the timer from counting.
Before enabling the timer, set the POWMAN_LPOSC_FREQ* and
POWMAN_XOSC_FREQ* registers to configure the count rate, and initialise the
current time by writing to SET_TIME_63TO48 through SET_TIME_15TO0. You
must not write to the SET_TIME_x registers when the timer is running.
Once configured, start the timer by setting POWMAN_TIMER_RUN=1. This will
start the timer running from the LPOSC. When the XOSC is available switch the
reference clock to XOSC then select it as the timer clock by setting
POWMAN_TIMER_USE_XOSC=1RW 0x0
0 NONSEC_WRITE : Control whether Non-secure software can write to the timer
registers. All other registers are hardwired to be inaccessible to Non-secure.RW 0x0
POWMAN : PWRUP0 Register
RP2350 Datasheet
6.4. Power management (POWMAN) registers 481
Offset : 0x8c
Description
4 GPIO powerup events can be configured to wake the chip up from a low power state.
The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event
The number of gpios available depends on the package option. An invalid selection will be ignored
source = 0 selects gpio0
1.+
2.+ source = 47 selects gpio47
source = 48 selects qspi_ss
source = 49 selects qspi_sd0
source = 50 selects qspi_sd1
source = 51 selects qspi_sd2
source = 52 selects qspi_sd3
source = 53 selects qspi_sclk
level = 0 triggers the pwrup when the source is low
level = 1 triggers the pwrup when the source is high
Table 513. PWRUP0
RegisterBits Description Type Reset
31:11 Reserved. - -
10 RAW_STATUS : Value of selected gpio pin (only if enable == 1) RO 0x0
9 STATUS : Status of gpio wakeup. Write to 1 to clear a latched edge detect. WC 0x0
8 MODE : Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0
transition). Level will detect a 1 or 0. Both types of event get latched into the
current_pwrup_req register.RW 0x0
Enumerated values:
0x0 → LEVEL
0x1 → EDGE
7 DIRECTION RW 0x0
Enumerated values:
0x0 → LOW_FALLING
0x1 → HIGH_RISING
6 ENABLE : Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup
source and clear a pending wakeup event.
If using edge detect a latched edge needs to be cleared by writing 1 to the
status register also.RW 0x0
5:0 SOURCE RW 0x3f
POWMAN : PWRUP1 Register
Offset : 0x90
Description
4 GPIO powerup events can be configured to wake the chip up from a low power state.
The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event
The number of gpios available depends on the package option. An invalid selection will be ignored
source = 0 selects gpio0
1.+
RP2350 Datasheet
6.4. Power management (POWMAN) registers 482
2.+ source = 47 selects gpio47
source = 48 selects qspi_ss
source = 49 selects qspi_sd0
source = 50 selects qspi_sd1
source = 51 selects qspi_sd2
source = 52 selects qspi_sd3
source = 53 selects qspi_sclk
level = 0 triggers the pwrup when the source is low
level = 1 triggers the pwrup when the source is high
Table 514. PWRUP1
RegisterBits Description Type Reset
31:11 Reserved. - -
10 RAW_STATUS : Value of selected gpio pin (only if enable == 1) RO 0x0
9 STATUS : Status of gpio wakeup. Write to 1 to clear a latched edge detect. WC 0x0
8 MODE : Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0
transition). Level will detect a 1 or 0. Both types of event get latched into the
current_pwrup_req register.RW 0x0
Enumerated values:
0x0 → LEVEL
0x1 → EDGE
7 DIRECTION RW 0x0
Enumerated values:
0x0 → LOW_FALLING
0x1 → HIGH_RISING
6 ENABLE : Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup
source and clear a pending wakeup event.
If using edge detect a latched edge needs to be cleared by writing 1 to the
status register also.RW 0x0
5:0 SOURCE RW 0x3f
POWMAN : PWRUP2 Register
Offset : 0x94
Description
4 GPIO powerup events can be configured to wake the chip up from a low power state.
The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event
The number of gpios available depends on the package option. An invalid selection will be ignored
source = 0 selects gpio0
1.+
2.+ source = 47 selects gpio47
source = 48 selects qspi_ss
source = 49 selects qspi_sd0
source = 50 selects qspi_sd1
source = 51 selects qspi_sd2
source = 52 selects qspi_sd3
source = 53 selects qspi_sclk
level = 0 triggers the pwrup when the source is low
RP2350 Datasheet
6.4. Power management (POWMAN) registers 483
level = 1 triggers the pwrup when the source is high
Table 515. PWRUP2
RegisterBits Description Type Reset
31:11 Reserved. - -
10 RAW_STATUS : Value of selected gpio pin (only if enable == 1) RO 0x0
9 STATUS : Status of gpio wakeup. Write to 1 to clear a latched edge detect. WC 0x0
8 MODE : Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0
transition). Level will detect a 1 or 0. Both types of event get latched into the
current_pwrup_req register.RW 0x0
Enumerated values:
0x0 → LEVEL
0x1 → EDGE
7 DIRECTION RW 0x0
Enumerated values:
0x0 → LOW_FALLING
0x1 → HIGH_RISING
6 ENABLE : Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup
source and clear a pending wakeup event.
If using edge detect a latched edge needs to be cleared by writing 1 to the
status register also.RW 0x0
5:0 SOURCE RW 0x3f
POWMAN : PWRUP3 Register
Offset : 0x98
Description
4 GPIO powerup events can be configured to wake the chip up from a low power state.
The pwrups are level/edge sensitive and can be set to trigger on a high/rising or low/falling event
The number of gpios available depends on the package option. An invalid selection will be ignored
source = 0 selects gpio0
1.+
2.+ source = 47 selects gpio47
source = 48 selects qspi_ss
source = 49 selects qspi_sd0
source = 50 selects qspi_sd1
source = 51 selects qspi_sd2
source = 52 selects qspi_sd3
source = 53 selects qspi_sclk
level = 0 triggers the pwrup when the source is low
level = 1 triggers the pwrup when the source is high
Table 516. PWRUP3
RegisterBits Description Type Reset
31:11 Reserved. - -
10 RAW_STATUS : Value of selected gpio pin (only if enable == 1) RO 0x0
9 STATUS : Status of gpio wakeup. Write to 1 to clear a latched edge detect. WC 0x0
RP2350 Datasheet
6.4. Power management (POWMAN) registers 484
Bits Description Type Reset
8 MODE : Edge or level detect. Edge will detect a 0 to 1 transition (or 1 to 0
transition). Level will detect a 1 or 0. Both types of event get latched into the
current_pwrup_req register.RW 0x0
Enumerated values:
0x0 → LEVEL
0x1 → EDGE
7 DIRECTION RW 0x0
Enumerated values:
0x0 → LOW_FALLING
0x1 → HIGH_RISING
6 ENABLE : Set to 1 to enable the wakeup source. Set to 0 to disable the wakeup
source and clear a pending wakeup event.
If using edge detect a latched edge needs to be cleared by writing 1 to the
status register also.RW 0x0
5:0 SOURCE RW 0x3f
POWMAN : CURRENT_PWRUP_REQ Register
Offset : 0x9c
Table 517.
CURRENT_PWRUP_RE
Q RegisterBits Description Type Reset
31:7 Reserved. - -
6:0 Indicates current powerup request state
pwrup events can be cleared by removing the enable from the pwrup register.
The alarm pwrup req can be cleared by clearing timer.alarm_enab
0 = chip reset, for the source of the last reset see POWMAN_CHIP_RESET
1 = pwrup0
2 = pwrup1
3 = pwrup2
4 = pwrup3
5 = coresight_pwrup
6 = alarm_pwrupRO 0x00
POWMAN : LAST_SWCORE_PWRUP Register
Offset : 0xa0
RP2350 Datasheet
6.4. Power management (POWMAN) registers 485
Table 518.
LAST_SWCORE_PWRU
P RegisterBits Description Type Reset
31:7 Reserved. - -
6:0 Indicates which pwrup source triggered the last switched-core power up
0 = chip reset, for the source of the last reset see POWMAN_CHIP_RESET
1 = pwrup0
2 = pwrup1
3 = pwrup2
4 = pwrup3
5 = coresight_pwrup
6 = alarm_pwrupRO 0x00
POWMAN : DBG_PWRCFG Register
Offset : 0xa4
Table 519.
DBG_PWRCFG
RegisterBits Description Type Reset
31:1 Reserved. - -
0 IGNORE : Ignore pwrup req from debugger. If pwrup req is asserted then this
will prevent power down and set powerdown blocked. Set ignore to stop
paying attention to pwrup_reqRW 0x0
POWMAN : BOOTDIS Register
Offset : 0xa8
Description
Tell the bootrom to ignore the BOOT0..3 registers following the next RSM reset (e.g. the next core power down/up).
If an early boot stage has soft-locked some OTP pages in order to protect their contents from later stages, there is a risk
that Secure code running at a later stage can unlock the pages by powering the core up and down.
This register can be used to ensure that the bootloader runs as normal on the next power up, preventing Secure code at
a later stage from accessing OTP in its unlocked state.
Should be used in conjunction with the OTP BOOTDIS register.
Table 520. BOOTDIS
RegisterBits Description Type Reset
31:2 Reserved. - -
1 NEXT : This flag always ORs writes into its current contents. It can be set but
not cleared by software.
The BOOTDIS_NEXT bit is OR’d into the BOOTDIS_NOW bit when the core is
powered down. Simultaneously, the BOOTDIS_NEXT bit is cleared. Setting this
bit means that the BOOT0..3 registers will be ignored following the next reset
of the RSM by powman.
This flag should be set by an early boot stage that has soft-locked OTP pages,
to prevent later stages from unlocking it by power cycling.RW 0x0
RP2350 Datasheet
6.4. Power management (POWMAN) registers 486
Bits Description Type Reset
0 NOW : When powman resets the RSM, the current value of BOOTDIS_NEXT is
OR’d into BOOTDIS_NOW, and BOOTDIS_NEXT is cleared.
The bootrom checks this flag before reading the BOOT0..3 registers. If it is set,
the bootrom clears it, and ignores the BOOT registers. This prevents Secure
software from diverting the boot path before a bootloader has had the chance
to soft lock OTP pages containing sensitive data.WC 0x0
POWMAN : DBGCONFIG Register
Offset : 0xac
Table 521.
DBGCONFIG RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 DP_INSTID : Configure DP instance ID for SWD multidrop selection.
Recommend that this is NOT changed until you require debug access in multi-
chip environmentRW 0x0
POWMAN : SCRATCH0, SCRATCH1, …, SCRATCH6, SCRATCH7 Registers
Offsets : 0xb0, 0xb4, …, 0xc8, 0xcc
Table 522. SCRATCH0,
SCRATCH1, …,
SCRATCH6,
SCRATCH7 RegistersBits Description Type Reset
31:0 Scratch register. Information persists in low power mode RW 0x00000000
POWMAN : BOOT0, BOOT1, BOOT2, BOOT3 Registers
Offsets : 0xd0, 0xd4, 0xd8, 0xdc
Table 523. BOOT0,
BOOT1, BOOT2,
BOOT3 RegistersBits Description Type Reset
31:0 Scratch register. Information persists in low power mode RW 0x00000000
POWMAN : INTR Register
Offset : 0xe0
Description
Raw Interrupts
Table 524. INTR
RegisterBits Description Type Reset
31:4 Reserved. - -
3 PWRUP_WHILE_WAITING : Source is state.pwrup_while_waiting RO 0x0
2 STATE_REQ_IGNORED : Source is state.req_ignored RO 0x0
1 TIMER RO 0x0
0 VREG_OUTPUT_LOW WC 0x0
POWMAN : INTE Register
Offset : 0xe4
RP2350 Datasheet
6.4. Power management (POWMAN) registers 487
Description
Interrupt Enable
Table 525. INTE
RegisterBits Description Type Reset
31:4 Reserved. - -
3 PWRUP_WHILE_WAITING : Source is state.pwrup_while_waiting RW 0x0
2 STATE_REQ_IGNORED : Source is state.req_ignored RW 0x0
1 TIMER RW 0x0
0 VREG_OUTPUT_LOW RW 0x0
POWMAN : INTF Register
Offset : 0xe8
Description
Interrupt Force
Table 526. INTF
RegisterBits Description Type Reset
31:4 Reserved. - -
3 PWRUP_WHILE_WAITING : Source is state.pwrup_while_waiting RW 0x0
2 STATE_REQ_IGNORED : Source is state.req_ignored RW 0x0
1 TIMER RW 0x0
0 VREG_OUTPUT_LOW RW 0x0
POWMAN : INTS Register
Offset : 0xec
Description
Interrupt status after masking & forcing
Table 527. INTS
RegisterBits Description Type Reset
31:4 Reserved. - -
3 PWRUP_WHILE_WAITING : Source is state.pwrup_while_waiting RO 0x0
2 STATE_REQ_IGNORED : Source is state.req_ignored RO 0x0
1 TIMER RO 0x0
0 VREG_OUTPUT_LOW RO 0x0
6.5. Power reduction strategies
RP2350 retains the SLEEP and DORMANT states for dynamic power control from RP2040. It extends these states by
introducing power domains ( Section 6.2.1 ), which allow power to be removed from various components on chip,
virtually eliminating the leakage currents, and allowing lower power modes to be supported.
RP2350 Datasheet
6.5. Power reduction strategies 488
6.5.1. Top-level clock gates
Each clock domain (for example, the system clock) may drive a large number of distinct hardware blocks, not all of
which might be required at once. To avoid unnecessary power dissipation, each individual endpoint of each clock (for
example, the UART system clock input) may be disabled at any time.
Enabling and disabling a clock gate is glitch-free. If a peripheral clock is temporarily disabled, and subsequently re-
enabled, the peripheral will be in the same state as prior to the clock being disabled. No reset or reinitialisation should
be required.
Clock gates are controlled by two sets of registers: the WAKE_ENx  registers (starting at WAKE_EN0 ) and SLEEP_ENx  registers
(starting at SLEEP_EN0 ). These two sets of registers are identical at the bit level, each possessing a flag to control each
clock endpoint. The WAKE_EN registers specify which clocks are enabled whilst the system is awake, and the SLEEP_ENx 
registers select which clocks are enabled while the processor is in the SLEEP state ( Section 6.5.2 ).
The two processors do not have externally-controllable clock gates. Instead, the processors gate the clocks of their
subsystems autonomously, based on execution of WFI/WFE instructions, and external Event and IRQ signals.
6.5.2. SLEEP state
RP2350 enters the SLEEP state when all of the following are true:
•Both processors are asleep (e.g. in a WFE or WFI instruction)
•The system DMA has no outstanding transfers on any channel
RP2350 exits the SLEEP state when either processor is awoken by an interrupt.
When in the SLEEP state, the top-level clock gates are masked by the SLEEP_ENx  registers (starting at SLEEP_EN0 ), rather
than the WAKE_ENx  registers (starting at WAKE_EN0 ). This permits more aggressive pruning of the clock tree when the
processors are asleep.
NOTE
Though it is possible for a clock to be enabled during SLEEP and disabled outside of SLEEP, this is generally not
useful.
For example, if the system is sleeping until a character interrupt from a UART, the entire system except for the UART
can be clock-gated ( SLEEP_ENx  = all-zeroes except for CLK_SYS_UART0  and CLK_PERI_UART0 ). This includes system
infrastructure such as the bus fabric.
When the UART asserts its interrupt and wakes a processor, RP2350 leaves SLEEP mode and switches back to the
WAKE_ENx  clock mask. At the minimum, this should include the bus fabric and the memory devices containing the
processor’s stack and interrupt vectors.
A system-level clock request handshake holds the processors off the bus until the clocks are re-enabled.
6.5.3. DORMANT state
The DORMANT state is a true zero-dynamic-power sleep state, where all clocks (and all oscillators) are disabled. The
system can awake from the DORMANT state upon a GPIO event (high/low level or rising/falling edge), or an AON Timer
alarm: this restarts one of the oscillators (either ring oscillator or crystal oscillator) and ungates the oscillator output
after it is stable. System state is retained, so code execution resumes immediately upon leaving the DORMANT state.
If relying on the AON Timer ( Section 12.10 ) to wake from the DORMANT state, the AON Timer must run from the LPOSC
or an external clock source. The AON Timer accepts clock frequencies as low as 1Hz.
DORMANT does not halt PLLs. To avoid unnecessary power dissipation, software should power down PLLs before
entering the DORMANT state, and power up and reconfigure the PLLs again after exiting.
RP2350 Datasheet
6.5. Power reduction strategies 489
If you halt the crystal oscillator (XOSC), you must also halt the PLLs to prevent them losing lock when their input
reference clock stops. The PLL VCO may behave erratically when the frequency reference is lost, such as increasing to
a very high frequency. Reconfigure and re-enable the PLLs after the XOSC starts again. Do not attempt to run clocks
from the PLLs while the XOSC is stopped.
The DORMANT state is entered by writing a keyword to the DORMANT register in whichever oscillator is active: ring
oscillator ( Section 8.3 ) or crystal oscillator ( Section 8.2 ). If both are active, the one providing the processor clock must
be stopped last because it will stop software from executing.
6.5.3.1. Waking from the DORMANT state
The system exits the DORMANT state on any of the following events:
•an alarm from the AON Timer which causes TIMER .ALARM to assert
•the assertion of an interrupt from GPIO Bank 0 to the DORMANT_WAKE  interrupt destination
•the assertion of an interrupt from GPIO Bank 1 to the DORMANT_WAKE  interrupt destination
When waking from the AON Timer you do not have to enable the IRQ output from POWMAN. It is sufficient for the timer
to fire, without being mapped to an interrupt output. Any AON Timer alarm comparison event which causes
TIMER .ALARM to assert causes the system to exit the DORMANT state. It is the actual alarm event which causes the
exit, not the TIMER .ALARM status; if you enter the DORMANT state with the TIMER .ALARM status set to 1, but the timer
alarm comparison logic disabled  by TIMER .ALARM_ENAB, you will not exit the DORMANT state.
The GPIO Bank registers have interrupt enable registers for interrupts targeting the DORMANT mode wake logic, such
as DORMANT_WAKE_INTE0 . These are identical to the interrupt enable registers for interrupts targeting the processors,
such as PROC0_INTE0 .
Waking from the DORMANT state restarts the oscillator which was disabled by entry to the DORMANT state. It does not
restart any other oscillators, or change any system-level clock configuration.
6.5.4. Memory periphery power down
The main system memories ( SRAM0 → SRAM9, mapped to bus addresses 0x20000000  to 0x20081fff ), as well as the USB
DPRAM, can be partially powered down via the MEMPOWERDOWN  register in the SYSCFG registers (see Section
12.15.2 ). This powers down the analogue circuitry used to access the SRAM storage array (the periphery  of the SRAM)
but the storage array itself remains powered. Memories retain their current contents, but cannot be accessed. Static
power is reduced.
CAUTION
Memories must not be accessed when powered down. Doing so can corrupt memory contents.
When powering a memory back up, a 20ns delay is required before accessing the memory again.
The XIP cache (see Section 4.4 ) can also be powered down, with CTRL .POWER_DOWN. The XIP hardware will not
generate cache accesses whilst the cache is powered down. Note that this is unlikely to produce a net power savings if
code continues to execute from XIP, due to the comparatively high voltages and switching capacitances of the external
QSPI bus.
6.5.5. Full memory power down
RP2350 can completely power down its internal SRAM. Unlike the memory periphery power down described in Section
6.5.4 , this completely disconnects the SRAM from the power supply, reducing static power to near zero.
Contents are lost when fully powering down memories. When you power memories up again following a power down,
RP2350 Datasheet
6.5. Power reduction strategies 490
the contents is completely undefined.
There are three distinct SRAM power domains:
SRAM0
Contains main system SRAM for addresses 0x20000000  through 0x2003ffff  (SRAM banks 0 through 3).
SRAM1
Contains main system SRAM for addresses 0x20040000  through 0x20081fff  (SRAM banks 4 through 9).
XIP
Contains the XIP cache and the boot RAM.
The XIP power domain is always powered when the switched core domain is powered. The switched core domain is the
domain which includes all core logic, such as processors, bus fabric and peripherals. This means the memories in this
domain are always powered whenever software is running.
Besides powering memory down to save power, you can also leave memories powered up whilst powering down the
switched core domain. This retains program state in SRAM while eliminating static power dissipation in core logic.
For more information see:
•Chapter 4  for a list of RP2350 memory resources, including main system SRAM, the XIP cache and boot RAM
•Section 6.2.1  for the definition of core power domains, including the memory power domains enumerated above
•Section 6.2.2  for the list of supported memory power states
•Section 6.2.3  for information on initiating power state transitions to power memories up or down
•Section 14.9.7.2  for typical power consumption in low-power states including memory power down
6.5.6. Programmer’s model
6.5.6.1. Sleep
The hello_sleep  example ( hello_sleep_aon.c  in the pico-playground  GitHub repository ) demonstrates sleep mode. The
hello_sleep  application (and underlying functions) takes the following steps:
1.Switches all clocks in the system to run from XOSC.
2.Configures an alarm in the AON Timer for 10 seconds in the future.
3.Sets the AON Timer clock as the only clock running in sleep mode using the SLEEP_ENx  registers (see SLEEP_EN0 ).
4.Enables deep sleep in the processor.
5.Calls __wfi on processor, which will put the processor into deep sleep until woken by the AON Timer interrupt.
6.After 10 seconds, the AON Timer interrupt clears the alarm and then calls a user supplied callback function.
7.The callback function ends the example application.
NOTE
To enter sleep mode, you must enable deep sleep on both proc0 and proc1, call __wfi, and ensure the DMA is
stopped.
hello_sleep  makes use of functions in pico_sleep  of the Pico Extras . In particular, sleep_goto_sleep_until  puts the
processor to sleep until woken up by an AON Timer time assumed to be in the future.
RP2350 Datasheet
6.5. Power reduction strategies 491
Pico Extras: https://github.com/raspberrypi/pico-extras/blob/master/src/rp2_common/pico_sleep/sleep.c  Lines 159 - 183
159 void sleep_goto_sleep_until (struct timespec  *ts, aon_timer_alarm_handler_t  callback )
160 {
161 
162     // We should have already called the sleep_run_from_dormant_source function
163     // This is only needed for dormancy although it saves power running from xosc while
    sleeping
164     //assert(dormant_source_valid(_dormant_source));
165 
166     clocks_hw ->sleep_en0  = CLOCKS_SLEEP_EN0_CLK_REF_POWMAN_BITS ;
167     clocks_hw ->sleep_en1  = 0x0;
168 
169     aon_timer_enable_alarm (ts, callback , false);
170 
171     stdio_flush ();
172 
173     // Enable deep sleep at the proc
174     processor_deep_sleep ();
175 
176     // Go to sleep
177     __wfi();
178 }
6.5.6.2. DORMANT
The hello_dormant  example, hello_dormant_gpio.c  in the pico-playground  GitHub repository , demonstrates the DORMANT
state. The example takes the following steps:
1.Switches all clocks in the system to run from XOSC.
2.Configures a GPIO interrupt for the dormant_wake  hardware, which can wake both the ROSC and XOSC from dormant
mode.
3.Puts the XOSC into dormant mode, which stops all processor execution (and all other clocked logic on the chip)
immediately.
4.When GPIO 10 goes high, the XOSC restarts and program execution continues.
hello_dormant  uses sleep_goto_dormant_until_pin  under the hood:
Pico Extras: https://github.com/raspberrypi/pico-extras/blob/master/src/rp2_common/pico_sleep/sleep.c  Lines 258 - 282
258 void sleep_goto_dormant_until_pin (uint gpio_pin , bool edge, bool high) {
259     bool low = !high;
260     bool level = !edge;
261 
262     // Configure the appropriate IRQ at IO bank 0
263     assert(gpio_pin  < NUM_BANK0_GPIOS );
264 
265     uint32_t  event = 0;
266 
267     if (level && low) event = IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_BITS ;
268     if (level && high) event = IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_BITS ;
269     if (edge && high) event = IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_BITS ;
270     if (edge && low) event = IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_BITS ;
271 
272     gpio_init (gpio_pin );
273     gpio_set_input_enabled (gpio_pin , true);
274     gpio_set_dormant_irq_enabled (gpio_pin , event, true);
275 
RP2350 Datasheet
6.5. Power reduction strategies 492
276     _go_dormant ();
277     // Execution stops here until woken up
278 
279     // Clear the irq so we can go back to dormant mode again if we want
280     gpio_acknowledge_irq (gpio_pin , event);
281     gpio_set_input_enabled (gpio_pin , false);
282 }
RP2350 Datasheet
6.5. Power reduction strategies 493
Chapter 7. Resets
7.1. Overview
Resets are divided into three categories, each of which applies to a subset of RP2350:
Chip-level resets
apply to the entire chip. Used to put the entire chip into a default state. These are initiated by hardware events, the
watchdog, or the debugger. When all chip level resets are de-asserted, the system resets are released and the
processors boot.
System resets
apply to components essential to processor operation. System components have interdependencies, therefore their
resets are de-asserted in sequence by the Power-on State Machine (PSM). The full PSM sequence is triggered by
deassertion of chip-level resets. A full or partial sequence can be triggered by the watchdog or debugger. The
sequence culminates in processor boot.
Subsystem resets
apply to components not essential for operation of the processors. The resets can be independently asserted by
writing to the RESETS registers and de-asserted by software, the watchdog, or the debugger.
The watchdog can be programmed to trigger any of the above categories.
7.2. Changes from RP2040
RP2350 retains all RP2040 chip-level reset features.
RP2350 adds the following features:
•new chip reset sources:
◦glitch detector
◦watchdog
◦debugger
•new destinations:
◦new power management components
RP2350 makes the following modifications to existing features:
•Modified the CHIP_RESET  register, which records the source of the last chip level reset. In RP2040, CHIP_RESET  was
stored in the LDO_POR register block. In RP2350, CHIP_RESET  was extended and moved to the POWMAN register block,
which is in the new always-on power domain ( AON).
•Renamed the brownout reset ( BOR) registers to brownout detect ( BOD), added functionality, and moved them to the
new POWlMAN register block.
•Added more system reset stages. To support this, added additional Power-on State Machine fields and rearranged
the existing fields.
•Added additional RESETS registers and rearranged the existing fields.
•Extended watchdog options to enable triggers for new resets.
RP2350 Datasheet
7.1. Overview 494
NOTE
Watchdog scratch registers are not preserved when the watchdog triggers a chip-level reset. However, watchdog
scratch registers are preserved after a system or subsystem reset. For general purpose scratch registers that do not
reset after a chip-level reset, see the POWMAN register block Section 6.4, “Power management (POWMAN) registers” .
7.3. Chip-level resets
Chip-level resets put the entire chip into a default state. These resets are only initiated by hardware events, the
debugger, or a watchdog timeout.
7.3.1. Chip-level reset table
Table 528, “List of chip-level reset causes”  shows the components reset by each of the chip-level reset sources. A dash
(—) indicates no change caused by this source.
Table 528. List of
chip-level reset causesReset Source SW-DP AON Scratch POWMAN Power State Double Tap Rescue
POR reset reset hard reset → P0.0 reset reset
BOR reset reset hard reset → P0.0 reset reset
EXTERNAL RESET (RUN) reset reset hard reset → P0.0  —  reset
DEBUGGER RESET REQ  —   —  hard reset → P0.0  —  reset
DEBUGGER RESCUE  —   —  hard reset → P0.0  —  set
WATCHDOG POWMAN ASYNC RESET  —   —  hard reset → P0.0  —   — 
WATCHDOG POWMAN RESET  —   —  soft reset → P0.0  —   — 
WATCHDOG SWCORE RESET  —   —   —  → P0.0  —   — 
SWCORE POWERDOWN  —   —   —  → P0.x  —   — 
GLITCH_DETECTOR  —   —   —   —   —   — 
WATCHDOG RESET PSM  —   —   —   —   —   — 
All chip-level resets sources in the table also reset the Power-on State Machine (PSM). This asserts all of the system
resets downstream of the PSM. System resets includes low-level chip infrastructure like the system-level clock
generators, as well as the processor cold and warm reset domains.
All chip-level reset sources in the table also reset the system watchdog peripheral. This includes watchdog scratch
registers SCRATCH0  → SCRATCH7 .
You can interpret the table columns as follows:
Reset Source
Indicates which of the events listed in Chip-level Reset Sources  is responsible for this chip-level reset.
SW-DP
Indicates the SWD Debug Port and the RP-AP ( Section 3.5.10, “RP-AP” ) are reset.
AON Scratch
Indicates scratch register state in POWMAN SCRATCH0  → SCRATCH7  and BOOT0  → BOOT3  registers is lost.
These registers are always-on, meaning they are preserved across power-down of the switched core domain.
RP2350 Datasheet
7.3. Chip-level resets 495
POWMAN
Indicates some or all of the register state of the power manager (POWMAN) is reset.
Power State
Indicates a change to the powered/unpowered status of core voltage domains.
Double Tap
Indicates the CHIP_RESET .DOUBLE_TAP bit is reset.
Rescue
Indicates changes to the CHIP_RESET .RESCUE_FLAG bit.
7.3.2. Chip-level reset destinations
Chip-level resets apply to the following primary components:
•the SW-DP and RP-AP debug components
•power manager scratch and boot registers
•power manager including the always-on timer
•power state (restored to state P0.0, in which all domains are powered, see Section 6.2.2, “Power states” )
•system resets (any chip-level reset triggers the PSM (power-on state machine), which sequences the system
resets, see Section 7.4, “System resets (Power-on State Machine)” )
•watchdog (reset by any chip-level reset, including one triggered by the watchdog)
Chip-level resets also reset the following two CHIP_RESET  register flags:
•CHIP_RESET .DOUBLE_TAP: the bootrom can use this flag to detect a double-press of a button connected to the
RUN pin, and enter the USB or UART bootloader. See the BOOT_FLAGS1 .DOUBLE_TAP OTP flag.
•CHIP_RESET .RESCUE_FLAG: this flag instructs the bootrom to halt the boot process. The bootrom clears the flag
to acknowledge. You can use this to perform a full-system reset from almost any state (particularly ones where all
system clocks are stopped), and catch the processors before they re-run the code that caused the bad state.
NOTE
When the SW-DP and RP-AP are out of reset, you can use them to perform low-level debug operations like a rescue
reset or a forced power-up over SWD. However accessing any other debug hardware, such as the Mem-APs, requires
the system clock to be running.
NOTE
These flags are located in located in the CHIP_RESET  register in the POWMAN register space, so they are included in
the always-on (AON) power domain.
7.3.3. Chip-level reset sources
In order of severity, the following events can trigger a chip-level reset:
Power-On Reset (POR)
The power-on reset ensures the chip starts up cleanly when power is first applied by holding it in reset until the
digital core supply (DVDD) reaches a voltage high enough to reliably power the chip’s core logic. The POR
component is described in detail in Section 7.6.1, “Power-on reset (POR)” .
RP2350 Datasheet
7.3. Chip-level resets 496
Brownout Detection (BOD)
The brownout detector prevents unreliable operation when the digital core supply (DVDD) drops below a safe
operating level. The BOD component is described in detail in Section 7.6.2, “Brownout detection (BOD)” . The reset
asserted by the BOD is referred to as the brownout reset, or BOR.
External Reset
The chip can be reset by taking the RUN pin low. This holds the chip in reset irrespective of the state of the core
power supply (DVDD), the power-on reset block, and brownout detection block. RUN can be used to extend the initial
power-on reset, or can be driven from an external source to start and stop the chip as required. If RUN is not used, it
should be tied high. Double-tapping the RUN low will set CHIP_RESET .DOUBLE_TAP. Boot code reads this flag and
selects an alternate boot sequence if the flag is set.
Debugger Reset Request
The debugger is able to initiate a chip-level reset using the CDBGPWRUPREQ  control. For more information, see Section
3.5, “Debug” .
Rescue Debug Port Reset
The chip can also be reset via the Rescue Debug Port. This allows the chip to be recovered from a locked-up state.
In addition to resetting the chip, a Rescue Debug Port reset also sets CHIP_RESET .RESCUE_FLAG. This is checked
by boot code at startup, causing it to enter a safe state if the bit is set. See Section 3.5.8, “Rescue reset”  for more
information.
Watchdog
The watchdog can trigger various levels of chip-level reset by setting appropriate bits in the WDSEL  register. A chip-
level reset triggered by a watchdog reset will reset the watchdog and the watchdog scratch registers. Additional
general purpose scratch registers are available in POWMAN. These are not reset by a chip-level reset triggered by the
watchdog.
SWCORE Powerdown
For a list of operations that power down the switched-core power domain (SWCORE) and trigger this reset, see
Section 6.2, “Power management” .
Glitch Detector
This reset fires if a glitch is detected in SWCORE power supply. For more information, see Section 10.9, “Glitch
detector” .
RISC-V Non-Debug-Module Reset
The dmcontrol.ndmreset  bit in the RISC-V Debug Module resets all RISC-V harts in the system. It resets no other
hardware. However, it is recorded as a chip-level reset reason in CHIP_RESET .HAD_HZD_SYS_RESET_REQ. See
Section 3.5.3, “RISC-V debug”  for details of the RISC-V debug subsystem.
The source of the last chip-level reset is recorded in the CHIP_RESET  register.
A complete list of POWMAN registers is provided in Section 6.4, “Power management (POWMAN) registers” .
7.4. System resets (Power-on State Machine)
RP2350 Datasheet
7.4. System resets (Power-on State Machine) 497
Chip Level Reset Released
Ring Oscillator
Bus FabricBoot ROM PSM ReadyOTP Crystal Oscillator
SRAM 0–9XIP CacheSIOAccess ControlProcessorsClocks Boot RAMFigure 27. Power-on
State Machine
Sequence
System Resets apply to components essential to processor operation. System components have interdependencies,
therefore their resets are de-asserted in sequence by the Power-on State Machine (PSM). Each stage of the sequencer
outputs a reset done signal when complete, rst_done , which releases the reset input to the next stage. A partial
sequence runs after a write to the FRCE_OFF  register or a watchdog timeout. Note that the FRCE_ON register is intended for
internal use only and is disabled in production devices.
The Power-on State Machine sequences system-level reset release following a power-up of the switched core power
domain. It is distinct from the power manager (POWMAN) which controls power domain switching, see Section 6.2,
“Power management” .
7.4.1. Reset sequence
Following a chip-level reset, the Power-on State Machine (PSM):
1.Removes cold reset to processors.
2.Takes OTP out of reset. OTP reads any content required to boot and asserts rst_done .
3.Starts the Ring Oscillator. Asserts rst_done  once the oscillator output is stable.
4.Removes Crystal Oscillator (XOSC) controller reset. The XOSC does not start yet, so rst_done  is asserted
immediately.
5.Deasserts the master subsystem reset, but does not remove individual subsystem resets.
6.Starts the clk_ref and clk_sys clock generators. In the initial configuration, clk_ref runs from the ring oscillator with
no divider and clk_sys runs from clk_ref.
7.The PSM confirms the clocks are active.
8.Removes Bus Fabric reset and initialises logic.
9.Removes various memory controllers' resets and initialises logic.
10.Removes Single-cycle IO subsystem (SIO) reset and initialises logic.
11.Removes Access Controller reset and initialises logic.
12.Deasserts Processor Complex reset. Both core 0 and core 1 start executing the boot code from ROM. The boot
code reads the core id and core 1 sleeps, leaving core 0 to continue bootrom execution.
RP2350 Datasheet
7.4. System resets (Power-on State Machine) 498
Following a watchdog reset trigger, the PSM restarts from a point selected by the PSM WDSEL  register.
7.4.2. Register control
The PSM is a fully automated piece of hardware: it requires no input from the user to work. The debugger can trigger a
full or partial sequence by writing to the FRCE_OFF  register. The FRCE_ON register is a development feature that does
nothing in production devices.
7.4.3. Interaction with watchdog
The watchdog can trigger a full or partial sequence by writing to the WDSEL register.
7.4.4. List of registers
The PSM registers start at a base address of 0x40018000  (defined as PSM_BASE  in SDK).
Table 529. List of PSM
registersOffset Name Info
0x0 FRCE_ON Force block out of reset (i.e. power it on)
0x4 FRCE_OFF Force into reset (i.e. power it off)
0x8 WDSEL Set to 1 if the watchdog should reset this
0xc DONE Is the subsystem ready?
PSM : FRCE_ON Register
Offset : 0x0
Description
Force block out of reset (i.e. power it on)
Table 530. FRCE_ON
RegisterBits Description Type Reset
31:25 Reserved. - -
24 PROC1 RW 0x0
23 PROC0 RW 0x0
22 ACCESSCTRL RW 0x0
21 SIO RW 0x0
20 XIP RW 0x0
19 SRAM9 RW 0x0
18 SRAM8 RW 0x0
17 SRAM7 RW 0x0
16 SRAM6 RW 0x0
15 SRAM5 RW 0x0
14 SRAM4 RW 0x0
13 SRAM3 RW 0x0
12 SRAM2 RW 0x0
RP2350 Datasheet
7.4. System resets (Power-on State Machine) 499
Bits Description Type Reset
11 SRAM1 RW 0x0
10 SRAM0 RW 0x0
9 BOOTRAM RW 0x0
8 ROM RW 0x0
7 BUSFABRIC RW 0x0
6 PSM_READY RW 0x0
5 CLOCKS RW 0x0
4 RESETS RW 0x0
3 XOSC RW 0x0
2 ROSC RW 0x0
1 OTP RW 0x0
0 PROC_COLD RW 0x0
PSM : FRCE_OFF Register
Offset : 0x4
Description
Force into reset (i.e. power it off)
Table 531. FRCE_OFF
RegisterBits Description Type Reset
31:25 Reserved. - -
24 PROC1 RW 0x0
23 PROC0 RW 0x0
22 ACCESSCTRL RW 0x0
21 SIO RW 0x0
20 XIP RW 0x0
19 SRAM9 RW 0x0
18 SRAM8 RW 0x0
17 SRAM7 RW 0x0
16 SRAM6 RW 0x0
15 SRAM5 RW 0x0
14 SRAM4 RW 0x0
13 SRAM3 RW 0x0
12 SRAM2 RW 0x0
11 SRAM1 RW 0x0
10 SRAM0 RW 0x0
9 BOOTRAM RW 0x0
8 ROM RW 0x0
RP2350 Datasheet
7.4. System resets (Power-on State Machine) 500
Bits Description Type Reset
7 BUSFABRIC RW 0x0
6 PSM_READY RW 0x0
5 CLOCKS RW 0x0
4 RESETS RW 0x0
3 XOSC RW 0x0
2 ROSC RW 0x0
1 OTP RW 0x0
0 PROC_COLD RW 0x0
PSM : WDSEL Register
Offset : 0x8
Description
Set to 1 if the watchdog should reset this
Table 532. WDSEL
RegisterBits Description Type Reset
31:25 Reserved. - -
24 PROC1 RW 0x0
23 PROC0 RW 0x0
22 ACCESSCTRL RW 0x0
21 SIO RW 0x0
20 XIP RW 0x0
19 SRAM9 RW 0x0
18 SRAM8 RW 0x0
17 SRAM7 RW 0x0
16 SRAM6 RW 0x0
15 SRAM5 RW 0x0
14 SRAM4 RW 0x0
13 SRAM3 RW 0x0
12 SRAM2 RW 0x0
11 SRAM1 RW 0x0
10 SRAM0 RW 0x0
9 BOOTRAM RW 0x0
8 ROM RW 0x0
7 BUSFABRIC RW 0x0
6 PSM_READY RW 0x0
5 CLOCKS RW 0x0
4 RESETS RW 0x0
RP2350 Datasheet
7.4. System resets (Power-on State Machine) 501
Bits Description Type Reset
3 XOSC RW 0x0
2 ROSC RW 0x0
1 OTP RW 0x0
0 PROC_COLD RW 0x0
PSM : DONE Register
Offset : 0xc
Description
Is the subsystem ready?
Table 533. DONE
RegisterBits Description Type Reset
31:25 Reserved. - -
24 PROC1 RO 0x0
23 PROC0 RO 0x0
22 ACCESSCTRL RO 0x0
21 SIO RO 0x0
20 XIP RO 0x0
19 SRAM9 RO 0x0
18 SRAM8 RO 0x0
17 SRAM7 RO 0x0
16 SRAM6 RO 0x0
15 SRAM5 RO 0x0
14 SRAM4 RO 0x0
13 SRAM3 RO 0x0
12 SRAM2 RO 0x0
11 SRAM1 RO 0x0
10 SRAM0 RO 0x0
9 BOOTRAM RO 0x0
8 ROM RO 0x0
7 BUSFABRIC RO 0x0
6 PSM_READY RO 0x0
5 CLOCKS RO 0x0
4 RESETS RO 0x0
3 XOSC RO 0x0
2 ROSC RO 0x0
1 OTP RO 0x0
0 PROC_COLD RO 0x0
RP2350 Datasheet
7.4. System resets (Power-on State Machine) 502
7.5. Subsystem resets
7.5.1. Overview
The reset controller allows software to reset non-critical components in RP2350. The reset controller can reset the
following components:
•USB Controller
•PIO
•Peripherals, including UART, I2C, SPI, PWM, Timer, ADC
•PLLs
•IO and Pad registers
For a full list of components that can be reset using the reset controller, see the register descriptions ( Section 7.5.3,
“List of Registers” ).
When reset, components are held in reset at power-up. To use the component, software must deassert the reset.
NOTE
The SDK automatically deasserts some components after a reset.
7.5.2. Programmer’s model
The SDK uses the following struct to represent the resets registers:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2350/hardware_structs/include/hardware/structs/resets.h  Lines 63 - 159
 63 typedef struct {
 64     _REG_(RESETS_RESET_OFFSET ) // RESETS_RESET
 65     // 0x10000000 [28]    USBCTRL      (1)
 66     // 0x08000000 [27]    UART1        (1)
 67     // 0x04000000 [26]    UART0        (1)
 68     // 0x02000000 [25]    TRNG         (1)
 69     // 0x01000000 [24]    TIMER1       (1)
 70     // 0x00800000 [23]    TIMER0       (1)
 71     // 0x00400000 [22]    TBMAN        (1)
 72     // 0x00200000 [21]    SYSINFO      (1)
 73     // 0x00100000 [20]    SYSCFG       (1)
 74     // 0x00080000 [19]    SPI1         (1)
 75     // 0x00040000 [18]    SPI0         (1)
 76     // 0x00020000 [17]    SHA256       (1)
 77     // 0x00010000 [16]    PWM          (1)
 78     // 0x00008000 [15]    PLL_USB      (1)
 79     // 0x00004000 [14]    PLL_SYS      (1)
 80     // 0x00002000 [13]    PIO2         (1)
 81     // 0x00001000 [12]    PIO1         (1)
 82     // 0x00000800 [11]    PIO0         (1)
 83     // 0x00000400 [10]    PADS_QSPI    (1)
 84     // 0x00000200 [9]     PADS_BANK0   (1)
 85     // 0x00000100 [8]     JTAG         (1)
 86     // 0x00000080 [7]     IO_QSPI      (1)
 87     // 0x00000040 [6]     IO_BANK0     (1)
 88     // 0x00000020 [5]     I2C1         (1)
 89     // 0x00000010 [4]     I2C0         (1)
 90     // 0x00000008 [3]     HSTX         (1)
RP2350 Datasheet
7.5. Subsystem resets 503
 91     // 0x00000004 [2]     DMA          (1)
 92     // 0x00000002 [1]     BUSCTRL      (1)
 93     // 0x00000001 [0]     ADC          (1)
 94     io_rw_32  reset;
 95 
 96     _REG_(RESETS_WDSEL_OFFSET ) // RESETS_WDSEL
 97     // 0x10000000 [28]    USBCTRL      (0)
 98     // 0x08000000 [27]    UART1        (0)
 99     // 0x04000000 [26]    UART0        (0)
100     // 0x02000000 [25]    TRNG         (0)
101     // 0x01000000 [24]    TIMER1       (0)
102     // 0x00800000 [23]    TIMER0       (0)
103     // 0x00400000 [22]    TBMAN        (0)
104     // 0x00200000 [21]    SYSINFO      (0)
105     // 0x00100000 [20]    SYSCFG       (0)
106     // 0x00080000 [19]    SPI1         (0)
107     // 0x00040000 [18]    SPI0         (0)
108     // 0x00020000 [17]    SHA256       (0)
109     // 0x00010000 [16]    PWM          (0)
110     // 0x00008000 [15]    PLL_USB      (0)
111     // 0x00004000 [14]    PLL_SYS      (0)
112     // 0x00002000 [13]    PIO2         (0)
113     // 0x00001000 [12]    PIO1         (0)
114     // 0x00000800 [11]    PIO0         (0)
115     // 0x00000400 [10]    PADS_QSPI    (0)
116     // 0x00000200 [9]     PADS_BANK0   (0)
117     // 0x00000100 [8]     JTAG         (0)
118     // 0x00000080 [7]     IO_QSPI      (0)
119     // 0x00000040 [6]     IO_BANK0     (0)
120     // 0x00000020 [5]     I2C1         (0)
121     // 0x00000010 [4]     I2C0         (0)
122     // 0x00000008 [3]     HSTX         (0)
123     // 0x00000004 [2]     DMA          (0)
124     // 0x00000002 [1]     BUSCTRL      (0)
125     // 0x00000001 [0]     ADC          (0)
126     io_rw_32  wdsel;
127 
128     _REG_(RESETS_RESET_DONE_OFFSET ) // RESETS_RESET_DONE
129     // 0x10000000 [28]    USBCTRL      (0)
130     // 0x08000000 [27]    UART1        (0)
131     // 0x04000000 [26]    UART0        (0)
132     // 0x02000000 [25]    TRNG         (0)
133     // 0x01000000 [24]    TIMER1       (0)
134     // 0x00800000 [23]    TIMER0       (0)
135     // 0x00400000 [22]    TBMAN        (0)
136     // 0x00200000 [21]    SYSINFO      (0)
137     // 0x00100000 [20]    SYSCFG       (0)
138     // 0x00080000 [19]    SPI1         (0)
139     // 0x00040000 [18]    SPI0         (0)
140     // 0x00020000 [17]    SHA256       (0)
141     // 0x00010000 [16]    PWM          (0)
142     // 0x00008000 [15]    PLL_USB      (0)
143     // 0x00004000 [14]    PLL_SYS      (0)
144     // 0x00002000 [13]    PIO2         (0)
145     // 0x00001000 [12]    PIO1         (0)
146     // 0x00000800 [11]    PIO0         (0)
147     // 0x00000400 [10]    PADS_QSPI    (0)
148     // 0x00000200 [9]     PADS_BANK0   (0)
149     // 0x00000100 [8]     JTAG         (0)
150     // 0x00000080 [7]     IO_QSPI      (0)
151     // 0x00000040 [6]     IO_BANK0     (0)
152     // 0x00000020 [5]     I2C1         (0)
153     // 0x00000010 [4]     I2C0         (0)
154     // 0x00000008 [3]     HSTX         (0)
RP2350 Datasheet
7.5. Subsystem resets 504
155     // 0x00000004 [2]     DMA          (0)
156     // 0x00000002 [1]     BUSCTRL      (0)
157     // 0x00000001 [0]     ADC          (0)
158     io_ro_32  reset_done ;
159 } resets_hw_t ;
This struct defines the following registers:
•reset: This register contains a bit for each component that can be reset. When set to 1, the reset is asserted. If the
bit is cleared, the reset is deasserted.
•wdsel: This register contains a bit for each component that can be reset. When set to 1, this component will reset if
the watchdog fires. If you reset the power-on state machine, the entire reset controller will reset, which includes
every component.
•reset_done : This register contains a bit for each component that is automatically set when the component is out of
reset. This allows software to wait for this status bit in case the component requires initialisation before use.
The SDK defines reset functions as follows:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_resets/include/hardware/resets.h  Lines 159 - 161
159 static __force_inline  void reset_block (uint32_t  bits) {
160     reset_block_mask (bits);
161 }
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_resets/include/hardware/resets.h  Lines 163 - 165
163 static __force_inline  void unreset_block (uint32_t  bits) {
164     unreset_block_mask (bits);
165 }
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_resets/include/hardware/resets.h  Lines 167 - 169
167 static __force_inline  void unreset_block_wait (uint32_t  bits) {
168     return unreset_block_mask_wait_blocking (bits);
169 }
One example use of reset functions is the UART driver, which defines a uart_reset  function that selects a different bit of
the reset register depending on the UART specified:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_uart/uart.c  Lines 32 - 38
32 static inline void uart_reset (uart_inst_t  *uart) {
33     reset_block_num (uart_get_reset_num (uart));
34 }
35 
36 static inline void uart_unreset (uart_inst_t  *uart) {
37     unreset_block_num_wait_blocking (uart_get_reset_num (uart));
38 }
7.5.3. List of Registers
The reset controller registers start at a base address of 0x40020000  (defined as RESETS_BASE  in SDK).
RP2350 Datasheet
7.5. Subsystem resets 505
Table 534. List of
RESETS registersOffset Name Info
0x0 RESET
0x4 WDSEL
0x8 RESET_DONE
RESETS : RESET Register
Offset : 0x0
Table 535. RESET
RegisterBits Description Type Reset
31:29 Reserved. - -
28 USBCTRL RW 0x1
27 UART1 RW 0x1
26 UART0 RW 0x1
25 TRNG RW 0x1
24 TIMER1 RW 0x1
23 TIMER0 RW 0x1
22 TBMAN RW 0x1
21 SYSINFO RW 0x1
20 SYSCFG RW 0x1
19 SPI1 RW 0x1
18 SPI0 RW 0x1
17 SHA256 RW 0x1
16 PWM RW 0x1
15 PLL_USB RW 0x1
14 PLL_SYS RW 0x1
13 PIO2 RW 0x1
12 PIO1 RW 0x1
11 PIO0 RW 0x1
10 PADS_QSPI RW 0x1
9 PADS_BANK0 RW 0x1
8 JTAG RW 0x1
7 IO_QSPI RW 0x1
6 IO_BANK0 RW 0x1
5 I2C1 RW 0x1
4 I2C0 RW 0x1
3 HSTX RW 0x1
2 DMA RW 0x1
1 BUSCTRL RW 0x1
RP2350 Datasheet
7.5. Subsystem resets 506
Bits Description Type Reset
0 ADC RW 0x1
RESETS : WDSEL Register
Offset : 0x4
Table 536. WDSEL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 USBCTRL RW 0x0
27 UART1 RW 0x0
26 UART0 RW 0x0
25 TRNG RW 0x0
24 TIMER1 RW 0x0
23 TIMER0 RW 0x0
22 TBMAN RW 0x0
21 SYSINFO RW 0x0
20 SYSCFG RW 0x0
19 SPI1 RW 0x0
18 SPI0 RW 0x0
17 SHA256 RW 0x0
16 PWM RW 0x0
15 PLL_USB RW 0x0
14 PLL_SYS RW 0x0
13 PIO2 RW 0x0
12 PIO1 RW 0x0
11 PIO0 RW 0x0
10 PADS_QSPI RW 0x0
9 PADS_BANK0 RW 0x0
8 JTAG RW 0x0
7 IO_QSPI RW 0x0
6 IO_BANK0 RW 0x0
5 I2C1 RW 0x0
4 I2C0 RW 0x0
3 HSTX RW 0x0
2 DMA RW 0x0
1 BUSCTRL RW 0x0
0 ADC RW 0x0
RESETS : RESET_DONE Register
RP2350 Datasheet
7.5. Subsystem resets 507
Offset : 0x8
Table 537.
RESET_DONE RegisterBits Description Type Reset
31:29 Reserved. - -
28 USBCTRL RO 0x0
27 UART1 RO 0x0
26 UART0 RO 0x0
25 TRNG RO 0x0
24 TIMER1 RO 0x0
23 TIMER0 RO 0x0
22 TBMAN RO 0x0
21 SYSINFO RO 0x0
20 SYSCFG RO 0x0
19 SPI1 RO 0x0
18 SPI0 RO 0x0
17 SHA256 RO 0x0
16 PWM RO 0x0
15 PLL_USB RO 0x0
14 PLL_SYS RO 0x0
13 PIO2 RO 0x0
12 PIO1 RO 0x0
11 PIO0 RO 0x0
10 PADS_QSPI RO 0x0
9 PADS_BANK0 RO 0x0
8 JTAG RO 0x0
7 IO_QSPI RO 0x0
6 IO_BANK0 RO 0x0
5 I2C1 RO 0x0
4 I2C0 RO 0x0
3 HSTX RO 0x0
2 DMA RO 0x0
1 BUSCTRL RO 0x0
0 ADC RO 0x0
7.6. Power-on resets and brownout detection
RP2350 Datasheet
7.6. Power-on resets and brownout detection 508
7.6.1. Power-on reset (POR)
The power-on reset block ensures the chip starts up cleanly when power is first applied. It accomplishes this by holding
the chip in reset until the digital core supply ( DVDD) reaches a voltage high enough to reliably power the chip’s core logic.
The block holds its por_n output low until DVDD exceeds the power-on reset threshold  (DVDD TH.POR ) for a period greater
than the power-on reset assertion delay  (tPOR.ASSERT ). Once high, por_n remains high even if DVDD subsequently falls below
DVDD TH.POR . The behaviour of por_n when power is applied is shown in Figure 28, “A power-on reset cycle” .
DVDD
por_nDVDD TH.POR
tPOR.ASSERTFigure 28. A power-on
reset cycle
DVDD TH.POR  is fixed at a nominal 0.957V, which should result in a threshold between 0.924V and 0.99V. The threshold
assumes a nominal DVDD of 1.1V at initial power-on, and por_n may never go high if a lower voltage is used. Once the chip
is out of reset, DVDD can be reduced without por_n going low.
7.6.1.1. Detailed specifications
Table 538. Power-on
Reset ParametersParameter Description Min Typ Max Units
DVDD TH.POR power-on reset
threshold0.924 0.957 0.99 V
tPOR.ASSERT power-on reset
assertion delay3 10 μs
7.6.2. Brownout detection (BOD)
The brownout detection block prevents unreliable operation when the digital core supply ( DVDD) drops below a safe
operating level. If enabled, the block resets the chip by taking its bor_n output low when DVDD drops below the brownout
detection assertion threshold  (DVDD TH.BOD.ASSERT ) for a period greater than the brownout detection assertion delay 
(tBOD.ASSERT ). If DVDD subsequently rises above the brownout detection de-assertion threshold  (DVDD TH.BOD.DEASSERT ) for a
period greater than the brownout detection de-assertion delay  (tBOD.DEASSERT ), the block releases reset by taking bor_n
high. A brownout, followed by supply recovery, is shown in Figure 29, “A brownout detection cycle” .
RP2350 Datasheet
7.6. Power-on resets and brownout detection 509
Figure 29. A brownout
detection cycle
7.6.2.1. Detection enable
Brownout detection is always enabled at initial power-on. There is, however, a short delay, the brownout detection
activation delay  (tBOD.ACTIVE ), between por_n going high and detection becoming active. This is shown in Figure 30,
“Activation of brownout detection at initial power-on and following a brownout event.” .
Figure 30. Activation
of brownout detection
at initial power-on and
following a brownout
event.
Once the chip is out of reset, detection can be disabled under software control. This saves a small amount of power. If
detection is subsequently re-enabled, there will be another short delay, the brownout detection enable delay  (tBOD.ENABLE ),
before it becomes active again. This is shown in Figure 31, “Disabling and enabling brownout detection” .
Detection is disabled by writing a 0 to the EN field in the BOD register and is re-enabled by writing a 1 to the same field. The
block’s bod_n output is high when detection is disabled.
EN
tBOD.ENABLE
detection inactive1 0 1
detection inactivedetection activeFigure 31. Disabling
and enabling brownout
detection
Detection is re-enabled if the BOD register is reset, as this sets the register’s EN field to 1. Again, detection will become
RP2350 Datasheet
7.6. Power-on resets and brownout detection 510
active after a delay equal to the brownout detection enable delay (t BOD.ENABLE ).
NOTE
If the BOD register is reset by a power-on or brownout-initiated reset, the delay between the register being reset and
brownout detection becoming active will be equal to the brownout detection activation delay (t BOD.ACTIVE ). The delay
will be equal to the brownout detection enable delay (t BOD.ENABLE ) for all other reset sources.
7.6.2.2. Adjusting the detection threshold
The brownout detection threshold  (DVDD TH.BOD ) has a nominal value of 0.946V at initial power-on or after a reset event.
This should result in a detection threshold between 0.913V and 0.979V. Once out of reset, the threshold can be adjusted
under software control. The new detection threshold will take effect after the brownout detection programming delay 
((tBOD.PROG ). An example of this is shown in Figure 32, “Adjusting the brownout detection threshold” .
The threshold is adjusted by writing to the VSEL field in the BOD register. See the BOD register description for details.
NOTE
The nominal supply voltage for DVDD is 1.1 V. You should not increase the brownout detection threshold above the
nominal supply voltage.
VSEL
tBOD.PROG
threshold 0.86V1001 0111
threshold 0.774VFigure 32. Adjusting
the brownout
detection threshold
7.6.2.3. Detailed specifications
Table 539. Brownout
Detection ParametersParameter Description Min Typ Max Units
DVDD TH.BOD.ASSERT brownout
detection
assertion
threshold96.5 100 103.5 % of selected
threshold voltage
DVDD TH.BOD.DEASSERT brownout
detection de-
assertion
threshold97.4 101 105 % of selected
threshold voltage
tBOD.ACTIVE brownout
detection
activation delay55 80 μs
tBOD.ASSERT brownout
detection
assertion delay3 10 μs
RP2350 Datasheet
7.6. Power-on resets and brownout detection 511
Parameter Description Min Typ Max Units
tBOD.DEASSERT brownout
detection de-
assertion delay55 80 μs
tBOD.ENABLE brownout
detection enable
delay35 55 μs
tBOD.PROG brownout
detection
programming
delay20 30 μs
7.6.3. Supply monitor
The power-on and brownout reset blocks are powered by the core voltage regulator’s analogue supply ( VREG_AVDD ). The
blocks are initialised when power is first applied, but may not be reliably re-initialised if power is removed and then
reapplied before VREG_AVDD  has dropped to a sufficiently low level. To prevent this happening, VREG_AVDD  is monitored and
the power-on reset block is re-initialised if it drops below the VREG_AVDD activation threshold  (VREG_AVDD TH.ACTIVE ).
VREG_AVDD TH.ACTIVE  is fixed at a nominal 1.1V, which should result in a threshold between 0.87V and 1.26V. This
threshold does not represent a safe operating voltage. Instead, it represents the voltage that VREG_AVD  must drop below
to reliably re-initialise the power-on reset block. For safe operation, VREG_AVDD  must be at a nominal voltage of 3.3V. See
Table 1441, “Power Supply Specifications” .
7.6.3.1. Detailed specifications
Table 540. Voltage
Regulator Input Supply
Monitor ParametersParameter Description Min Typ Max Units
VREG_VIN TH.ACTIVE VREG_VIN  activation
threshold0.87 1.1 1.26 V
7.6.4. List of registers
The chip-level reset subsystem shares a register address space with other power management subsystems in the
always-on domain. The address space is referred to as POWMAN elsewhere in this document. A complete list of POWMAN
registers is provided in Section 6.4, “Power management (POWMAN) registers” , but information on registers associated
with the brownout detector are repeated here.
The POWMAN registers start at a base address of 0x40100000  (defined as POWMAN_BASE  in SDK).
•BOD_CTRL
•BOD
•BOD_LP_ENTRY
•BOD_LP_EXIT
RP2350 Datasheet
7.6. Power-on resets and brownout detection 512
Chapter 8. Clocks
8.1. Overview
The clocks block provides independent clocks to on-chip and external components. It takes inputs from a variety of
clock sources, allowing the user to trade off performance against cost, board area and power consumption. From these
sources it uses multiple clock generators to provide the required clocks. This architecture allows the user flexibility to
start and stop clocks independently and to vary some clock frequencies whilst maintaining others at their optimum
frequencies.
GPCLK0 - 1 
from 
GPIO MuxingExternal 
clocks or 
Relaxation 
oscillators
External 
clocksClock sourcesclk_gpout0-3
clk_adc
clk_usb
clk_hstx
clk_peri
clk_sys
clk_ref
switched-core power domain
always-on power domain÷÷ en
÷ en
÷ en
÷ en
÷ enUSB PLL
System PLL
Crystal Oscillator 
(XOSC)
Ring Oscillator 
(ROSC)
Low Power 
Oscillator 
(LPOSC)÷
Frequency counter
Resus
ClocksGPIO Muxing
ADC
USB
HSTX
UART+SPI
Processors, Bus fabric, 
Memories & 
Memory -mapped registers
Watchdog & Timers
OTP
tick ÷ AON Timer
clk_powPower ManagerenFigure 33. Clocks
overview
The crystal oscillator (XOSC) provides a reference to two PLLs, which provide high precision clocks to the processors
and peripherals. These are slow to start when waking from the various low-power modes, so the on-chip ring oscillator
(ROSC) is provided to boot the device until they are available. When the switched-core is powered down or the device is
in DORMANT mode (see Section 6.5.3, “DORMANT state” ) the on-chip 32kHz low-power oscillator (LPOSC) provides a
clock to the power manager and a tick to the Always-on Timer (AON Timer).
RP2350 Datasheet
8.1. Overview 513
The clock generators select from the clock sources and optionally divide the selected clock before outputting through
enable logic that provides automatic clock gating in sleep mode (see Section 8.1.3.5.2, “System sleep mode” ).
An on-chip frequency counter facilitates debugging of the clock setup and also allows measurement of the frequencies
of LPOSC, ROSC and external clocks. If the system clock stops accidentally, the on-chip resus  (short for resuscitate )
component restarts it from a known good clock. This allows the software debugger to access registers and debug the
problem.
When the switched-core is powered, the power manager clock automatically switches to the reference clock ( clk_ref).
The user can optionally switch the AON Timer tick, though we recommend waiting until clk_ref is running from the
XOSC, because the ROSC frequency is imprecise.
You can substitute the clock sources with up to 2 GPIO clock inputs. This helps avoid adding a second crystal into
systems that already have an accurate clock source and enables replacement of the ROSC and LPOSC with more
accurate external sources.
You can also output up to 4 generated clocks to GPIOs at up to 50MHz. This enables you to supply clocks to external
devices, reducing the need for additional clock components that consume power and board area.
8.1.1. Changes between RP2350 revisions
RP2350 A3 changes the reset values of:
•CLK_SYS_CTRL .SRC from 0 to 1 (select AUX source).
•CLK_SYS_CTRL .AUXSRC from 0 to 2 (select ROSC as AUX source).
See Hardware changes  for information about related changes made to the ROSC configuration at reset. See Bootrom
changes  for related changes made in the A3 boot ROM.
8.1.2. Clock sources
RP2350 can use a variety of clock sources. This flexibility allows the user to optimise the clock setup for performance,
cost, board area and power consumption. RP2350 supports the following potential clock sources:
•On-chip 32kHz low-power oscillator ( Section 8.4, “Low Power oscillator (LPOSC)” )
•On-chip ring oscillator ( Section 8.3, “Ring oscillator (ROSC)” )
•Crystal oscillator ( Section 8.2, “Crystal oscillator (XOSC)” )
•External clocks from GPIOs ( Section 8.1.6.4, “Configuring a GPIO input clock” ) and PLLs ( Section 8.6, “PLL” )
The list of clock sources is different per clock generator and can be found as enumerated values in the CTRL register.
See CLK_SYS_CTRL  as an example.
8.1.2.1. Low-power oscillator
The on-chip 32kHz low-power oscillator ( Section 8.4, “Low Power oscillator (LPOSC)” ) requires no external components.
It starts automatically when the always-on domain is powered, providing a clock for the power manager and a tick for
the Always-on Timer (AON Timer) when the switched-core power domain is powered off.
The LPOSC can be tuned to 1% accuracy, and the divider in the AON Timer tick generator can further tune the 1ms tick.
However, the LPOSC frequency varies with voltage and temperature, so fine-tuning is only useful in systems with stable
voltage and temperature.
When the switched-core is powered, the LPOSC clock can drive the reference clock ( clk_ref), which in turn can drive the
system clock ( clk_sys). This allows another low-power mode where the processors remain powered but, unlike the
SLEEP and DORMANT modes, clocks are running. The LPOSC clock can also be sent to the frequency counter for
calibration or output to a GPIO.
RP2350 Datasheet
8.1. Overview 514
8.1.2.2. Ring oscillator
The on-chip ring oscillator ( Section 8.3, “Ring oscillator (ROSC)” ) requires no external components. It starts
automatically when the switched-core domain is powered and is used to clock the chip during the initial boot stages.
During boot, the ROSC runs at a nominal 11MHz, but varies with PVT (Process, Voltage, and Temperature). The ROSC
frequency is guaranteed to be in the range 4.6MHz to 19.6MHz.
For low-cost applications where frequency accuracy is unimportant, the chip can continue to run from the ROSC. If your
application requires greater performance, the frequency can be increased by programming the registers as described in
Section 8.3, “Ring oscillator (ROSC)” . Because the frequency varies with PVT (Process, Voltage, and Temperature), the
user must take care to avoid exceeding the maximum frequencies described in the clock generators section. For
information about reducing this variation when running the ROSC at frequencies close to the maximum, see Section
8.1.2.2.1, “Mitigate ROSC frequency variation due to process” . Alternatively, use an external clock or the XOSC to
provide a stable reference clock and use the PLLs to generate higher frequencies. However, this approach requires
external components, which will cost board area and increase power consumption.
When using an external clock or the XOSC, you can stop the ROSC to save power. Before stopping the ROSC, you must
switch the reference clock generator and the system clock generator to an alternate source.
The ROSC is unpowered when the switched-core domain is powered down, but starts immediately when the switched-
core powers up. It is not affected by sleep mode. To save power, reduce the frequency before entering sleep mode.
When entering DORMANT mode, the ROSC is automatically stopped. When exiting DORMANT mode, the ROSC restarts
in the same configuration. If you drive clocks at close to their maximum frequencies with the ROSC, drop the frequency
before entering SLEEP or DORMANT mode. This allows for frequency variation due to changes in environmental
conditions during SLEEP or DORMANT mode.
To use ROSC clock externally, output it to a GPIO pin using one of the clk_gpclk0-3  generators.
The following sections describe techniques for mitigating PVT variation of the ROSC frequency. They also provide some
interesting design challenges for use in teaching both the effects of PVT and writing software to control real time
functions.
TIP
Because the ROSC frequency varies with PVT (Process, Voltage, and Temperature), you can use the ROSC frequency
to measure any one of the three PVT variables as long as you know the other two variables.
8.1.2.2.1. Mitigate ROSC frequency variation due to process
Process varies for the following reasons:
•Chips leave the factory with a spread of process parameters. This causes variation in the ROSC frequency across
chips.
•Process parameters vary slightly as the chip ages. This is only observable over many thousands of hours of
operation.
To mitigate process variation, the user can characterise individual chips and program the ROSC frequency accordingly.
This is an adequate solution for small numbers of chips, but does not scale well to volume production. For high-volume
applications, consider using automatic mitigation .
8.1.2.2.2. Mitigate ROSC frequency variation due to voltage
Supply voltage varies for the following reasons:
•The power supply itself can vary.
•As chip activity varies, on-chip IR varies.
To mitigate voltage variation, calibrate for the minimum performance target of your application, then adjust the ROSC
RP2350 Datasheet
8.1. Overview 515
frequency to always exceed that minimum.
8.1.2.2.3. Mitigate ROSC frequency variation due to temperature
Temperature varies for the following reasons:
•The ambient temperature can vary.
•The chip temperature varies as chip activity varies due to self-heating.
To mitigate temperature variations, stabilise the temperature. You can use a temperature controlled environment,
passive cooling, or active cooling. Alternatively, track the temperature using the on-chip temperature sensor and adjust
the ROSC frequency so it remains within the required bounds.
8.1.2.2.4. Automatic mitigation of ROSC frequency variation due to PVT
Techniques for automatic ROSC frequency control avoid the need to calibrate individual chips, but require periodic
access to a clock reference or to a time reference.
If a clock reference is available, you can use it to periodically measure the ROSC frequency and adjust accordingly. The
on-chip XOSC is one potential clock reference. You can even run the XOSC intermittently to save power for very low-
power application where it is too costly to run the XOSC continuously or use the PLLs to achieve high frequencies.
If a time reference is available, you can clock the on-chip AON Timer from the ROSC and periodically compare it against
the time reference, adjusting the ROSC frequency as necessary. Using these techniques, the ROSC frequency still drifts
due to voltage and temperature variation. As a result, you should also implement mitigations for voltage and
temperature to ensure that variations do not allow the ROSC frequency to drift out of the acceptable range.
8.1.2.2.5. Automatic overclocking using the ROSC
The datasheet maximum frequencies for any digital device are quoted for worst case PVT. Most chips in most normal
environments can run significantly faster than the quoted maximum, and therefore support overclocking. When RP2350
runs from the ROSC, PVT affects both both the ROSC and the digital components. As the ROSC gets faster, the
processors can also run faster. This means the user can overclock from the ROSC, then rely on the ROSC frequency
tracking with PVT variations. The tracking of ROSC frequency and the processor capability is not perfect, and currently
there is insufficient data to specify a safe ROSC setting for this mode of operation, so some experimentation is
required.
This mode of operation maximises processor performance, but causes variations in the time taken to complete a task.
Only use overclocking for applications where this variation is acceptable. If your application uses frequency sensitive
interfaces such as USB or UART, you must use the XOSC and PLL to provide a precise clock for those components.
8.1.2.3. Crystal oscillator
The Crystal Oscillator ( Section 8.2, “Crystal oscillator (XOSC)” ) provides a precise, stable clock reference and should be
used where accurate timing is required and no suitable external clocks are available. The XOSC requires an external
crystal component. The external crystal determines the frequency. RP2350 supports 1MHz to 50MHz crystals and the
RP2350 reference design (see Hardware design with RP2350 , Minimal Design Example ) uses a 12MHz crystal. Using
the XOSC and the PLLs, you can run on-chip components at their maximum frequencies. Appropriate margin is built into
the design to tolerate up to 1000ppm variation in the XOSC frequency.
The XOSC is unpowered when the switched-core domain is powered down. It remains inactive when the switched-core
is powered up. If required, you must enable it in software. XOSC startup takes several milliseconds, and software must
wait for the XOSC_STABLE  flag to be set before starting the PLLs and changing any clock generators. Before the XOSC
completes startup, output might be non-existent or exhibit very short pulse widths; this will corrupt logic if used. When
XOSC startup is complete, the reference clock ( clk_ref) and the system clock ( clk_sys) can run from the XOSC. If you
RP2350 Datasheet
8.1. Overview 516
switch the system and reference clocks to run from the XOSC, you can stop the ROSC to save power.
The XOSC is not affected by sleep mode. It automatically stops and restarts in the same configuration when entering
and exiting DORMANT mode.
To use the XOSC clock externally, output it to a GPIO pin using one of the clk_gpclk0 -clk_gpclk03  generators. You cannot
take XOSC output directly from the XIN (XI) or XOUT (XO) pins.
8.1.2.4. External clocks
If external clocks exist in the hardware design, you can use them to clock RP2350. You can use clocks individually or in
conjunction with the other (internal or external) clock sources. Use XIN and one of GPIN0-GPIN1 to input external
clocks.
If you drive an external clock into XIN, you don’t need an external crystal. When driving an external clock into XIN, you
must configure the XOSC to pass through the XIN signal. When the switched-core powers down, this configuration will
be lost, but the configuration is unaffected by SLEEP and DORMANT modes. The input is limited to 50MHz, but the on-
chip PLLs can synthesise higher frequencies from the XIN input if required.
GPIN0-GPIN1 can provide system and peripherals clocks, but is limited to 50MHz. This can potentially save power and
allows components on RP2350 to run synchronously with external components, which simplifies data transfer between
chips. If the frequency accuracy of the external clocks is poorer than 1000ppm, the generated clocks should not run at
their maximum frequencies since they could exceed their design margins. Once the external clocks begin to run, the
reference clock ( clk_ref) and the system clock ( clk_sys) can run from the external clocks and you can stop the ROSC to
save power. When the switched-core powers down, GPIN0-GPIN1 configuration will be lost, but the configuration is
unaffected by SLEEP and DORMANT modes.
To provide a more accurate tick to the AON Timer, use one of the GPIN0-GPIN3 inputs to replace the clock from the
LPOSC. These inputs are limited to 29MHz. GPIN0-GPIN3 configuration is unaffected by switched-core power down,
sleep mode, and DORMANT mode.
8.1.2.5. Relaxation oscillators
If there is no appropriate clock available, but you still want to replace or supplement external clocks with another clock
source, you can construct one or two relaxation oscillators from external passive components. Send the clock source
(GPIN0-GPIN1) to one of the clk_gpclk0 -clk_gpclk03  generators, invert it through the GPIO inverter OUTOVER, and connect
back to the clock source input via an RC circuit:
Figure 34. Simple
relaxation oscillator
example
The frequency of clocks generated from relaxation oscillators depend on the delay through the chip and the drive
current from the GPIO output, both of which vary with PVT. The frequency and frequency accuracy depend on the
quality and accuracy of the external components. More elaborate external components such as ceramic resonators, can
improve performance, but also increase cost and complexity. Such an oscillator will not achieve 1000ppm, so they
cannot drive internal clocks at their maximum frequencies. To drive internal clocks at the maximum possible frequency,
use the XOSC.
The configuration of the relaxation oscillators will be lost when the switched-core powers down, but is not affected by
sleep mode or DORMANT mode.
RP2350 Datasheet
8.1. Overview 517
8.1.2.6. PLLs
The PLLs ( Section 8.6, “PLL” ) are used to provide fast clocks when running from the XOSC or an external clock source
driven into the XIN pin. In a fully-featured application, the USB PLL provides a fixed 48MHz clock to the ADC and USB
while clk_ref is driven from the XOSC or external clock source. This allows the user to drive clk_sys from the system PLL
and vary the frequency according to demand to save power without having to change the setups of the other clocks.
clk_peri  can be driven either from the fixed frequency USB PLL or from the variable frequency system PLL. If clk_sys
never needs to exceed 48MHz, one PLL can be used and the divider in the clk_sys clock generator can scale the clk_sys
frequency according to demand.
When a PLL starts, you cannot use the output until the PLL locks as indicated by the LOCK bit in the STATUS register. As a
result, the PLL output cannot be used during changes to the reference clock divider, the output dividers or the bypass
mode. The output can be used during feedback divisor changes, though the output frequency might overshoot or
undershoot during large changes to the feedback divisor. For more information, see Section 8.6, “PLL” .
The PLLs can drive clocks at their maximum frequency as long as the reference clock is accurate to 1000ppm, since
this keeps the frequency of the generated clocks within design margins.
The PLLs are not affected by sleep mode. To save power in sleep mode, switch all clock generators away from the PLLs
stop them in software before entering sleep mode.
The PLLs do not stop and restart automatically when entering and exiting DORMANT mode. If the PLLs are running
when entering DORMANT mode, they will be corrupted because the reference clock in the XOSC stops. This generates
out-of-control clocks that consume power unnecessarily. Before entering DORMANT mode, always switch all clock
generators away from the PLLs and stop the PLLs in software.
8.1.3. Clock generators
The clock generators are built on a standard design that incorporates clock source multiplexing, division, duty cycle
correction, and sleep mode enabling. To save chip area and power, some individual clock generators omit certain
features.
Figure 35. A generic
clock generator
8.1.3.1. Instances
RP2350 has several clock generators, which are listed below.
Table 541. RP2350
clock generatorsClock Description Nominal Frequency
clk_gpout0 Clock output to GPIO. Can be used to
clock external devices or debug on
chip clocks with a logic analyser or
oscilloscope.N/A
clk_gpout1
clk_gpout2
clk_gpout3
clk_ref Reference clock that is always running
unless in DORMANT mode. Runs from
ring oscillator (ROSC) at power-up but
can be switched to crystal oscillator
(XOSC) for more accuracy.6 - 12MHz
RP2350 Datasheet
8.1. Overview 518
Clock Description Nominal Frequency
clk_sys System clock that is always running
unless in DORMANT mode. Runs from
clk_ref at power-up, but is typically
switched to a PLL.150MHz
clk_peri Peripheral clock. Typically runs from
clk_sys but allows peripherals to run at
a consistent speed if clk_sys is
changed by software.12 - 150MHz
clk_usb USB reference clock. Must be 48MHz. 48MHz
clk_adc ADC reference clock. Must be 48MHz. 48MHz
clk_hstx HSTX clock. 150MHz
For a full list of clock sources for each clock generator, see the appropriate CTRL register. For example, CLK_SYS_CTRL .
8.1.3.2. Multiplexers
All clock generators have a multiplexer referred to as the auxiliary (aux) mux. This mux has a conventional design
whose output will glitch when changing the select control. The reference clock ( clk_ref) and the system clock ( clk_sys)
have an additional multiplexer referred to as the glitchless mux . The glitchless mux can switch between clock sources
without generating a glitch on the output.
Before switching the clock source of an auxiliary mux you must either:
•Temporarily switch the glitchless mux away from aux (if a glitchless mux is available).
•Temporarily disable the clock generator using its CTRL_ENABLE  bit.
•Hold the destination in reset so that a potential clock glitch doesn’t cause undefined operation.
Failure to do at least one of the above can cause a glitch on the clock input of all hardware currently clocked by this
clock generator. Avoid clock glitches at all costs; they can corrupt the logic running from the clock.
Clock generators require two cycles of the source clock to stop the output and two cycles of the new source to restart
the output. Wait for the generator to stop before changing the auxiliary mux. When the destination clock is much slower
than the system clock, there is a danger that software changes the aux mux source before the clock generator has
come to a safe halt. Avoid this by polling the clock generator’s CTRL_ENABLED  status until it matches the value of
CTRL_ENABLE .
The glitchless mux is only implemented for always-on clocks. On RP2350, the always-on clocks are the reference clock
(clk_ref) and the system clock ( clk_sys). Such clocks must run continuously unless the chip is in DORMANT mode. The
glitchless mux has a status output ( SELECTED ) that indicates which source is selected. You can read this status output
from software to confirm that a change of clock source has completed.
The recommended control sequences are as follows.
To switch between clock sources for the glitchless mux:
1.Switch the glitchless mux to an alternate source.
2.Poll the SELECTED  register until the switch completes.
To switch between clock sources for the aux mux when the generator has a glitchless mux:
1.Switch the glitchless mux to a source that isn’t the aux mux.
2.Poll the SELECTED  register until the switch completes.
3.Change the auxiliary mux select control.
RP2350 Datasheet
8.1. Overview 519
4.Switch the glitchless mux back to the aux mux.
5.If required, poll the SELECTED  register until the switch completes.
To switch between clock sources for the aux mux when the generator does not have a glitchless mux:
1.Disable the clock divider.
2.Wait for the generated clock to stop (two cycles of the clock source).
3.Change the auxiliary mux select control.
4.Enable the clock divider.
5.If required, wait for the clock generator to restart (two cycles of the clock source).
See Section 8.1.6.1, “Configuring a clock generator”  for a code example of this.
8.1.3.3. Divider
A fully featured divider divides by a fractional number in the range 1.0 to 216. Fractional division is achieved by toggling
between 2 integer divisors; this yields a jittery clock that might be unsuitable for some applications. For example, when
dividing by 2.4, the divider divides by 2 for 3 cycles and by 3 for 2 cycles. For divisors with large integer components, the
jitter will be much smaller and less critical.
Figure 36. An example
of fractional division.
All dividers support on-the-fly divisor changes : the output clock can switch cleanly from one divisor to another. The
clock generator does not need to be stopped during clock divisor changes, because the dividers synchronise the divisor
change to the end of the clock cycle. Similarly, dividers synchronise the enable to the end of the clock cycle to avoid
glitches when the clock generator is enabled or disabled. Clock generators for always-on clocks are permanently
enabled and therefore do not have an enable control.
In the event that a clock generator locks up and never completes the current clock cycle, it can be forced to stop using
the KILL control. This can result in an output glitch, which can corrupt the logic driven by the clock. Always reset the
destination logic before using the KILL control. Clock generators for always-on clocks are permanently active and
therefore do not have a KILL control.
NOTE
This clock generator design has been used in numerous chips and has never been known to lock up. The KILL control
is inelegant and unnecessary and should not be used as an alternative to the enable.
8.1.3.4. Duty cycle correction
The divider operates on the rising edge of the input clock, so it does not generate an even duty cycle clock when dividing
by odd numbers. For example, divide by 3 gives a duty cycle of 33.3%, and divide by 5 gives a duty cycle of 40%.
If enabled, duty cycle correction logic will shift the falling edge of the output clock to the falling edge of the input clock
and restore a 50% duty cycle. The duty cycle correction can be enabled and disabled while the clock is running. It
doesn’t operate when dividing by an even number.
RP2350 Datasheet
8.1. Overview 520
Clock source
Generated clock without DCC
Generated clock with DCCFigure 37. An example
of
duty_cycle_correction.
8.1.3.5. Clock Enables
Each clock goes to multiple destinations. With a few exceptions, each destination has two enables. Use the WAKE_EN
registers to enable the clocks when the system is awake. Use the SLEEP_EN  registers to enable the clocks when the
system is in sleep mode. Enables help reduce power in the clock distribution networks for unused components. Any
component that isn’t clocked will retain its configuration so it can restart quickly.
NOTE
By default, the WAKE_EN and SLEEP_EN  registers reset to 0x1, which enables all clocks. Only use this feature for low-
power designs.
8.1.3.5.1. Clock enable exceptions
The following destinations don’t have clock enables:
•The clk_gpclk0 -clk_gpclk03  generators.
•The processor cores, because they require a clock at all times to manage their own power-saving features.
•clk_sys_busfabric  (in wake mode), because that would prevent the cores from accessing any chip registers,
including those that control the clock enables.
•clk_sys_clocks  (in wake mode), because that would prevent the cores from accessing the clocks control registers.
8.1.3.5.2. System sleep mode
System sleep mode is entered automatically when both cores are in sleep and the DMA has no outstanding
transactions. In system sleep mode, the clock enables described in the previous paragraphs are switched from the
WAKE_EN registers to the SLEEP_EN  registers. Sleep mode helps reduce power consumed in the clock distribution networks
when the chip is inactive. If the user hasn’t configured the WAKE_EN and SLEEP_EN  registers, system sleep does nothing.
There is little value in using system sleep without taking other measures to reduce power before the cores are put to
sleep. Things to consider include:
•Stop unused clock sources such as the PLLs and crystal oscillator.
•Reduce the frequencies of generated clocks by increasing the clock divisors.
•Stop external clocks.
For maximum power saving when the chip is inactive, the user should consider DORMANT (see Section 6.5.3,
“DORMANT state” ) mode in which clocks are sourced from the crystal oscillator and/or the ring oscillator and those
clock sources are stopped.
For more information about sleep, see Section 6.5.2, “SLEEP state” .
RP2350 Datasheet
8.1. Overview 521
8.1.4. Frequency counter
The frequency counter measures the frequency of internal and external clocks by counting the clock edges seen over a
test interval. The interval is defined by counting cycles of clk_ref, which must be driven either from XOSC or a stable
external source of known frequency.
The user can pick between accuracy and test time using the FC0_INTERVAL  register. Table 542, “Frequency Counter
Test Interval vs Accuracy”  shows this trade off:
Table 542. Frequency
Counter Test Interval
vs AccuracyInterval Register Test Interval Accuracy
0 1μs 2048kHz
1 2μs 1024kHz
2 4μs 512kHz
3 8μs 256kHz
4 16μs 128kHz
5 32μs 64kHz
6 64μs 32kHz
7 125μs 16kHz
8 250μs 8kHz
9 500μs 4kHz
10 1ms 2kHz
11 2ms 1kHz
12 4ms 500Hz
13 8ms 250Hz
14 16ms 125Hz
15 32ms 62.5Hz
8.1.5. Resus
It is possible to write software that inadvertently stops clk_sys. This normally causes an unrecoverable lock-up of the
cores and the on-chip debugger, leaving the user unable to trace the problem. To mitigate against unrecoverable core
lock-up, an automatic resuscitation circuit  is provided; this switches clk_sys to a known good clock source ( clk_ref) if it
detects no edges over a user-defined interval. clk_ref can be driven from the XOSC, ROSC or an external source. The
interval is programmable via CLK_SYS_RESUS_CTRL .
WARNING
There is no way for resus to revive the chip if clk_ref is also stopped.
To enable the resus:
•Set the timeout interval.
•Set the ENABLE bit in CLK_SYS_RESUS_CTRL .
To detect a resus event:
•Enable the CLK_SYS_RESUS  interrupt by setting the interrupt enable bit in INTE .
RP2350 Datasheet
8.1. Overview 522
•Enable the CLOCKS_DEFAULT_IRQ  processor interrupt (see Section 3.2, “Interrupts” ).
Resus is intended as a debugging aid, so the user can trace the software error that triggered the resus, then correct the
error and reboot. It is possible to continue running after a resus event by reconfiguring clk_sys, then clearing the resus
by writing the CLEAR bit in CLK_SYS_RESUS_CTRL .
WARNING
Only use resus for debugging. If clk_sys runs slower than expected, a resus could trigger. This could result in a
clk_sys glitch, which could corrupt the chip.
8.1.6. Programmer’s model
8.1.6.1. Configuring a clock generator
The SDK defines an enum of clocks:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2350/hardware_structs/include/hardware/structs/clocks.h  Lines 30 - 42
30 typedef enum clock_num_rp2350  {
31     clk_gpout0  = 0, ///< Select CLK_GPOUT0 as clock source
32     clk_gpout1  = 1, ///< Select CLK_GPOUT1 as clock source
33     clk_gpout2  = 2, ///< Select CLK_GPOUT2 as clock source
34     clk_gpout3  = 3, ///< Select CLK_GPOUT3 as clock source
35     clk_ref = 4, ///< Select CLK_REF as clock source
36     clk_sys = 5, ///< Select CLK_SYS as clock source
37     clk_peri  = 6, ///< Select CLK_PERI as clock source
38     clk_hstx  = 7, ///< Select CLK_HSTX as clock source
39     clk_usb = 8, ///< Select CLK_USB as clock source
40     clk_adc = 9, ///< Select CLK_ADC as clock source
41     CLK_COUNT
42 } clock_num_t ;
Additionally, the SDK defines a struct to describe the registers of a clock generator:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2350/hardware_structs/include/hardware/structs/clocks.h  Lines 116 - 137
116 typedef struct {
117     _REG_(CLOCKS_CLK_GPOUT0_CTRL_OFFSET ) // CLOCKS_CLK_GPOUT0_CTRL
118     // Clock control, can be changed on-the-fly (except for auxsrc)
119     // 0x10000000 [28]    ENABLED      (0) clock generator is enabled
120     // 0x00100000 [20]    NUDGE        (0) An edge on this signal shifts the phase of the
    output by...
121     // 0x00030000 [17:16] PHASE        (0x0) This delays the enable signal by up to 3 cycles
    of the...
122     // 0x00001000 [12]    DC50         (0) Enables duty cycle correction for odd divisors, can
    be...
123     // 0x00000800 [11]    ENABLE       (0) Starts and stops the clock generator cleanly
124     // 0x00000400 [10]    KILL         (0) Asynchronously kills the clock generator, enable
    must be...
125     // 0x000001e0 [8:5]   AUXSRC       (0x0) Selects the auxiliary clock source, will glitch
    when switching
126     io_rw_32  ctrl;
127 
128     _REG_(CLOCKS_CLK_GPOUT0_DIV_OFFSET ) // CLOCKS_CLK_GPOUT0_DIV
129     // 0xffff0000 [31:16] INT          (0x0001) Integer part of clock divisor, 0 -> max+1, can
    be...
130     // 0x0000ffff [15:0]  FRAC         (0x0000) Fractional component of the divisor, can be
RP2350 Datasheet
8.1. Overview 523
    changed on-the-fly
131     io_rw_32  div;
132 
133     _REG_(CLOCKS_CLK_GPOUT0_SELECTED_OFFSET ) // CLOCKS_CLK_GPOUT0_SELECTED
134     // Indicates which src is currently selected (one-hot)
135     // 0x00000001 [0]     CLK_GPOUT0_SELECTED (1) This slice does not have a glitchless mux
(only the...
136     io_ro_32  selected ;
137 } clock_hw_t ;
Clock configuration requires the following pieces of information:
•The frequency of the clock source
•The mux / aux mux position of the clock source
•The desired output frequency
The SDK provides clock_configure  to configure a clock:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_clocks/clocks.c  Lines 40 - 133
 40 static void clock_configure_internal (clock_handle_t  clock, uint32_t  src, uint32_t  auxsrc,
    uint32_t  actual_freq , uint32_t  div) {
 41     clock_hw_t  *clock_hw  = &clocks_hw ->clk[clock];
 42 
 43     // If increasing divisor, set divisor before source. Otherwise set source
 44     // before divisor. This avoids a momentary overspeed when e.g. switching
 45     // to a faster source and increasing divisor to compensate.
 46     if (div > clock_hw ->div)
 47         clock_hw ->div = div;
 48 
 49     // If switching a glitchless slice (ref or sys) to an aux source, switch
 50     // away from aux *first* to avoid passing glitches when changing aux mux.
 51     // Assume (!!!) glitchless source 0 is no faster than the aux source.
 52     if (has_glitchless_mux (clock) && src ==
    CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX ) {
 53         hw_clear_bits (&clock_hw ->ctrl, CLOCKS_CLK_REF_CTRL_SRC_BITS );
 54         while (!(clock_hw ->selected  & 1u))
 55             tight_loop_contents ();
 56     }
 57     // If no glitchless mux, cleanly stop the clock to avoid glitches
 58     // propagating when changing aux mux. Note it would be a really bad idea
 59     // to do this on one of the glitchless clocks (clk_sys, clk_ref).
 60     else {
 61         // Disable clock. On clk_ref and clk_sys this does nothing,
 62         // all other clocks have the ENABLE bit in the same position.
 63         hw_clear_bits (&clock_hw ->ctrl, CLOCKS_CLK_GPOUT0_CTRL_ENABLE_BITS );
 64         if (configured_freq [clock] > 0) {
 65             // Delay for 3 cycles of the target clock, for ENABLE propagation.
 66             // Note XOSC_COUNT is not helpful here because XOSC is not
 67             // necessarily running, nor is timer...
 68             uint delay_cyc  = configured_freq [clk_sys] / configured_freq [clock] + 1;
 69             busy_wait_at_least_cycles (delay_cyc  * 3);
 70         }
 71     }
 72 
 73     // Set aux mux first, and then glitchless mux if this clock has one
 74     hw_write_masked (&clock_hw ->ctrl,
 75         (auxsrc << CLOCKS_CLK_SYS_CTRL_AUXSRC_LSB ),
 76         CLOCKS_CLK_SYS_CTRL_AUXSRC_BITS
 77     );
 78 
RP2350 Datasheet
8.1. Overview 524
 79     if (has_glitchless_mux (clock)) {
 80         hw_write_masked (&clock_hw ->ctrl,
 81             src << CLOCKS_CLK_REF_CTRL_SRC_LSB ,
 82             CLOCKS_CLK_REF_CTRL_SRC_BITS
 83         );
 84         while (!(clock_hw ->selected  & (1u << src)))
 85             tight_loop_contents ();
 86     }
 87 
 88     // Enable clock. On clk_ref and clk_sys this does nothing,
 89     // all other clocks have the ENABLE bit in the same position.
 90     hw_set_bits (&clock_hw ->ctrl, CLOCKS_CLK_GPOUT0_CTRL_ENABLE_BITS );
 91 
 92     // Now that the source is configured, we can trust that the user-supplied
 93     // divisor is a safe value.
 94     clock_hw ->div = div;
 95     configured_freq [clock] = actual_freq ;
 96 }
 97 
 98 bool clock_configure (clock_handle_t  clock, uint32_t  src, uint32_t  auxsrc, uint32_t  src_freq ,
    uint32_t  freq) {
 99     assert(src_freq  >= freq);
100 
101     if (freq > src_freq )
102         return false;
103 
104     uint64_t  div64 =((((uint64_t ) src_freq ) << CLOCKS_CLK_GPOUT0_DIV_INT_LSB ) / freq);
105     uint32_t  div, actual_freq ;
106     if (div64 >> 32) {
107         // set div to 0 for maximum clock divider
108         div = 0;
109         actual_freq  = src_freq  >> (32 - CLOCKS_CLK_GPOUT0_DIV_INT_LSB );
110     } else {
111         div = (uint32_t ) div64;
112         actual_freq  = (uint32_t ) ((((uint64_t ) src_freq ) << CLOCKS_CLK_GPOUT0_DIV_INT_LSB ) /
    div);
113     }
114 
115     clock_configure_internal (clock, src, auxsrc, actual_freq , div);
116     // Store the configured frequency
117     return true;
118 }
119 
120 void clock_configure_int_divider (clock_handle_t  clock, uint32_t  src, uint32_t  auxsrc,
    uint32_t  src_freq , uint32_t  int_divider ) {
121     clock_configure_internal (clock, src, auxsrc, src_freq  / int_divider , int_divider  <<
    CLOCKS_CLK_GPOUT0_DIV_INT_LSB );
122 }
123 
124 void clock_configure_undivided (clock_handle_t  clock, uint32_t  src, uint32_t  auxsrc, uint32_t
    src_freq ) {
125     clock_configure_internal (clock, src, auxsrc, src_freq , 1u <<
    CLOCKS_CLK_GPOUT0_DIV_INT_LSB );
126 }
clocks_init  calls clock_configure  for each clock. The following example shows the clk_sys configuration:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/pico_runtime_init/runtime_init_clocks.c  Lines 100 - 104
100         // CLK SYS = PLL SYS (usually) 125MHz / 1 = 125MHz
101         clock_configure_undivided (clk_sys,
102                         CLOCKS_CLK_SYS_CTRL_SRC_VALUE_CLKSRC_CLK_SYS_AUX ,
RP2350 Datasheet
8.1. Overview 525
103                         CLOCKS_CLK_SYS_CTRL_AUXSRC_VALUE_CLKSRC_PLL_SYS ,
104                         SYS_CLK_HZ );
Once a clock is configured, call clock_get_hz  to get the output frequency in Hz.
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_clocks/clocks.c  Lines 137 - 139
137 uint32_t  clock_get_hz (clock_handle_t  clock) {
138     return configured_freq [clock];
139 }
WARNING
The frequency returned by clock_get_hz  will be inaccurate if the provided source frequency is incorrect.
8.1.6.2. Using the frequency counter
To use the frequency counter, the programmer must:
1.Set the reference frequency: clk_ref.
2.Set the mux position of the source they want to measure. See FC0_SRC .
3.Wait for the DONE status bit in FC0_STATUS  to be set.
4.Read the result.
The SDK defines a frequency_count  function that takes the source as an argument and returns the frequency in kHz:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_clocks/clocks.c  Lines 147 - 174
147 uint32_t  frequency_count_khz (uint src) {
148     fc_hw_t *fc = &clocks_hw ->fc0;
149 
150     // If frequency counter is running need to wait for it. It runs even if the source is NULL
151     while(fc->status & CLOCKS_FC0_STATUS_RUNNING_BITS ) {
152         tight_loop_contents ();
153     }
154 
155     // Set reference freq
156     fc->ref_khz = clock_get_hz (clk_ref) / 1000;
157 
158     // FIXME: Don't pick random interval. Use best interval
159     fc->interval  = 10;
160 
161     // No min or max
162     fc->min_khz = 0;
163     fc->max_khz = 0xffffffff ;
164 
165     // Set SRC which automatically starts the measurement
166     fc->src = src;
167 
168     while(!(fc->status & CLOCKS_FC0_STATUS_DONE_BITS )) {
169         tight_loop_contents ();
170     }
171 
172     // Return the result
173     return fc->result >> CLOCKS_FC0_RESULT_KHZ_LSB ;
174 }
RP2350 Datasheet
8.1. Overview 526
There is also a wrapper function to change the unit to MHz:
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_clocks/include/hardware/clocks.h  Lines 377 - 379
377 static inline float frequency_count_mhz (uint src) {
378     return ((float) (frequency_count_khz (src))) / KHZ;
379 }
The frequency counter can also be used in a test mode. This allows the hardware to check if the frequency is between a
minimum and a maximum frequency, set in FC0_MIN_KHZ  and FC0_MAX_KHZ . This mode will set one of the following
bits in FC0_STATUS  when DONE is set:
•SLOW: if the frequency is below the specified range
•PASS: if the frequency is within the specified range
•FAST: if the frequency is above the specified range
•DIED: if the clock is stopped or stops running
Test mode will also set the FAIL bit if DIED, FAST, or SLOW are set.
8.1.6.3. Configuring a GPIO output clock
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_clocks/clocks.c  Lines 245 - 263
245 void clock_gpio_init_int_frac16 (uint gpio, uint src, uint32_t  div_int, uint16_t  div_frac16 )
    {
246     // note this includes an invalid_params_if before defaulting to clk_gpout0
247     uint gpclk = gpio_to_gpout_clock_handle (gpio, clk_gpout0 );
248 
249     invalid_params_if (HARDWARE_CLOCKS , div_int >> REG_FIELD_WIDTH (
    CLOCKS_CLK_GPOUT0_DIV_INT ));
250     // Set up the gpclk generator
251     clocks_hw ->clk[gpclk].ctrl = (src << CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_LSB ) |
252                                  CLOCKS_CLK_GPOUT0_CTRL_ENABLE_BITS ;
253 #ifdef REG_FIELD_WIDTH(CLOCKS_CLK_GPOUT0_DIV_FRAC) == 16
254     clocks_hw ->clk[gpclk].div = (div_int << CLOCKS_CLK_GPOUT0_DIV_INT_LSB ) | (div_frac16  <<
    CLOCKS_CLK_GPOUT0_DIV_FRAC_LSB );
255 #elif REG_FIELD_WIDTH(CLOCKS_CLK_GPOUT0_DIV_FRAC) == 8
256     clocks_hw ->clk[gpclk].div = (div_int << CLOCKS_CLK_GPOUT0_DIV_INT_LSB ) | ((div_frac16
    >>8u) << CLOCKS_CLK_GPOUT0_DIV_FRAC_LSB );
257 #else
258 #error unsupported number of fractional bits
259 #endif
260 
261     // Set gpio pin to gpclock function
262     gpio_set_function (gpio, GPIO_FUNC_GPCK );
263 }
8.1.6.4. Configuring a GPIO input clock
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_clocks/clocks.c  Lines 300 - 330
300 bool clock_configure_gpin (clock_handle_t  clock, uint gpio, uint32_t  src_freq , uint32_t  freq)
    {
301     // Configure a clock to run from a GPIO input
RP2350 Datasheet
8.1. Overview 527
302     uint gpin = 0;
303     if      (gpio == 20) gpin = 0;
304     else if (gpio == 22) gpin = 1;
305     else if (gpio == 12) gpin = 0;
306     else if (gpio == 14) gpin = 1;
307     else {
308         invalid_params_if (HARDWARE_CLOCKS , true);
309     }
310 
311     // Work out sources. GPIN is always an auxsrc
312     uint src = 0;
313 
314     // GPIN1 == GPIN0 + 1
315     uint auxsrc = gpin0_src [clock] + gpin;
316 
317     if (has_glitchless_mux (clock)) {
318         // AUX src is always 1
319         src = 1;
320     }
321 
322     // Set the GPIO function
323     gpio_set_function (gpio, GPIO_FUNC_GPCK );
324 
325     // Now we have the src, auxsrc, and configured the gpio input
326     // call clock configure to run the clock from a gpio
327     return clock_configure (clock, src, auxsrc, src_freq , freq);
328 }
8.1.6.5. Enabling resus
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_clocks/clocks.c  Lines 221 - 243
221 void clocks_enable_resus (resus_callback_t  resus_callback ) {
222     // Restart clk_sys if it is stopped by forcing it
223     // to the default source of clk_ref. If clk_ref stops running this will
224     // not work.
225 
226     // Store user's resus callback
227     _resus_callback  = resus_callback ;
228 
229     irq_set_exclusive_handler (CLOCKS_IRQ , clocks_irq_handler );
230 
231     // Enable the resus interrupt in clocks
232     clocks_hw ->inte = CLOCKS_INTE_CLK_SYS_RESUS_BITS ;
233 
234     // Enable the clocks irq
235     irq_set_enabled (CLOCKS_IRQ , true);
236 
237     // 2 * clk_ref freq / clk_sys_min_freq;
238     // assume clk_ref is 3MHz and we want clk_sys to be no lower than 1MHz
239     uint timeout = 2 * 3 * 1;
240 
241     // Enable resus with the maximum timeout
242     clocks_hw ->resus.ctrl = CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE_BITS  | timeout;
243 }
RP2350 Datasheet
8.1. Overview 528
8.1.6.6. Configuring sleep mode
Sleep mode is active when neither processor core nor the DMA are requesting clocks. For example, sleep mode is active
when the DMA is not active and both core 0 and core 1 are waiting for an interrupt.
The SLEEP_EN  registers set what clocks run in sleep mode. The hello_sleep  example ( hello_sleep_aon.c  in the pico-
playground  GitHub repository ) illustrates how to put the chip to sleep until the AON Timer fires.
NOTE
clk_sys is always sent to proc0 and proc1 during sleep mode, as some logic must be clocked for the processor to
wake up again.
Pico Extras: https://github.com/raspberrypi/pico-extras/blob/master/src/rp2_common/pico_sleep/sleep.c  Lines 159 - 183
159 void sleep_goto_sleep_until (struct timespec  *ts, aon_timer_alarm_handler_t  callback )
160 {
161 
162     // We should have already called the sleep_run_from_dormant_source function
163     // This is only needed for dormancy although it saves power running from xosc while
    sleeping
164     //assert(dormant_source_valid(_dormant_source));
165 
166     clocks_hw ->sleep_en0  = CLOCKS_SLEEP_EN0_CLK_REF_POWMAN_BITS ;
167     clocks_hw ->sleep_en1  = 0x0;
168 
169     aon_timer_enable_alarm (ts, callback , false);
170 
171     stdio_flush ();
172 
173     // Enable deep sleep at the proc
174     processor_deep_sleep ();
175 
176     // Go to sleep
177     __wfi();
178 }
8.1.7. List of registers
The clocks registers start at a base address of 0x40010000  (defined as CLOCKS_BASE  in SDK).
Table 543. List of
CLOCKS registersOffset Name Info
0x00 CLK_GPOUT0_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x04 CLK_GPOUT0_DIV
0x08 CLK_GPOUT0_SELECTED Indicates which src is currently selected (one-hot)
0x0c CLK_GPOUT1_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x10 CLK_GPOUT1_DIV
0x14 CLK_GPOUT1_SELECTED Indicates which src is currently selected (one-hot)
0x18 CLK_GPOUT2_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x1c CLK_GPOUT2_DIV
0x20 CLK_GPOUT2_SELECTED Indicates which src is currently selected (one-hot)
0x24 CLK_GPOUT3_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
RP2350 Datasheet
8.1. Overview 529
Offset Name Info
0x28 CLK_GPOUT3_DIV
0x2c CLK_GPOUT3_SELECTED Indicates which src is currently selected (one-hot)
0x30 CLK_REF_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x34 CLK_REF_DIV
0x38 CLK_REF_SELECTED Indicates which src is currently selected (one-hot)
0x3c CLK_SYS_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x40 CLK_SYS_DIV
0x44 CLK_SYS_SELECTED Indicates which src is currently selected (one-hot)
0x48 CLK_PERI_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x4c CLK_PERI_DIV
0x50 CLK_PERI_SELECTED Indicates which src is currently selected (one-hot)
0x54 CLK_HSTX_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x58 CLK_HSTX_DIV
0x5c CLK_HSTX_SELECTED Indicates which src is currently selected (one-hot)
0x60 CLK_USB_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x64 CLK_USB_DIV
0x68 CLK_USB_SELECTED Indicates which src is currently selected (one-hot)
0x6c CLK_ADC_CTRL Clock control, can be changed on-the-fly (except for auxsrc)
0x70 CLK_ADC_DIV
0x74 CLK_ADC_SELECTED Indicates which src is currently selected (one-hot)
0x78 DFTCLK_XOSC_CTRL
0x7c DFTCLK_ROSC_CTRL
0x80 DFTCLK_LPOSC_CTRL
0x84 CLK_SYS_RESUS_CTRL
0x88 CLK_SYS_RESUS_STATUS
0x8c FC0_REF_KHZ Reference clock frequency in kHz
0x90 FC0_MIN_KHZ Minimum pass frequency in kHz. This is optional. Set to 0 if you
are not using the pass/fail flags
0x94 FC0_MAX_KHZ Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff
if you are not using the pass/fail flags
0x98 FC0_DELAY Delays the start of frequency counting to allow the mux to settle
Delay is measured in multiples of the reference clock period
0x9c FC0_INTERVAL The test interval is 0.98us * 2**interval, but let’s call it 1us *
2**interval
The default gives a test interval of 250us
0xa0 FC0_SRC Clock sent to frequency counter, set to 0 when not required
Writing to this register initiates the frequency count
0xa4 FC0_STATUS Frequency counter status
RP2350 Datasheet
8.1. Overview 530
Offset Name Info
0xa8 FC0_RESULT Result of frequency measurement, only valid when
status_done=1
0xac WAKE_EN0 enable clock in wake mode
0xb0 WAKE_EN1 enable clock in wake mode
0xb4 SLEEP_EN0 enable clock in sleep mode
0xb8 SLEEP_EN1 enable clock in sleep mode
0xbc ENABLED0 indicates the state of the clock enable
0xc0 ENABLED1 indicates the state of the clock enable
0xc4 INTR Raw Interrupts
0xc8 INTE Interrupt Enable
0xcc INTF Interrupt Force
0xd0 INTS Interrupt status after masking & forcing
CLOCKS : CLK_GPOUT0_CTRL Register
Offset : 0x00
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 544.
CLK_GPOUT0_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 ENABLED : clock generator is enabled RO 0x0
27:21 Reserved. - -
20 NUDGE : An edge on this signal shifts the phase of the output by 1 cycle of the
input clock
This can be done at any timeRW 0x0
19:18 Reserved. - -
17:16 PHASE : This delays the enable signal by up to 3 cycles of the input clock
This must be set before the clock is enabled to have any effectRW 0x0
15:13 Reserved. - -
12 DC50 : Enables duty cycle correction for odd divisors, can be changed on-the-
flyRW 0x0
11 ENABLE : Starts and stops the clock generator cleanly RW 0x0
10 KILL : Asynchronously kills the clock generator, enable must be set low before
deasserting killRW 0x0
9 Reserved. - -
8:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLKSRC_PLL_SYS
0x1 → CLKSRC_GPIN0
RP2350 Datasheet
8.1. Overview 531
Bits Description Type Reset
0x2 → CLKSRC_GPIN1
0x3 → CLKSRC_PLL_USB
0x4 → CLKSRC_PLL_USB_PRIMARY_REF_OPCG
0x5 → ROSC_CLKSRC
0x6 → XOSC_CLKSRC
0x7 → LPOSC_CLKSRC
0x8 → CLK_SYS
0x9 → CLK_USB
0xa → CLK_ADC
0xb → CLK_REF
0xc → CLK_PERI
0xd → CLK_HSTX
0xe → OTP_CLK2FC
4:0 Reserved. - -
CLOCKS : CLK_GPOUT0_DIV Register
Offset : 0x04
Table 545.
CLK_GPOUT0_DIV
RegisterBits Description Type Reset
31:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x0001
15:0 FRAC : Fractional component of the divisor, can be changed on-the-fly RW 0x0000
CLOCKS : CLK_GPOUT0_SELECTED Register
Offset : 0x08
Description
Indicates which src is currently selected (one-hot)
Table 546.
CLK_GPOUT0_SELECT
ED RegisterBits Description Type Reset
31:1 Reserved. - -
0 This slice does not have a glitchless mux (only the AUX_SRC field is present,
not SRC) so this register is hardwired to 0x1.RO 0x1
CLOCKS : CLK_GPOUT1_CTRL Register
Offset : 0x0c
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 547.
CLK_GPOUT1_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 ENABLED : clock generator is enabled RO 0x0
RP2350 Datasheet
8.1. Overview 532
Bits Description Type Reset
27:21 Reserved. - -
20 NUDGE : An edge on this signal shifts the phase of the output by 1 cycle of the
input clock
This can be done at any timeRW 0x0
19:18 Reserved. - -
17:16 PHASE : This delays the enable signal by up to 3 cycles of the input clock
This must be set before the clock is enabled to have any effectRW 0x0
15:13 Reserved. - -
12 DC50 : Enables duty cycle correction for odd divisors, can be changed on-the-
flyRW 0x0
11 ENABLE : Starts and stops the clock generator cleanly RW 0x0
10 KILL : Asynchronously kills the clock generator, enable must be set low before
deasserting killRW 0x0
9 Reserved. - -
8:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLKSRC_PLL_SYS
0x1 → CLKSRC_GPIN0
0x2 → CLKSRC_GPIN1
0x3 → CLKSRC_PLL_USB
0x4 → CLKSRC_PLL_USB_PRIMARY_REF_OPCG
0x5 → ROSC_CLKSRC
0x6 → XOSC_CLKSRC
0x7 → LPOSC_CLKSRC
0x8 → CLK_SYS
0x9 → CLK_USB
0xa → CLK_ADC
0xb → CLK_REF
0xc → CLK_PERI
0xd → CLK_HSTX
0xe → OTP_CLK2FC
4:0 Reserved. - -
CLOCKS : CLK_GPOUT1_DIV Register
Offset : 0x10
Table 548.
CLK_GPOUT1_DIV
RegisterBits Description Type Reset
31:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x0001
RP2350 Datasheet
8.1. Overview 533
Bits Description Type Reset
15:0 FRAC : Fractional component of the divisor, can be changed on-the-fly RW 0x0000
CLOCKS : CLK_GPOUT1_SELECTED Register
Offset : 0x14
Description
Indicates which src is currently selected (one-hot)
Table 549.
CLK_GPOUT1_SELECT
ED RegisterBits Description Type Reset
31:1 Reserved. - -
0 This slice does not have a glitchless mux (only the AUX_SRC field is present,
not SRC) so this register is hardwired to 0x1.RO 0x1
CLOCKS : CLK_GPOUT2_CTRL Register
Offset : 0x18
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 550.
CLK_GPOUT2_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 ENABLED : clock generator is enabled RO 0x0
27:21 Reserved. - -
20 NUDGE : An edge on this signal shifts the phase of the output by 1 cycle of the
input clock
This can be done at any timeRW 0x0
19:18 Reserved. - -
17:16 PHASE : This delays the enable signal by up to 3 cycles of the input clock
This must be set before the clock is enabled to have any effectRW 0x0
15:13 Reserved. - -
12 DC50 : Enables duty cycle correction for odd divisors, can be changed on-the-
flyRW 0x0
11 ENABLE : Starts and stops the clock generator cleanly RW 0x0
10 KILL : Asynchronously kills the clock generator, enable must be set low before
deasserting killRW 0x0
9 Reserved. - -
8:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLKSRC_PLL_SYS
0x1 → CLKSRC_GPIN0
0x2 → CLKSRC_GPIN1
0x3 → CLKSRC_PLL_USB
0x4 → CLKSRC_PLL_USB_PRIMARY_REF_OPCG
RP2350 Datasheet
8.1. Overview 534
Bits Description Type Reset
0x5 → ROSC_CLKSRC_PH
0x6 → XOSC_CLKSRC
0x7 → LPOSC_CLKSRC
0x8 → CLK_SYS
0x9 → CLK_USB
0xa → CLK_ADC
0xb → CLK_REF
0xc → CLK_PERI
0xd → CLK_HSTX
0xe → OTP_CLK2FC
4:0 Reserved. - -
CLOCKS : CLK_GPOUT2_DIV Register
Offset : 0x1c
Table 551.
CLK_GPOUT2_DIV
RegisterBits Description Type Reset
31:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x0001
15:0 FRAC : Fractional component of the divisor, can be changed on-the-fly RW 0x0000
CLOCKS : CLK_GPOUT2_SELECTED Register
Offset : 0x20
Description
Indicates which src is currently selected (one-hot)
Table 552.
CLK_GPOUT2_SELECT
ED RegisterBits Description Type Reset
31:1 Reserved. - -
0 This slice does not have a glitchless mux (only the AUX_SRC field is present,
not SRC) so this register is hardwired to 0x1.RO 0x1
CLOCKS : CLK_GPOUT3_CTRL Register
Offset : 0x24
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 553.
CLK_GPOUT3_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 ENABLED : clock generator is enabled RO 0x0
27:21 Reserved. - -
RP2350 Datasheet
8.1. Overview 535
Bits Description Type Reset
20 NUDGE : An edge on this signal shifts the phase of the output by 1 cycle of the
input clock
This can be done at any timeRW 0x0
19:18 Reserved. - -
17:16 PHASE : This delays the enable signal by up to 3 cycles of the input clock
This must be set before the clock is enabled to have any effectRW 0x0
15:13 Reserved. - -
12 DC50 : Enables duty cycle correction for odd divisors, can be changed on-the-
flyRW 0x0
11 ENABLE : Starts and stops the clock generator cleanly RW 0x0
10 KILL : Asynchronously kills the clock generator, enable must be set low before
deasserting killRW 0x0
9 Reserved. - -
8:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLKSRC_PLL_SYS
0x1 → CLKSRC_GPIN0
0x2 → CLKSRC_GPIN1
0x3 → CLKSRC_PLL_USB
0x4 → CLKSRC_PLL_USB_PRIMARY_REF_OPCG
0x5 → ROSC_CLKSRC_PH
0x6 → XOSC_CLKSRC
0x7 → LPOSC_CLKSRC
0x8 → CLK_SYS
0x9 → CLK_USB
0xa → CLK_ADC
0xb → CLK_REF
0xc → CLK_PERI
0xd → CLK_HSTX
0xe → OTP_CLK2FC
4:0 Reserved. - -
CLOCKS : CLK_GPOUT3_DIV Register
Offset : 0x28
RP2350 Datasheet
8.1. Overview 536
Table 554.
CLK_GPOUT3_DIV
RegisterBits Description Type Reset
31:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x0001
15:0 FRAC : Fractional component of the divisor, can be changed on-the-fly RW 0x0000
CLOCKS : CLK_GPOUT3_SELECTED Register
Offset : 0x2c
Description
Indicates which src is currently selected (one-hot)
Table 555.
CLK_GPOUT3_SELECT
ED RegisterBits Description Type Reset
31:1 Reserved. - -
0 This slice does not have a glitchless mux (only the AUX_SRC field is present,
not SRC) so this register is hardwired to 0x1.RO 0x1
CLOCKS : CLK_REF_CTRL Register
Offset : 0x30
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 556.
CLK_REF_CTRL
RegisterBits Description Type Reset
31:7 Reserved. - -
6:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLKSRC_PLL_USB
0x1 → CLKSRC_GPIN0
0x2 → CLKSRC_GPIN1
0x3 → CLKSRC_PLL_USB_PRIMARY_REF_OPCG
4:2 Reserved. - -
1:0 SRC : Selects the clock source glitchlessly, can be changed on-the-fly RW -
Enumerated values:
0x0 → ROSC_CLKSRC_PH
0x1 → CLKSRC_CLK_REF_AUX
0x2 → XOSC_CLKSRC
0x3 → LPOSC_CLKSRC
CLOCKS : CLK_REF_DIV Register
Offset : 0x34
Table 557.
CLK_REF_DIV RegisterBits Description Type Reset
31:24 Reserved. - -
23:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x01
RP2350 Datasheet
8.1. Overview 537
Bits Description Type Reset
15:0 Reserved. - -
CLOCKS : CLK_REF_SELECTED Register
Offset : 0x38
Description
Indicates which src is currently selected (one-hot)
Table 558.
CLK_REF_SELECTED
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 The glitchless multiplexer does not switch instantaneously (to avoid glitches),
so software should poll this register to wait for the switch to complete. This
register contains one decoded bit for each of the clock sources enumerated in
the CTRL SRC field. At most one of these bits will be set at any time, indicating
that clock is currently present at the output of the glitchless mux. Whilst
switching is in progress, this register may briefly show all-0s.RO 0x1
CLOCKS : CLK_SYS_CTRL Register
Offset : 0x3c
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 559.
CLK_SYS_CTRL
RegisterBits Description Type Reset
31:8 Reserved. - -
7:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x2
Enumerated values:
0x0 → CLKSRC_PLL_SYS
0x1 → CLKSRC_PLL_USB
0x2 → ROSC_CLKSRC
0x3 → XOSC_CLKSRC
0x4 → CLKSRC_GPIN0
0x5 → CLKSRC_GPIN1
4:1 Reserved. - -
0 SRC : Selects the clock source glitchlessly, can be changed on-the-fly RW 0x1
Enumerated values:
0x0 → CLK_REF
0x1 → CLKSRC_CLK_SYS_AUX
CLOCKS : CLK_SYS_DIV Register
Offset : 0x40
RP2350 Datasheet
8.1. Overview 538
Table 560.
CLK_SYS_DIV RegisterBits Description Type Reset
31:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x0001
15:0 FRAC : Fractional component of the divisor, can be changed on-the-fly RW 0x0000
CLOCKS : CLK_SYS_SELECTED Register
Offset : 0x44
Description
Indicates which src is currently selected (one-hot)
Table 561.
CLK_SYS_SELECTED
RegisterBits Description Type Reset
31:2 Reserved. - -
1:0 The glitchless multiplexer does not switch instantaneously (to avoid glitches),
so software should poll this register to wait for the switch to complete. This
register contains one decoded bit for each of the clock sources enumerated in
the CTRL SRC field. At most one of these bits will be set at any time, indicating
that clock is currently present at the output of the glitchless mux. Whilst
switching is in progress, this register may briefly show all-0s.RO 0x1
CLOCKS : CLK_PERI_CTRL Register
Offset : 0x48
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 562.
CLK_PERI_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 ENABLED : clock generator is enabled RO 0x0
27:12 Reserved. - -
11 ENABLE : Starts and stops the clock generator cleanly RW 0x0
10 KILL : Asynchronously kills the clock generator, enable must be set low before
deasserting killRW 0x0
9:8 Reserved. - -
7:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLK_SYS
0x1 → CLKSRC_PLL_SYS
0x2 → CLKSRC_PLL_USB
0x3 → ROSC_CLKSRC_PH
0x4 → XOSC_CLKSRC
0x5 → CLKSRC_GPIN0
0x6 → CLKSRC_GPIN1
4:0 Reserved. - -
RP2350 Datasheet
8.1. Overview 539
CLOCKS : CLK_PERI_DIV Register
Offset : 0x4c
Table 563.
CLK_PERI_DIV
RegisterBits Description Type Reset
31:18 Reserved. - -
17:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x1
15:0 Reserved. - -
CLOCKS : CLK_PERI_SELECTED Register
Offset : 0x50
Description
Indicates which src is currently selected (one-hot)
Table 564.
CLK_PERI_SELECTED
RegisterBits Description Type Reset
31:1 Reserved. - -
0 This slice does not have a glitchless mux (only the AUX_SRC field is present,
not SRC) so this register is hardwired to 0x1.RO 0x1
CLOCKS : CLK_HSTX_CTRL Register
Offset : 0x54
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 565.
CLK_HSTX_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 ENABLED : clock generator is enabled RO 0x0
27:21 Reserved. - -
20 NUDGE : An edge on this signal shifts the phase of the output by 1 cycle of the
input clock
This can be done at any timeRW 0x0
19:18 Reserved. - -
17:16 PHASE : This delays the enable signal by up to 3 cycles of the input clock
This must be set before the clock is enabled to have any effectRW 0x0
15:12 Reserved. - -
11 ENABLE : Starts and stops the clock generator cleanly RW 0x0
10 KILL : Asynchronously kills the clock generator, enable must be set low before
deasserting killRW 0x0
9:8 Reserved. - -
7:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLK_SYS
0x1 → CLKSRC_PLL_SYS
RP2350 Datasheet
8.1. Overview 540
Bits Description Type Reset
0x2 → CLKSRC_PLL_USB
0x3 → CLKSRC_GPIN0
0x4 → CLKSRC_GPIN1
4:0 Reserved. - -
CLOCKS : CLK_HSTX_DIV Register
Offset : 0x58
Table 566.
CLK_HSTX_DIV
RegisterBits Description Type Reset
31:18 Reserved. - -
17:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x1
15:0 Reserved. - -
CLOCKS : CLK_HSTX_SELECTED Register
Offset : 0x5c
Description
Indicates which src is currently selected (one-hot)
Table 567.
CLK_HSTX_SELECTED
RegisterBits Description Type Reset
31:1 Reserved. - -
0 This slice does not have a glitchless mux (only the AUX_SRC field is present,
not SRC) so this register is hardwired to 0x1.RO 0x1
CLOCKS : CLK_USB_CTRL Register
Offset : 0x60
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 568.
CLK_USB_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 ENABLED : clock generator is enabled RO 0x0
27:21 Reserved. - -
20 NUDGE : An edge on this signal shifts the phase of the output by 1 cycle of the
input clock
This can be done at any timeRW 0x0
19:18 Reserved. - -
17:16 PHASE : This delays the enable signal by up to 3 cycles of the input clock
This must be set before the clock is enabled to have any effectRW 0x0
15:12 Reserved. - -
11 ENABLE : Starts and stops the clock generator cleanly RW 0x0
RP2350 Datasheet
8.1. Overview 541
Bits Description Type Reset
10 KILL : Asynchronously kills the clock generator, enable must be set low before
deasserting killRW 0x0
9:8 Reserved. - -
7:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLKSRC_PLL_USB
0x1 → CLKSRC_PLL_SYS
0x2 → ROSC_CLKSRC_PH
0x3 → XOSC_CLKSRC
0x4 → CLKSRC_GPIN0
0x5 → CLKSRC_GPIN1
4:0 Reserved. - -
CLOCKS : CLK_USB_DIV Register
Offset : 0x64
Table 569.
CLK_USB_DIV RegisterBits Description Type Reset
31:20 Reserved. - -
19:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x1
15:0 Reserved. - -
CLOCKS : CLK_USB_SELECTED Register
Offset : 0x68
Description
Indicates which src is currently selected (one-hot)
Table 570.
CLK_USB_SELECTED
RegisterBits Description Type Reset
31:1 Reserved. - -
0 This slice does not have a glitchless mux (only the AUX_SRC field is present,
not SRC) so this register is hardwired to 0x1.RO 0x1
CLOCKS : CLK_ADC_CTRL Register
Offset : 0x6c
Description
Clock control, can be changed on-the-fly (except for auxsrc)
Table 571.
CLK_ADC_CTRL
RegisterBits Description Type Reset
31:29 Reserved. - -
28 ENABLED : clock generator is enabled RO 0x0
27:21 Reserved. - -
RP2350 Datasheet
8.1. Overview 542
Bits Description Type Reset
20 NUDGE : An edge on this signal shifts the phase of the output by 1 cycle of the
input clock
This can be done at any timeRW 0x0
19:18 Reserved. - -
17:16 PHASE : This delays the enable signal by up to 3 cycles of the input clock
This must be set before the clock is enabled to have any effectRW 0x0
15:12 Reserved. - -
11 ENABLE : Starts and stops the clock generator cleanly RW 0x0
10 KILL : Asynchronously kills the clock generator, enable must be set low before
deasserting killRW 0x0
9:8 Reserved. - -
7:5 AUXSRC : Selects the auxiliary clock source, will glitch when switching RW 0x0
Enumerated values:
0x0 → CLKSRC_PLL_USB
0x1 → CLKSRC_PLL_SYS
0x2 → ROSC_CLKSRC_PH
0x3 → XOSC_CLKSRC
0x4 → CLKSRC_GPIN0
0x5 → CLKSRC_GPIN1
4:0 Reserved. - -
CLOCKS : CLK_ADC_DIV Register
Offset : 0x70
Table 572.
CLK_ADC_DIV RegisterBits Description Type Reset
31:20 Reserved. - -
19:16 INT: Integer part of clock divisor, 0 → max+1, can be changed on-the-fly RW 0x1
15:0 Reserved. - -
CLOCKS : CLK_ADC_SELECTED Register
Offset : 0x74
Description
Indicates which src is currently selected (one-hot)
RP2350 Datasheet
8.1. Overview 543
Table 573.
CLK_ADC_SELECTED
RegisterBits Description Type Reset
31:1 Reserved. - -
0 This slice does not have a glitchless mux (only the AUX_SRC field is present,
not SRC) so this register is hardwired to 0x1.RO 0x1
CLOCKS : DFTCLK_XOSC_CTRL Register
Offset : 0x78
Table 574.
DFTCLK_XOSC_CTRL
RegisterBits Description Type Reset
31:2 Reserved. - -
1:0 SRC RW 0x0
Enumerated values:
0x0 → NULL
0x1 → CLKSRC_PLL_USB_PRIMARY
0x2 → CLKSRC_GPIN0
CLOCKS : DFTCLK_ROSC_CTRL Register
Offset : 0x7c
Table 575.
DFTCLK_ROSC_CTRL
RegisterBits Description Type Reset
31:2 Reserved. - -
1:0 SRC RW 0x0
Enumerated values:
0x0 → NULL
0x1 → CLKSRC_PLL_SYS_PRIMARY_ROSC
0x2 → CLKSRC_GPIN1
CLOCKS : DFTCLK_LPOSC_CTRL Register
Offset : 0x80
Table 576.
DFTCLK_LPOSC_CTRL
RegisterBits Description Type Reset
31:2 Reserved. - -
1:0 SRC RW 0x0
Enumerated values:
0x0 → NULL
0x1 → CLKSRC_PLL_USB_PRIMARY_LPOSC
0x2 → CLKSRC_GPIN1
CLOCKS : CLK_SYS_RESUS_CTRL Register
Offset : 0x84
RP2350 Datasheet
8.1. Overview 544
Table 577.
CLK_SYS_RESUS_CTR
L RegisterBits Description Type Reset
31:17 Reserved. - -
16 CLEAR : For clearing the resus after the fault that triggered it has been
correctedRW 0x0
15:13 Reserved. - -
12 FRCE : Force a resus, for test purposes only RW 0x0
11:9 Reserved. - -
8 ENABLE : Enable resus RW 0x0
7:0 TIMEOUT : This is expressed as a number of clk_ref cycles
and must be >= 2x clk_ref_freq/min_clk_tst_freqRW 0xff
CLOCKS : CLK_SYS_RESUS_STATUS Register
Offset : 0x88
Table 578.
CLK_SYS_RESUS_STA
TUS RegisterBits Description Type Reset
31:1 Reserved. - -
0 RESUSSED : Clock has been resuscitated, correct the error then send
ctrl_clear=1RO 0x0
CLOCKS : FC0_REF_KHZ Register
Offset : 0x8c
Table 579.
FC0_REF_KHZ RegisterBits Description Type Reset
31:20 Reserved. - -
19:0 Reference clock frequency in kHz RW 0x00000
CLOCKS : FC0_MIN_KHZ Register
Offset : 0x90
Table 580.
FC0_MIN_KHZ
RegisterBits Description Type Reset
31:25 Reserved. - -
24:0 Minimum pass frequency in kHz. This is optional. Set to 0 if you are not using
the pass/fail flagsRW 0x0000000
CLOCKS : FC0_MAX_KHZ Register
Offset : 0x94
Table 581.
FC0_MAX_KHZ
RegisterBits Description Type Reset
31:25 Reserved. - -
24:0 Maximum pass frequency in kHz. This is optional. Set to 0x1ffffff if you are
not using the pass/fail flagsRW 0x1ffffff
CLOCKS : FC0_DELAY Register
Offset : 0x98
RP2350 Datasheet
8.1. Overview 545
Table 582. FC0_DELAY
RegisterBits Description Type Reset
31:3 Reserved. - -
2:0 Delays the start of frequency counting to allow the mux to settle
Delay is measured in multiples of the reference clock periodRW 0x1
CLOCKS : FC0_INTERVAL Register
Offset : 0x9c
Table 583.
FC0_INTERVAL
RegisterBits Description Type Reset
31:4 Reserved. - -
3:0 The test interval is 0.98us * 2**interval, but let’s call it 1us * 2**interval
The default gives a test interval of 250usRW 0x8
CLOCKS : FC0_SRC Register
Offset : 0xa0
Table 584. FC0_SRC
RegisterBits Description Type Reset
31:8 Reserved. - -
7:0 Clock sent to frequency counter, set to 0 when not required
Writing to this register initiates the frequency countRW 0x00
Enumerated values:
0x00 → NULL
0x01 → PLL_SYS_CLKSRC_PRIMARY
0x02 → PLL_USB_CLKSRC_PRIMARY
0x03 → ROSC_CLKSRC
0x04 → ROSC_CLKSRC_PH
0x05 → XOSC_CLKSRC
0x06 → CLKSRC_GPIN0
0x07 → CLKSRC_GPIN1
0x08 → CLK_REF
0x09 → CLK_SYS
0x0a → CLK_PERI
0x0b → CLK_USB
0x0c → CLK_ADC
0x0d → CLK_HSTX
0x0e → LPOSC_CLKSRC
0x0f → OTP_CLK2FC
0x10 → PLL_USB_CLKSRC_PRIMARY_DFT
CLOCKS : FC0_STATUS Register
Offset : 0xa4
RP2350 Datasheet
8.1. Overview 546
Description
Frequency counter status
Table 585.
FC0_STATUS RegisterBits Description Type Reset
31:29 Reserved. - -
28 DIED : Test clock stopped during test RO 0x0
27:25 Reserved. - -
24 FAST : Test clock faster than expected, only valid when status_done=1 RO 0x0
23:21 Reserved. - -
20 SLOW : Test clock slower than expected, only valid when status_done=1 RO 0x0
19:17 Reserved. - -
16 FAIL : Test failed RO 0x0
15:13 Reserved. - -
12 WAITING : Waiting for test clock to start RO 0x0
11:9 Reserved. - -
8 RUNNING : Test running RO 0x0
7:5 Reserved. - -
4 DONE : Test complete RO 0x0
3:1 Reserved. - -
0 PASS : Test passed RO 0x0
CLOCKS : FC0_RESULT Register
Offset : 0xa8
Description
Result of frequency measurement, only valid when status_done=1
Table 586.
FC0_RESULT RegisterBits Description Type Reset
31:30 Reserved. - -
29:5 KHZ RO 0x0000000
4:0 FRAC RO 0x00
CLOCKS : WAKE_EN0 Register
Offset : 0xac
Description
enable clock in wake mode
Table 587. WAKE_EN0
RegisterBits Description Type Reset
31 CLK_SYS_SIO RW 0x1
30 CLK_SYS_SHA256 RW 0x1
29 CLK_SYS_PSM RW 0x1
28 CLK_SYS_ROSC RW 0x1
RP2350 Datasheet
8.1. Overview 547
Bits Description Type Reset
27 CLK_SYS_ROM RW 0x1
26 CLK_SYS_RESETS RW 0x1
25 CLK_SYS_PWM RW 0x1
24 CLK_SYS_POWMAN RW 0x1
23 CLK_REF_POWMAN RW 0x1
22 CLK_SYS_PLL_USB RW 0x1
21 CLK_SYS_PLL_SYS RW 0x1
20 CLK_SYS_PIO2 RW 0x1
19 CLK_SYS_PIO1 RW 0x1
18 CLK_SYS_PIO0 RW 0x1
17 CLK_SYS_PADS RW 0x1
16 CLK_SYS_OTP RW 0x1
15 CLK_REF_OTP RW 0x1
14 CLK_SYS_JTAG RW 0x1
13 CLK_SYS_IO RW 0x1
12 CLK_SYS_I2C1 RW 0x1
11 CLK_SYS_I2C0 RW 0x1
10 CLK_SYS_HSTX RW 0x1
9 CLK_HSTX RW 0x1
8 CLK_SYS_GLITCH_DETECTOR RW 0x1
7 CLK_SYS_DMA RW 0x1
6 CLK_SYS_BUSFABRIC RW 0x1
5 CLK_SYS_BUSCTRL RW 0x1
4 CLK_SYS_BOOTRAM RW 0x1
3 CLK_SYS_ADC RW 0x1
2 CLK_ADC_ADC RW 0x1
1 CLK_SYS_ACCESSCTRL RW 0x1
0 CLK_SYS_CLOCKS RW 0x1
CLOCKS : WAKE_EN1 Register
Offset : 0xb0
Description
enable clock in wake mode
Table 588. WAKE_EN1
RegisterBits Description Type Reset
31 Reserved. - -
30 CLK_SYS_XOSC RW 0x1
RP2350 Datasheet
8.1. Overview 548
Bits Description Type Reset
29 CLK_SYS_XIP RW 0x1
28 CLK_SYS_WATCHDOG RW 0x1
27 CLK_USB RW 0x1
26 CLK_SYS_USBCTRL RW 0x1
25 CLK_SYS_UART1 RW 0x1
24 CLK_PERI_UART1 RW 0x1
23 CLK_SYS_UART0 RW 0x1
22 CLK_PERI_UART0 RW 0x1
21 CLK_SYS_TRNG RW 0x1
20 CLK_SYS_TIMER1 RW 0x1
19 CLK_SYS_TIMER0 RW 0x1
18 CLK_SYS_TICKS RW 0x1
17 CLK_REF_TICKS RW 0x1
16 CLK_SYS_TBMAN RW 0x1
15 CLK_SYS_SYSINFO RW 0x1
14 CLK_SYS_SYSCFG RW 0x1
13 CLK_SYS_SRAM9 RW 0x1
12 CLK_SYS_SRAM8 RW 0x1
11 CLK_SYS_SRAM7 RW 0x1
10 CLK_SYS_SRAM6 RW 0x1
9 CLK_SYS_SRAM5 RW 0x1
8 CLK_SYS_SRAM4 RW 0x1
7 CLK_SYS_SRAM3 RW 0x1
6 CLK_SYS_SRAM2 RW 0x1
5 CLK_SYS_SRAM1 RW 0x1
4 CLK_SYS_SRAM0 RW 0x1
3 CLK_SYS_SPI1 RW 0x1
2 CLK_PERI_SPI1 RW 0x1
1 CLK_SYS_SPI0 RW 0x1
0 CLK_PERI_SPI0 RW 0x1
CLOCKS : SLEEP_EN0 Register
Offset : 0xb4
Description
enable clock in sleep mode
RP2350 Datasheet
8.1. Overview 549
Table 589. SLEEP_EN0
RegisterBits Description Type Reset
31 CLK_SYS_SIO RW 0x1
30 CLK_SYS_SHA256 RW 0x1
29 CLK_SYS_PSM RW 0x1
28 CLK_SYS_ROSC RW 0x1
27 CLK_SYS_ROM RW 0x1
26 CLK_SYS_RESETS RW 0x1
25 CLK_SYS_PWM RW 0x1
24 CLK_SYS_POWMAN RW 0x1
23 CLK_REF_POWMAN RW 0x1
22 CLK_SYS_PLL_USB RW 0x1
21 CLK_SYS_PLL_SYS RW 0x1
20 CLK_SYS_PIO2 RW 0x1
19 CLK_SYS_PIO1 RW 0x1
18 CLK_SYS_PIO0 RW 0x1
17 CLK_SYS_PADS RW 0x1
16 CLK_SYS_OTP RW 0x1
15 CLK_REF_OTP RW 0x1
14 CLK_SYS_JTAG RW 0x1
13 CLK_SYS_IO RW 0x1
12 CLK_SYS_I2C1 RW 0x1
11 CLK_SYS_I2C0 RW 0x1
10 CLK_SYS_HSTX RW 0x1
9 CLK_HSTX RW 0x1
8 CLK_SYS_GLITCH_DETECTOR RW 0x1
7 CLK_SYS_DMA RW 0x1
6 CLK_SYS_BUSFABRIC RW 0x1
5 CLK_SYS_BUSCTRL RW 0x1
4 CLK_SYS_BOOTRAM RW 0x1
3 CLK_SYS_ADC RW 0x1
2 CLK_ADC_ADC RW 0x1
1 CLK_SYS_ACCESSCTRL RW 0x1
0 CLK_SYS_CLOCKS RW 0x1
CLOCKS : SLEEP_EN1 Register
Offset : 0xb8
RP2350 Datasheet
8.1. Overview 550
Description
enable clock in sleep mode
Table 590. SLEEP_EN1
RegisterBits Description Type Reset
31 Reserved. - -
30 CLK_SYS_XOSC RW 0x1
29 CLK_SYS_XIP RW 0x1
28 CLK_SYS_WATCHDOG RW 0x1
27 CLK_USB RW 0x1
26 CLK_SYS_USBCTRL RW 0x1
25 CLK_SYS_UART1 RW 0x1
24 CLK_PERI_UART1 RW 0x1
23 CLK_SYS_UART0 RW 0x1
22 CLK_PERI_UART0 RW 0x1
21 CLK_SYS_TRNG RW 0x1
20 CLK_SYS_TIMER1 RW 0x1
19 CLK_SYS_TIMER0 RW 0x1
18 CLK_SYS_TICKS RW 0x1
17 CLK_REF_TICKS RW 0x1
16 CLK_SYS_TBMAN RW 0x1
15 CLK_SYS_SYSINFO RW 0x1
14 CLK_SYS_SYSCFG RW 0x1
13 CLK_SYS_SRAM9 RW 0x1
12 CLK_SYS_SRAM8 RW 0x1
11 CLK_SYS_SRAM7 RW 0x1
10 CLK_SYS_SRAM6 RW 0x1
9 CLK_SYS_SRAM5 RW 0x1
8 CLK_SYS_SRAM4 RW 0x1
7 CLK_SYS_SRAM3 RW 0x1
6 CLK_SYS_SRAM2 RW 0x1
5 CLK_SYS_SRAM1 RW 0x1
4 CLK_SYS_SRAM0 RW 0x1
3 CLK_SYS_SPI1 RW 0x1
2 CLK_PERI_SPI1 RW 0x1
1 CLK_SYS_SPI0 RW 0x1
0 CLK_PERI_SPI0 RW 0x1
CLOCKS : ENABLED0 Register
Offset : 0xbc
RP2350 Datasheet
8.1. Overview 551
Description
indicates the state of the clock enable
Table 591. ENABLED0
RegisterBits Description Type Reset
31 CLK_SYS_SIO RO 0x0
30 CLK_SYS_SHA256 RO 0x0
29 CLK_SYS_PSM RO 0x0
28 CLK_SYS_ROSC RO 0x0
27 CLK_SYS_ROM RO 0x0
26 CLK_SYS_RESETS RO 0x0
25 CLK_SYS_PWM RO 0x0
24 CLK_SYS_POWMAN RO 0x0
23 CLK_REF_POWMAN RO 0x0
22 CLK_SYS_PLL_USB RO 0x0
21 CLK_SYS_PLL_SYS RO 0x0
20 CLK_SYS_PIO2 RO 0x0
19 CLK_SYS_PIO1 RO 0x0
18 CLK_SYS_PIO0 RO 0x0
17 CLK_SYS_PADS RO 0x0
16 CLK_SYS_OTP RO 0x0
15 CLK_REF_OTP RO 0x0
14 CLK_SYS_JTAG RO 0x0
13 CLK_SYS_IO RO 0x0
12 CLK_SYS_I2C1 RO 0x0
11 CLK_SYS_I2C0 RO 0x0
10 CLK_SYS_HSTX RO 0x0
9 CLK_HSTX RO 0x0
8 CLK_SYS_GLITCH_DETECTOR RO 0x0
7 CLK_SYS_DMA RO 0x0
6 CLK_SYS_BUSFABRIC RO 0x0
5 CLK_SYS_BUSCTRL RO 0x0
4 CLK_SYS_BOOTRAM RO 0x0
3 CLK_SYS_ADC RO 0x0
2 CLK_ADC_ADC RO 0x0
1 CLK_SYS_ACCESSCTRL RO 0x0
0 CLK_SYS_CLOCKS RO 0x0
CLOCKS : ENABLED1 Register
Offset : 0xc0
RP2350 Datasheet
8.1. Overview 552
Description
indicates the state of the clock enable
Table 592. ENABLED1
RegisterBits Description Type Reset
31 Reserved. - -
30 CLK_SYS_XOSC RO 0x0
29 CLK_SYS_XIP RO 0x0
28 CLK_SYS_WATCHDOG RO 0x0
27 CLK_USB RO 0x0
26 CLK_SYS_USBCTRL RO 0x0
25 CLK_SYS_UART1 RO 0x0
24 CLK_PERI_UART1 RO 0x0
23 CLK_SYS_UART0 RO 0x0
22 CLK_PERI_UART0 RO 0x0
21 CLK_SYS_TRNG RO 0x0
20 CLK_SYS_TIMER1 RO 0x0
19 CLK_SYS_TIMER0 RO 0x0
18 CLK_SYS_TICKS RO 0x0
17 CLK_REF_TICKS RO 0x0
16 CLK_SYS_TBMAN RO 0x0
15 CLK_SYS_SYSINFO RO 0x0
14 CLK_SYS_SYSCFG RO 0x0
13 CLK_SYS_SRAM9 RO 0x0
12 CLK_SYS_SRAM8 RO 0x0
11 CLK_SYS_SRAM7 RO 0x0
10 CLK_SYS_SRAM6 RO 0x0
9 CLK_SYS_SRAM5 RO 0x0
8 CLK_SYS_SRAM4 RO 0x0
7 CLK_SYS_SRAM3 RO 0x0
6 CLK_SYS_SRAM2 RO 0x0
5 CLK_SYS_SRAM1 RO 0x0
4 CLK_SYS_SRAM0 RO 0x0
3 CLK_SYS_SPI1 RO 0x0
2 CLK_PERI_SPI1 RO 0x0
1 CLK_SYS_SPI0 RO 0x0
0 CLK_PERI_SPI0 RO 0x0
CLOCKS : INTR Register
Offset : 0xc4
RP2350 Datasheet
8.1. Overview 553
Description
Raw Interrupts
Table 593. INTR
RegisterBits Description Type Reset
31:1 Reserved. - -
0 CLK_SYS_RESUS RO 0x0
CLOCKS : INTE Register
Offset : 0xc8
Description
Interrupt Enable
Table 594. INTE
RegisterBits Description Type Reset
31:1 Reserved. - -
0 CLK_SYS_RESUS RW 0x0
CLOCKS : INTF Register
Offset : 0xcc
Description
Interrupt Force
Table 595. INTF
RegisterBits Description Type Reset
31:1 Reserved. - -
0 CLK_SYS_RESUS RW 0x0
CLOCKS : INTS Register
Offset : 0xd0
Description
Interrupt status after masking & forcing
Table 596. INTS
RegisterBits Description Type Reset
31:1 Reserved. - -
0 CLK_SYS_RESUS RO 0x0
8.2. Crystal oscillator (XOSC)
8.2.1. Overview
RP2350 Datasheet
8.2. Crystal oscillator (XOSC) 554
Figure 38. The XOSC
is an amplifier. When
a piezoelectric crystal
is connected across
XIN and XOUT, the
amplified feedback
drives the crystal into
mechanical
resonance. This
creates a precise
reference for on-chip
clock generation.
External signals can
also be driven directly
into XIN.
The Crystal Oscillator (XOSC) uses an external crystal to produce an accurate reference clock. RP2350 supports 1 MHz
to 50 MHz crystals and the RP2350 reference design (see Hardware design with RP2350 , Minimal Design Example )
uses a 12 MHz crystal. The reference clock is distributed to the PLLs, which can be used to multiply the XOSC frequency
to provide accurate high speed clocks. For example, they can generate a 48 MHz clock which meets the frequency
accuracy requirement of the USB interface and a 150 MHz maximum speed system clock. The XOSC clock is also a
clock source for the clock generators and can be used directly if required.
If the user already has an accurate clock source, it is possible to drive an external clock directly into XIN (aka XI), and
disable the oscillator circuit. In this mode XIN can be driven at up to 50 MHz.
To use XOSC clock externally, output it to a GPIO pin using one of the clk_gpclk0 -clk_gpclk3  generators. You cannot take
XOSC output directly from the XIN (XI) or XOUT (XO) pins.
NOTE
A minimum crystal frequency of 5 MHz is needed for the PLL. See Section 8.6, “PLL” .
8.2.1.1. Recommended crystals
For the best performance and stability across typical operating temperature ranges, it is recommended to use the
Abracon ABM8-272-T3. You can source the ABM8-272-T3  directly from Abracon or from an authorised reseller. The
Abracon ABM8-272-T3 has the following specifications:
Table 597. Key Crystal
Specifications.Parameters Minimum Typical Maximum Units Notes
Center Frequency 12.000 12.000 12.000 MHz
Operation Mode Fundamental-AT Fundamental-AT Fundamental-AT
Operating Temperature -40 +85 °C
Storage Temperature -55 +125 °C
Frequency Tolerance (25 °C) -30 +30 ppm
Frequency Stability (25 °C) -30 +30 ppm
Equivalent Series Resistance (R1) 50 Ω
Shunt Capacitance (C0) 3.0 pF
Load Capacitance (CL) 10 10 10 pF
Drive Level 10 200 μW
Aging -5 +5 ppm @25±3 °C, 1st year
Insulation Resistance 500 MΩ @100 Vdc±15 V
Even if you use a crystal with similar specifications, you will need to test the circuit over a range of temperatures to
RP2350 Datasheet
8.2. Crystal oscillator (XOSC) 555
ensure stability.
The crystal oscillator is powered from the VDDIO voltage. As a result, the Abracon crystal and that particular damping
resistor are tuned for 3.3V operation. If you use a different IO voltage, you will need to re-tune.
Any changes to crystal parameters risk instability across any components connected to the crystal circuit.
If you can’t source the recommended crystal directly from Abracon or a reseller, contact applications@raspberrypi.com .
Raspberry Pi Pico 2 has been specifically tuned for the specifications of the Abracon ABM8-272-T3 crystal. For an
example of how to use a crystal with RP2350, see the Raspberry Pi Pico 2 board schematic in Appendix B of Raspberry
Pi Pico 2 Datasheet  and the Raspberry Pi Pico 2 design files .
8.2.2. Changes from RP2040
•Maximum crystal frequency increased from 15 MHz to 50 MHz, when appropriate range is selected in
CTRL .FREQ_RANGE
NOTE
The above change applies when using the XOSC as a crystal oscillator, with a crystal connected between the XIN and
XOUT pins. When using the XOSC XIN pin as a CMOS clock input from an external oscillator, the maximum is always
50 MHz. You do not have to configure CTRL .FREQ_RANGE for the CMOS input case. The CMOS input behaviour is
the same as RP2040.
NOTE
The maximum clk_ref frequency is 25 MHz. If you use a >25 MHz crystal as the source of clk_ref, you must divide
the XOSC output using the clk_ref divider.
8.2.3. Usage
The XOSC is disabled on chip startup and RP2350 boots using the Ring Oscillator (ROSC). To start the XOSC, the
programmer must set the CTRL_ENABLE  register. The XOSC is not immediately usable because it takes time for the
oscillations to build to sufficient amplitude. This time will be dependent on the chosen crystal but will be of the order of
a few milliseconds. The XOSC incorporates a timer controlled by the STARTUP_DELAY  register to automatically manage this,
which sets a flag ( STATUS_STABLE ) when the XOSC clock is usable.
8.2.4. Startup delay
The STARTUP_DELAY  register specifies how many clock cycles must be seen from the crystal before it can be used. This is
specified in multiples of 256. The SDK xosc_init  function sets this value. The 1 ms default is sufficient for the RP2350
reference design (see Hardware design with RP2350 , Minimal Design Example ) which runs the XOSC at 12 MHz. When
the timer expires, the STATUS_STABLE  flag will be set to indicate the XOSC output can be used.
Before starting the XOSC the programmer must ensure the STARTUP_DELAY  register is correctly configured. The required
value can be calculated by:
So with a 12 MHz crystal and a 1 ms wait time, the calculation is:
RP2350 Datasheet
8.2. Crystal oscillator (XOSC) 556
NOTE
The value is rounded up to the nearest integer, so the wait time will be just over 1 ms.
8.2.5. XOSC counter
The COUNT register provides a method of managing short software delays. To use this method:
1.Write a value to the COUNT register. The register automatically begins to count down to zero at the XOSC frequency.
2.Poll the register until it reaches zero.
This is preferable to using NOPs in software loops because it is independent of the core clock frequency, the compiler,
and the execution time of the compiled code.
8.2.6. DORMANT mode
In DORMANT mode (see Section 6.5.3, “DORMANT state” ), all of the on-chip clocks can be paused to save power. This
is particularly useful in battery-powered applications. RP2350 wakes from DORMANT mode by interrupt: either from an
external event, such as an edge on a GPIO pin, or from the AON Timer. This must be configured before entering
DORMANT mode. To use the AON Timer to trigger a wake from DORMANT mode, it must be clocked from the LPOSC or
from an external source.
To enter DORMANT mode:
1.Switch all internal clocks to be driven from XOSC or ROSC and stop the PLLs.
2.Choose an oscillator (XOSC or ROSC). Write a specific 32-bit value to the DORMANT register of the chosen oscillator to
stop it.
When exiting DORMANT mode, the chosen oscillator will restart. If you chose XOSC, the frequency will be more precise,
but the restart will take more time due to startup delay (>1 ms on the RP2350 reference design (see Hardware design
with RP2350 , Minimal Design Example )). If you chose ROSC, the frequency will be less precise, but the start-up time is
very short (approximately 1μs). See Section 6.5.3.1, “Waking from the DORMANT state”  for the events which cause the
system to exit DORMANT mode.
NOTE
You must stop the PLLs before entering DORMANT mode.
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_xosc/xosc.c  Lines 56 - 63
56 void xosc_dormant (void) {
57     // WARNING: This stops the xosc until woken up by an irq
58     xosc_hw->dormant = XOSC_DORMANT_VALUE_DORMANT ;
59     // Wait for it to become stable once woken up
60     while(!(xosc_hw->status & XOSC_STATUS_STABLE_BITS )) {
61         tight_loop_contents ();
62     }
63 }
RP2350 Datasheet
8.2. Crystal oscillator (XOSC) 557
WARNING
If you do not configure IRQ before entering DORMANT mode, neither oscillator will restart.
See Section 6.5.6.2, “DORMANT”  for a complete example of DORMANT mode using the XOSC.
8.2.7. Programmer’s model
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2350/hardware_structs/include/hardware/structs/xosc.h  Lines 27 - 57
27 typedef struct {
28     _REG_(XOSC_CTRL_OFFSET ) // XOSC_CTRL
29     // Crystal Oscillator Control
30     // 0x00fff000 [23:12] ENABLE       (-) On power-up this field is initialised to DISABLE and
   the...
31     // 0x00000fff [11:0]  FREQ_RANGE   (-) The 12-bit code is intended to give some
   protection...
32     io_rw_32  ctrl;
33 
34     _REG_(XOSC_STATUS_OFFSET ) // XOSC_STATUS
35     // Crystal Oscillator Status
36     // 0x80000000 [31]    STABLE       (0) Oscillator is running and stable
37     // 0x01000000 [24]    BADWRITE     (0) An invalid value has been written to CTRL_ENABLE
   or...
38     // 0x00001000 [12]    ENABLED      (-) Oscillator is enabled but not necessarily running
   and...
39     // 0x00000003 [1:0]   FREQ_RANGE   (-) The current frequency range setting
40     io_rw_32  status;
41 
42     _REG_(XOSC_DORMANT_OFFSET ) // XOSC_DORMANT
43     // Crystal Oscillator pause control
44     // 0xffffffff [31:0]  DORMANT      (-) This is used to save power by pausing the XOSC +
45     io_rw_32  dormant;
46 
47     _REG_(XOSC_STARTUP_OFFSET ) // XOSC_STARTUP
48     // Controls the startup delay
49     // 0x00100000 [20]    X4           (-) Multiplies the startup_delay by 4, just in case
50     // 0x00003fff [13:0]  DELAY        (-) in multiples of 256*xtal_period
51     io_rw_32  startup;
52 
53     _REG_(XOSC_COUNT_OFFSET ) // XOSC_COUNT
54     // A down counter running at the XOSC frequency which counts to zero and stops.
55     // 0x0000ffff [15:0]  COUNT        (0x0000)
56     io_rw_32  count;
57 } xosc_hw_t ;
SDK: https://github.com/raspberrypi/pico-sdk/blob/master/src/rp2_common/hardware_xosc/xosc.c  Lines 29 - 43
29 void xosc_init (void) {
30     // Assumes 1-15 MHz input, checked above.
31     xosc_hw->ctrl = XOSC_CTRL_FREQ_RANGE_VALUE_1_15MHZ ;
32 
33     // Set xosc startup delay
34     xosc_hw->startup = STARTUP_DELAY ;
35 
36     // Set the enable bit now that we have set freq range and startup delay
37     hw_set_bits (&xosc_hw->ctrl, XOSC_CTRL_ENABLE_VALUE_ENABLE  << XOSC_CTRL_ENABLE_LSB );
38 
RP2350 Datasheet
8.2. Crystal oscillator (XOSC) 558
39     // Wait for XOSC to be stable
40     while(!(xosc_hw->status & XOSC_STATUS_STABLE_BITS )) {
41         tight_loop_contents ();
42     }
43 }
8.2.8. List of registers
The XOSC registers start at a base address of 0x40048000  (defined as XOSC_BASE  in SDK).
Table 598. List of
XOSC registersOffset Name Info
0x00 CTRL Crystal Oscillator Control
0x04 STATUS Crystal Oscillator Status
0x08 DORMANT Crystal Oscillator pause control
0x0c STARTUP Controls the startup delay
0x10 COUNT A down counter running at the XOSC frequency which counts to
zero and stops.
XOSC : CTRL Register
Offset : 0x00
Description
Crystal Oscillator Control
Table 599. CTRL
RegisterBits Description Type Reset
31:24 Reserved. - -
23:12 ENABLE : On power-up this field is initialised to DISABLE and the chip runs
from the ROSC.
If the chip has subsequently been programmed to run from the XOSC then
setting this field to DISABLE may lock-up the chip. If this is a concern then run
the clk_ref from the ROSC and enable the clk_sys RESUS feature.
The 12-bit code is intended to give some protection against accidental writes.
An invalid setting will retain the previous value. The actual value being used
can be read from STATUS_ENABLEDRW -
Enumerated values:
0xd1e → DISABLE
0xfab → ENABLE
11:0 FREQ_RANGE : The 12-bit code is intended to give some protection against
accidental writes. An invalid setting will retain the previous value. The actual
value being used can be read from STATUS_FREQ_RANGERW -
Enumerated values:
0xaa0 → 1_15MHZ
0xaa1 → 10_30MHZ
0xaa2 → 25_60MHZ
0xaa3 → 40_100MHZ
RP2350 Datasheet
8.2. Crystal oscillator (XOSC) 559
XOSC : STATUS Register
Offset : 0x04
Description
Crystal Oscillator Status
Table 600. STATUS
RegisterBits Description Type Reset
31 STABLE : Oscillator is running and stable RO 0x0
30:25 Reserved. - -
24 BADWRITE : An invalid value has been written to CTRL_ENABLE or
CTRL_FREQ_RANGE or DORMANTWC 0x0
23:13 Reserved. - -
12 ENABLED : Oscillator is enabled but not necessarily running and stable, resets
to 0RO -
11:2 Reserved. - -
1:0 FREQ_RANGE : The current frequency range setting RO -
Enumerated values:
0x0 → 1_15MHZ
0x1 → 10_30MHZ
0x2 → 25_60MHZ
0x3 → 40_100MHZ
XOSC : DORMANT Register
Offset : 0x08
Description
Crystal Oscillator pause control
Table 601. DORMANT
RegisterBits Description Type Reset
31:0 This is used to save power by pausing the XOSC
On power-up this field is initialised to WAKE
An invalid write will also select WAKE
WARNING: stop the PLLs before selecting dormant mode
WARNING: setup the irq before selecting dormant modeRW -
Enumerated values:
0x636f6d61 → DORMANT
0x77616b65 → WAKE
XOSC : STARTUP Register
Offset : 0x0c
Description
Controls the startup delay
Table 602. STARTUP
RegisterBits Description Type Reset
31:21 Reserved. - -
RP2350 Datasheet
8.2. Crystal oscillator (XOSC) 560
Bits Description Type Reset
20 X4: Multiplies the startup_delay by 4, just in case. The reset value is controlled
by a mask-programmable tiecell and is provided in case we are booting from
XOSC and the default startup delay is insufficientRW 0x0
19:14 Reserved. - -
13:0 DELAY : in multiples of 256*xtal_period. The reset value of 0xc4 corresponds
to approx 50 000 cycles.RW 0x00c4
XOSC : COUNT Register
Offset : 0x10
Table 603. COUNT
RegisterBits Description Type Reset
31:16 Reserved. - -
15:0 A down counter running at the xosc frequency which counts to zero and stops.
Can be used for short software pauses when setting up time sensitive
hardware.
To start the counter, write a non-zero value. Reads will return 1 while the count
is running and 0 when it has finished.
Minimum count value is 4. Count values <4 will be treated as count value =4.
Note that synchronisation to the register clock domain costs 2 register clock
cycles and the counter cannot compensate for that.RW 0x0000
8.3. Ring oscillator (ROSC)
8.3.1. Overview
The Ring Oscillator (ROSC) is an on-chip oscillator built from a ring of inverters. It requires no external components and
is started automatically during RP2350 power up. It provides the clock to the cores during boot. The frequency of the
ROSC is programmable and it can directly provide a high speed clock to the cores, but the frequency varies with
Process, Voltage, and Temperature (PVT) so it cannot provide clocks for components that require an accurate
frequency such as the AON Timer, USB, and ADC. The frequency can be randomised to provide some protection against
attempts to recover the system clock from power traces. Methods for mitigating unwanted frequency variation are
discussed in Section 8.1, “Overview” , but these are only relevant to very low power designs. For most applications
requiring accurate clock frequencies, switch to the XOSC and PLLs. During boot, the ROSC runs at a nominal 11MHz
and is guaranteed to be in the range 4.6MHz to 19.6MHz without randomisation and 4.6MHz to 24.0MHz with
randomisation.
NOTE
RP2350 A3 and later enable randomisation by default, and the bootrom quadruples the ROSC base frequency by
reducing DIV to 2. As a result, clk_sys is guaranteed to range between 18.4 MHz and 96.0 MHz. clk_ref is maintained
at a nominal 11 MHz by increasing its divisor. This change increases the sensitivity of the glitch detectors, which
have an inverse relationship with clock period, consequently better protecting the ROM’s early boot paths.
After the chip has booted, the programmer can choose to continue running from the ROSC and increase its frequency or
start the Crystal Oscillator (XOSC) and PLLs. You can disable the ROSC when you’ve switched the system clocks to the
XOSC. Each oscillator has advantages; switch between them to achieve the best solution for your application.
RP2350 Datasheet
8.3. Ring oscillator (ROSC) 561
Figure 39. ROSC
overview.
8.3.2. Changes from RP2040
Frequency randomisation feature added.
8.3.3. Changes between RP2350 revisions
RP2350 A3 changes the reset values of FREQA .DS0_RANDOM and FREQA .DS1_RANDOM from 0 to 1. See Hardware
changes  for information about related changes made to the clock configuration at reset. See Bootrom changes  for
related changes made in the A3 boot ROM.
8.3.4. ROSC/XOSC trade-offs
The ROSC has several advantages:
•Flexibility due to programmable frequency
•Low power requirements
•No need for internal or external components
•Optional frequency randomisation improves security
Because the ROSC has programmable frequency, it can provide a fast core clock without starting the PLLs and can
generate slower peripheral clocks by dividing by clock generators ( Section 8.1, “Overview” ). The ROSC starts
immediately and responds immediately to frequency controls. It retains the frequency setting when entering and exiting
the DORMANT state (see Section 6.5.3, “DORMANT state” ). However, the user must be aware that the frequency may
have drifted when exiting the DORMANT state due to changes in the supply voltage and the chip temperature.
The disadvantage of the ROSC is its frequency variation with PVT (Process, Voltage, and Temperature), which makes it
unsuitable for generating precise clocks or for applications where software execution timing is important. However, the
PVT frequency variation can be exploited to provide automatic frequency scaling to maximise performance. This is
discussed in Section 8.1, “Overview” .
The only advantage of the XOSC is its accurate frequency, but this is an overriding requirement in many applications.
The XOSC has the following disadvantages:
•the requirement for external components (a crystal, etc.)
•higher power consumption
•slow startup time (>1ms)
•fixed, low frequency
PLLs are required to produce higher-frequency clocks. They consume more power and take significant time to start up
or change frequency. Exiting DORMANT mode is much slower than for ROSC because the XOSC must restart and the
PLLs must be reconfigured.
RP2350 Datasheet
8.3. Ring oscillator (ROSC) 562
8.3.5. Modifying the frequency
The ROSC is arranged as 8 stages, each with programmable drive. The ROSC provides two methods of controlling the
frequency. The frequency range controls the number of stages in the ROSC loop and the FREQA & FREQB registers control
the drive strength of the stages.
To change the frequency range, write to the FREQ_RANGE  register, which controls the number of stages in the ROSC loop.
The FREQ_RANGE  register supports the following configurations:
Table 604. ROSC
stage rangesName Number of stages Range (stages)
LOW 8 0-7
MEDIUM 6 2-7
HIGH 4 4-7
TOOHIGH 2 6-7
Change FREQ_RANGE  one step at a time until you reach the desired range. When increasing the frequency range, ROSC
output will not glitch, so the output clock can continue to be used. When decreasing the frequency range, ROSC output
will glitch, so you must select an alternate clock source for the modules clocked by ROSC or hold them in reset during
the transition.
The behaviour has not been fully characterised, but the MEDIUM range will be approximately 1.33 times the LOW range, the
HIGH range will be 2 times the LOW range and the TOOHIGH range will be 4 times the LOW range. The TOOHIGH range is aptly
named. It should not be used because the internal logic of the ROSC will not run at that frequency.
The FREQA and FREQB registers control the drive strength of the stages in the ROSC loop. As the drive strength increases,
the delay through the stage decreases and the oscillation frequency increases. Each stage has 3 drive strength control
bits. Each bit turns on an additional drive, therefore each stage has 4 drive strength settings equal to the number of bits
set, with 0 being the default, 1 being double drive, 2 being triple drive and 3 being quadruple drive. Extra drives do not
have a linear effect on frequency: the second has less impact than the first, the third has less impact than the second,
and so on. To ensure smooth transitions, change one drive strength bit at a time. When FREQ_RANGE  shortens the ROSC
loop, the bypassed stages still propagate the signal and therefore their drive strengths must be set to at least the same
level as the lowest drive strength in the stages that are in the loop. This will not affect the oscillation frequency.
8.3.6. Randomising the frequency
Randomisation is enabled by setting the drive strength controls for the first two stages of the ROSC loop to DS0_RANDOM 
and DS1_RANDOM . An LFSR then provides the drive strength controls for those two stages which are always included in the
loop regardless of the FREQ_RANGE  setting. It is recommended to randomise both stages. When the low FREQ_RANGE  is
selected the randomiser will increase the frequency by up to 22% of the default. The increase will be approximately half
of that if only one stage is randomised. The LFSR can be seeded by writing to the RANDOM register. This can be done at
any time but will restart the randomiser.
8.3.7. ROSC divider
The ROSC frequency is too fast to be used directly, so it is divided in an integer divider controlled by the DIV register. You
can change DIV while the ROSC is running, and the output clock will change frequency without glitching. The default
divisor is 8, which ensures the output clock is in the specified range on chip startup.
The divider has two outputs, rosc_clksrc  and rosc_clksrc_ph . rosc_clksrc_ph  is a phase shifted version of rosc_clksrc . This
is primarily intended for use during product development; the outputs are identical if the PHASE register is left in its
default state.
RP2350 Datasheet
8.3. Ring oscillator (ROSC) 563
8.3.8. Random number generator
When the system clocks are running from the XOSC, you can use the ROSC to generate random numbers. Enable the
ROSC and read the RANDOMBIT  register to get a 1-bit random number; to get an n-bit value, read it n times. This does not
meet the requirements of randomness for security systems because it can be compromised, but it may be useful in less
critical applications. If the cores are running from the ROSC, the value will not be random because the timing of the
register read will be correlated to the phase of the ROSC.
8.3.9. ROSC counter
The COUNT register provides a method of managing short software delays. To use this method:
1.Write a value to the COUNT register. The register automatically begins to count down to zero at the ROSC frequency.
2.Poll the register until it reaches zero.
This is preferable to using NOPs in software loops because it is independent of the core clock frequency, the compiler,
and the execution time of the compiled code.
8.3.10. DORMANT mode
In DORMANT mode (see Section 6.5.3, “DORMANT state” ), all of the on-chip clocks can be paused to save power. This
is particularly useful in battery-powered applications. RP2350 wakes from DORMANT mode by interrupt: either from an
external event, such as an edge on a GPIO pin, or from the AON Timer. This must be configured before entering
DORMANT mode. To use the AON Timer to trigger a wake from DORMANT mode, it must be clocked from the LPOSC or
from an external source.
To enter DORMANT mode:
1.Switch all internal clocks to be driven from XOSC or ROSC and stop the PLLs.
2.Choose an oscillator (XOSC or ROSC). Write a specific 32-bit value to the DORMANT register of the chosen oscillator to
stop it.
When exiting DORMANT mode, the chosen oscillator will restart. If you chose XOSC, the frequency will be more precise,
but the restart will take more time due to startup delay (>1ms on the RP2350 reference design (see Hardware design
with RP2350 , Minimal Design Example )). If you chose ROSC, the frequency will be less precise, but the start-up time is
very short (approximately 1μs). See Section 6.5.3.1, “Waking from the DORMANT state”  for the events which cause the
system to exit DORMANT mode.
NOTE
You must stop the PLLs before entering DORMANT mode.
Pico Extras: https://github.com/raspberrypi/pico-extras/blob/master/src/rp2_common/hardware_rosc/rosc.c  Lines 56 - 61
56 void rosc_set_dormant (void) {
57     // WARNING: This stops the rosc until woken up by an irq
58     rosc_write (&rosc_hw->dormant, ROSC_DORMANT_VALUE_DORMANT );
59     // Wait for it to become stable once woken up
60     while(!(rosc_hw->status & ROSC_STATUS_STABLE_BITS ));
61 }
RP2350 Datasheet
8.3. Ring oscillator (ROSC) 564
WARNING
If you do not configure IRQ before entering DORMANT mode, neither oscillator will restart.
See Section 6.5.6.2, “DORMANT”  for a some examples of dormant mode.
8.3.11. List of registers
The ROSC registers start at a base address of 0x400e8000  (defined as ROSC_BASE  in SDK).
Table 605. List of
ROSC registersOffset Name Info
0x00 CTRL Ring Oscillator control
0x04 FREQA Ring Oscillator frequency control A
0x08 FREQB Ring Oscillator frequency control B
0x0c RANDOM Loads a value to the LFSR randomiser
0x10 DORMANT Ring Oscillator pause control
0x14 DIV Controls the output divider
0x18 PHASE Controls the phase shifted output
0x1c STATUS Ring Oscillator Status
0x20 RANDOMBIT Returns a 1 bit random value
0x24 COUNT A down counter running at the ROSC frequency which counts to
zero and stops.
ROSC : CTRL Register
Offset : 0x00
Description
Ring Oscillator control
Table 606. CTRL
RegisterBits Description Type Reset
31:24 Reserved. - -
23:12 ENABLE : On power-up this field is initialised to ENABLE
The system clock must be switched to another source before setting this field
to DISABLE otherwise the chip will lock up
The 12-bit code is intended to give some protection against accidental writes.
An invalid setting will enable the oscillator.RW -
Enumerated values:
0xd1e → DISABLE
0xfab → ENABLE
RP2350 Datasheet
8.3. Ring oscillator (ROSC) 565
Bits Description Type Reset
11:0 FREQ_RANGE : Controls the number of delay stages in the ROSC ring
LOW uses stages 0 to 7
MEDIUM uses stages 0 to 5
HIGH uses stages 0 to 3
TOOHIGH uses stages 0 to 1 and should not be used because its frequency
exceeds design specifications
The clock output will not glitch when changing the range up one step at a time
The clock output will glitch when changing the range down
Note: the values here are gray coded which is why HIGH comes before
TOOHIGHRW 0xaa0
Enumerated values:
0xfa4 → LOW
0xfa5 → MEDIUM
0xfa7 → HIGH
0xfa6 → TOOHIGH
ROSC : FREQA Register
Offset : 0x04
Description
The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage
The drive strength has 4 levels determined by the number of bits set
Increasing the number of bits set increases the drive strength and increases the oscillation frequency
0 bits set is the default drive strength
1 bit set doubles the drive strength
2 bits set triples drive strength
3 bits set quadruples drive strength
For frequency randomisation set both DS0_RANDOM=1 & DS1_RANDOM=1
Table 607. FREQA
RegisterBits Description Type Reset
31:16 PASSWD : Set to 0x9696 to apply the settings
Any other value in this field will set all drive strengths to 0RW 0x0000
Enumerated values:
0x9696 → PASS
15 Reserved. - -
14:12 DS3: Stage 3 drive strength RW 0x0
11 Reserved. - -
10:8 DS2: Stage 2 drive strength RW 0x0
7 DS1_RANDOM : Randomises the stage 1 drive strength RW 0x1
6:4 DS1: Stage 1 drive strength RW 0x0
3 DS0_RANDOM : Randomises the stage 0 drive strength RW 0x1
2:0 DS0: Stage 0 drive strength RW 0x0
ROSC : FREQB Register
Offset : 0x08
RP2350 Datasheet
8.3. Ring oscillator (ROSC) 566
Description
For a detailed description see freqa register
Table 608. FREQB
RegisterBits Description Type Reset
31:16 PASSWD : Set to 0x9696 to apply the settings
Any other value in this field will set all drive strengths to 0RW 0x0000
Enumerated values:
0x9696 → PASS
